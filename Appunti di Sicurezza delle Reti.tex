%% LyX 2.3.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\RequirePackage{fix-cm}
\documentclass[12pt,italian]{amsbook}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=2cm,bmargin=2.2cm,lmargin=2cm,rmargin=4cm,headheight=2cm,headsep=1cm,footskip=1cm}
\setlength{\parskip}{\smallskipamount}
\setlength{\parindent}{0pt}
\usepackage{babel}
\usepackage{array}
\usepackage{varioref}
\usepackage{refstyle}
\usepackage{units}
\usepackage{textcomp}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{amsbsy}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{cancel}
\makeindex
\usepackage{graphicx}
\usepackage{wasysym}
\PassOptionsToPackage{normalem}{ulem}
\usepackage{ulem}
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=1,
 breaklinks=false,pdfborder={0 0 0},pdfborderstyle={},backref=page,colorlinks=false]
 {hyperref}
\hypersetup{pdftitle={Appunti di Fondamenti di fondamenti di Automatica},
 pdfauthor={Lorenzo Prosseda},
 pdfsubject={Corso di fondamenti di Automatica del prof. Fagiano, Politecnico di Milano 2017-2018},
 pdfkeywords={automatica}}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.

\AtBeginDocument{\providecommand\propref[1]{\ref{prop:#1}}}
\AtBeginDocument{\providecommand\subsecref[1]{\ref{subsec:#1}}}
\AtBeginDocument{\providecommand\secref[1]{\ref{sec:#1}}}
\AtBeginDocument{\providecommand\figref[1]{\ref{fig:#1}}}
\newcommand{\noun}[1]{\textsc{#1}}
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}
\RS@ifundefined{subsecref}
  {\newref{subsec}{name = \RSsectxt}}
  {}
\RS@ifundefined{thmref}
  {\def\RSthmtxt{theorem~}\newref{thm}{name = \RSthmtxt}}
  {}
\RS@ifundefined{lemref}
  {\def\RSlemtxt{lemma~}\newref{lem}{name = \RSlemtxt}}
  {}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{section}{chapter}
\numberwithin{equation}{section}
\numberwithin{figure}{section}
\numberwithin{table}{section}
\theoremstyle{plain}
    \ifx\thechapter\undefined
	    \newtheorem{thm}{\protect\theoremname}
	  \else
      \newtheorem{thm}{\protect\theoremname}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{example}{\protect\examplename}
    \else
      \newtheorem{example}{\protect\examplename}[chapter]
    \fi
\theoremstyle{plain}
    \ifx\thechapter\undefined
      \newtheorem{prop}{\protect\propositionname}
    \else
      \newtheorem{prop}{\protect\propositionname}[chapter]
    \fi
\theoremstyle{remark}
    \ifx\thechapter\undefined
      \newtheorem{rem}{\protect\remarkname}
    \else
      \newtheorem{rem}{\protect\remarkname}[chapter]
    \fi
\theoremstyle{plain}
    \ifx\thechapter\undefined
  \newtheorem{cor}{\protect\corollaryname}
\else
      \newtheorem{cor}{\protect\corollaryname}[chapter]
    \fi
\theoremstyle{plain}
    \ifx\thechapter\undefined
      \newtheorem{fact}{\protect\factname}
    \else
      \newtheorem{fact}{\protect\factname}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{defn}{\protect\definitionname}
    \else
      \newtheorem{defn}{\protect\definitionname}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{problem}{\protect\problemname}
    \else
      \newtheorem{problem}{\protect\problemname}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{xca}{\protect\exercisename}
    \else
      \newtheorem{xca}{\protect\exercisename}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{sol}{\protect\solutionname}
    \else
      \newtheorem{sol}{\protect\solutionname}[chapter]
    \fi
\newenvironment{lyxlist}[1]
	{\begin{list}{}
		{\settowidth{\labelwidth}{#1}
		 \setlength{\leftmargin}{\labelwidth}
		 \addtolength{\leftmargin}{\labelsep}
		 \renewcommand{\makelabel}[1]{##1\hfil}}}
	{\end{list}}

\@ifundefined{date}{}{\date{}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{pgfplots}
\usepackage{caption}
\captionsetup{font=scriptsize,labelfont=scriptsize}
\usepackage{geometry}
\usepackage{marginnote}
\usepackage{imakeidx}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{hyphenat}

\renewcommand{\marginpar}[1]{\marginnote{\footnotesize #1}}
\setlength\marginparsep{0.3cm}
\setlength\marginparwidth{3cm}
\newcommand\xqed[1]{%
  \leavevmode\unskip\penalty9999 \hbox{}\nobreak\hfill
  \quad\hbox{#1}}
\newcommand\demo{\xqed{$\square$}}
\newcommand\sln[1]{\xqed{$\scriptstyle Sol.\,#1$}}
\makeindex

\makeatother

\providecommand{\corollaryname}{Corollario}
\providecommand{\definitionname}{Definizione}
\providecommand{\examplename}{Esempio}
\providecommand{\exercisename}{Esercizio}
\providecommand{\factname}{Fatto}
\providecommand{\problemname}{Problema}
\providecommand{\propositionname}{Proposizione}
\providecommand{\remarkname}{Osservazione}
\providecommand{\solutionname}{Soluzione}
\providecommand{\theoremname}{Teorema}

\begin{document}
\newgeometry{margin=1cm}
\title{Appunti di Sicurezza delle reti}
\author{Lorenzo Prosseda, a.a. 2018-2019}
\dedicatory{
\begin{figure}[!h]
\vspace{20cm}
\includegraphics{Illustrazioni/gfdl-logo}
\end{figure}
Copyright \textcopyright 2019 Lorenzo Prosseda. Permission is granted
to copy, distribute and/or modify this document under the terms of
the GNU Free Documentation License, Version 1.3 or any later version
published by the Free Software Foundation; with no Invariant Sections,
no Front-Cover Texts, and no Back-Cover Texts. A copy of the license
is included in the file called \textquotedbl LICENSE\textquotedbl .}

\maketitle
\restoregeometry

\tableofcontents{}

\global\long\def\lm#1#2#3{\underset{{\scriptstyle #1\rightarrow#2}}{\lim}#3}%

\global\long\def\serie#1#2#3{\overset{{\scriptstyle #2}}{\underset{{\scriptstyle #1}}{\sum}}#3}%

\global\long\def\somme#1#2#3#4{\underset{{\scriptstyle #1}}{\overset{{\scriptstyle #2}}{\int}}#3d#4}%

\global\long\def\mcd#1#2{\mathrm{{\scriptstyle MCD}}\left(#1,\,#2\right)}%

\global\long\def\mcm#1#2{\mathrm{{\scriptstyle mcm}}\left(#1,\,#2\right)}%

\global\long\def\cgm#1#2#3{#1\equiv#2\left(\text{mod}\,#3\right)}%

\global\long\def\ncgm#1#2#3{#1\not\equiv#2\left(\text{mod}\,#3\right)}%

\global\long\def\cgms#1#2#3#4{#1\overset{#4}{\equiv}#2\left(\text{mod}\,#3\right)}%

\global\long\def\mod#1#2{#1\,\text{mod}\,#2}%

\global\long\def\ord#1{\mathrm{{\scriptstyle ORD}}\left(#1\right)}%

\global\long\def\nirr#1#2{N_{{\scriptscriptstyle irr}}\left(#1,\,#2\right)}%

\global\long\def\logd#1#2{\mathrm{\mathcal{L}_{#1}}\left(#2\right)}%

\global\long\def\tc{\,:\,}%


\part{Crittografia}

\chapter{Teoria dei numeri}

\section{Proprietà degli interi}

Da ora in avanti parleremo di numeri interi, positivi o negativi,
operando all'interno dell'insieme $\mathbb{Z}$; enunciamo la proprietà
di divisione nel modo seguente: presi due interi $a,\,b\in\mathbb{Z}$
non uguali ($a\neq b$) si dice che $a$ divide $b$ quando $a$ è
un divisore di $b$, ovvero
\[
a\backslash b\implies\exists k\tc b=k\cdot a
\]

Dalla precedente deduciamo che $b$ dovrà essere un multiplo di $a$.
Inoltre, otteniamo anche che:
\[
\forall a\in\mathbb{Z}\,:\,a\backslash0;\;\nexists a\in\mathbb{Z}\tc0\backslash a;\;\forall a\in\mathbb{Z}\,:\,a\backslash a
\]

La relazione di divisione introdotta ammette la proprietà transitiva:
\[
\forall a,b,c\in\mathbb{Z}\,\land\,a\neq b\neq c\tc a\backslash b\,\land\,b\backslash c\implies a\backslash c
\]


\section{Numeri primi}

\subsection{Definizione e proprietà}

Un numero $a$ si dice primo quando è divisibile solo per 1 e per
sé stesso (ovvero se vale $\forall b\in\mathbb{Z}\tc b\backslash a\iff b=1\,\lor\,b=a$);
un numero composto è scomponibile in un numero finito di fattori,
e questa scomposizione è unica. Determinare la primalità di un numero
tuttavia non è cosa facile; introduciamo il seguente teorema:
\begin{thm}
Sia $\pi\left(n\right)\coloneqq$``numero di numeri primi fino a
$n$'', allora vale\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema dei numeri primi}{\footnotesize{}\index{Numeri primi, teorema@{\footnotesize{}Numeri primi, teorema}}\label{thm:Numeri-primi}}}[0.1cm]
\[
\pi\left(n\right)\sim\dfrac{n}{\ln\left(n\right)}
\]
\end{thm}
Alcuni algoritmi crittografici usano i numeri primi come ``ingredienti''
per creare le chiavi: in questi casi il teorema introdotto si dimostra
molto utile per determinare la quantità di numeri primi che è possibile
ottenere con una data quantità di cifre.
\begin{example}
Determinare una stima della quantità di numeri primi che è possibile
ottenere a partire da 100 cifre.

$\checked$Usando il Teorema \ref{thm:Numeri-primi} possiamo scrivere
la quantità di numeri primi con 100 cifre come
\[
\pi\left(10^{100}\right)-\pi\left(10^{99}\right)=\frac{10^{100}}{100\ln\left(10\right)}-\frac{10^{99}}{99\ln\left(10\right)}\simeq\boxed{10^{97}}
\]
\demo
\end{example}
Se fossimo nel contesto di un algoritmo di cifratura, pur sapendo
che la chiave sia un numero primo di 100 cifre, dovremmo analizzare
in ogni caso $10^{97}$ possibili candidati.

Prendiamo\marginpar{La funzione $\protect\mcd ab$ indica il massimo comune divisore tra
$a$ e $b$} ora $a,\,b\in\mathbb{Z}$ tali che $\mcd ab=1$: in tal caso diremo
che $a$ e $b$ sono \emph{coprimi} o \emph{primi relativi}, indicando
la loro relazione come $a\perp b$; da questa relazione segue che
due numeri coprimi non hanno fattori in comune.

Escluso il numero 2, tutti i primi sono dispari, e sono divisi in
due classi: preso un numero primo $p$, esso appartiene a una delle
seguenti classi:
\begin{itemize}
\item $\cgm p14$
\item $\cgm p34$
\end{itemize}
L'operatore $\equiv$ indica la congruenza in modulo: si dice che
un numero $a\in\mathbb{Z}$ è \emph{congruente a 1 modulo $n$} (e
si scrive $\cgm a1n$) se il resto della divisione di $a$ per $n$
è 1.

Componendo le due classi osserviamo che tutti i numeri primi $p$
possono essere indicati come 
\begin{equation}
p=6k\pm1\implies\cgm p{\pm1}6,\,k\in\mathbb{Z}\label{eq:Successione-primi-classi}
\end{equation}
Troveremo per esempio $p_{k=1}=6\pm1=\left\{ 5,\,7\right\} ,\,p_{k=2}=12\pm1=\left\{ 11,\,13\right\} ,\,p_{k=3}=18\pm1=\left\{ 17,\,19\right\} ,\,\ldots\,$;
osserviamo che tutti i numeri della successione appena definita sono
primi, tuttavia non tutti i primi appartengono a questa successione.

\subsection{Test di primalità con classi}

Possiamo usare la successione (\ref{eq:Successione-primi-classi})
per testare la primalità di un numero intero: sia $n>0$ un numero
del quale si vuole conoscere la primalità; allora definiamo un algoritmo
iterativo che costruisce la successione (\ref{eq:Successione-primi-classi})
incrementando $k$, e per ogni primo $p_{k}$ ottenuto, se non vale
$p_{k}\backslash n$ fino a che $6k+1\leq\sqrt{n}$, allora $n$ è
primo.

\section{Algoritmo di Euclide}

\subsection{Definizione della successione}

La funzione principale di questo algoritmo, è calcolare il massimo
comune divisore di due numeri; presi due interi $m$ e $n$ tali che
$m<n$, vogliamo calcolare $\mcd mn$. Tramite questo algoritmo otteniamo
il risultato desiderato, senza passare per la scomposizione in fattori
primi di $m$ e $n$; definendo la seguente successione:
\begin{align}
\mcd mn & =\mcd{\mod nm}n\label{eq:Successione-Euclide}\\
 & =\mcd{\mod{\left(\mod nm\right)}n}n\nonumber \\
 & =\mcd 0n=n\nonumber 
\end{align}

Osserviamo come calcolare questa successione con un esempio.
\begin{example}
\emph{Calcolare il massimo comune divisore tra 482 e 1180}

$\checked$Procediamo applicando la definizione (\ref{eq:Successione-Euclide}):
per farlo dovremo scomporre il numero maggiore ($n$ dalla definizione)
usando il suo modulo rispetto al minore ($m$); in pratica prendiamo
1180 e lo dividiamo per 482, conservando il residuo dell'operazione
da usare nel termine successivo della successione
\[
\mcd{482}{1180}\rightarrow1180=2\cdot482+216
\]
proseguiamo lavorando col resto del passo precedente (216) e col valore
precedentemente usato per calcolare il modulo (482)
\begin{align*}
\mcd{216}{482} & \rightarrow482=2\cdot216+50\\
\mcd{50}{216} & \rightarrow216=4\cdot50+16\\
\mcd{16}{50} & \rightarrow3\cdot16+\boldsymbol{2}=\boldsymbol{d}\\
\mcd 2{16} & \rightarrow8\cdot2+\boxed{0}
\end{align*}
La successione termina quando si ottiene resto zero; il resto chiamato
$d$, ottenuto alla penultima riga (sopra a quella con resto 0, vale
2 in questo caso) è effettivamente il risultato della richiesta: $\mcd{482}{1180}=2$\demo
\end{example}

\subsection{Algoritmo in forma simbolica}

Presi $a,\,b\in\mathbb{Z}$ tali che $a<b$, otteniamo $\mcd ab=d$
applicando (\ref{eq:Successione-Euclide}) nel seguente modo:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Algoritmo di Euclide}{\footnotesize{}\index{Euclide, algoritmo di@{\footnotesize{}Euclide, algoritmo di}}}}[1.8cm]
\begin{equation}
\begin{array}{c}
b=q_{1}\cdot a+r_{1}\\
a=q_{2}\cdot r_{1}+r_{2}\\
r_{1}=q_{3}\cdot r_{2}+r_{3}\\
\vdots\\
r_{k-2}=q_{k}\cdot r_{k-1}+r_{k}\\
r_{k-1}=q_{k+1}\cdot r_{k}+0\\
\boxed{r_{k}=d}
\end{array}\label{eq:Algoritmo-Euclide}
\end{equation}
dove $q_{i}$ è l'$i$-esimo quoziente e $r_{i}$ è l'$i$-esimo resto;
dall'algoritmo si può dedurre che, presi $a,\,b\neq0$ e sia $d=\mcd ab$,
allora è vero che $\exists x,\,y\in\mathbb{Z}\tc a\cdot x+b\cdot y=d$.
Questo risulta chiaro se immaginiamo che i due interi cercati siano
anche negativi; per trovare tali interi è necessario utilizzare una
estensione del (\ref{eq:Algoritmo-Euclide}).

\subsection{Algoritmo esteso}

L'algoritmo di Euclide presentato nella sottosezione precedente può
essere esteso, impiegando nel suo svolgimento due successioni $\left\{ x_{k}\right\} $
e $\left\{ y_{k}\right\} $: esse avranno i primi due valori ben definiti,
come
\begin{equation}
x_{0}=0,\,x_{1}=1;\;y_{0}=1,\,y_{1}=0\label{eq:Premessa-successioni-Euclide-esteso}
\end{equation}

Facendo corrispondere ai passi (\ref{eq:Algoritmo-Euclide}) gli elementi
delle successioni $\left\{ x_{k}\right\} $ e $\left\{ y_{k}\right\} $,
possiamo ottenere gli elementi dal secondo in poi come:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Algoritmo di Euclide esteso}{\footnotesize{}\index{Euclide, algoritmo esteso di@{\footnotesize{}Euclide, algoritmo esteso di}}}}[1.2cm]
\begin{equation}
\begin{array}{cc}
x_{2}=-q_{1}\cdot x_{1}+x_{0} & y_{2}=-q_{1}\cdot y_{1}+y_{0}\\
x_{3}=-q_{2}\cdot x_{2}+x_{1} & y_{3}=-q_{2}\cdot y_{2}+y_{1}\\
x_{4}=-q_{3}\cdot x_{3}+x_{2} & y_{4}=-q_{3}\cdot y_{3}+y_{2}\\
\vdots & \vdots\\
\boxed{x_{k+1}}=-q_{k}\cdot x_{k}+x_{k-1} & \boxed{y_{k+1}}=-q_{k}\cdot y_{k}+y_{k-1}
\end{array}\label{eq:Algoritmo-Euclide-esteso}
\end{equation}
Osserviamo che gli elementi delle successioni in $x$ e $y$ si ottengono
in modo analogo, tuttavia le due successioni sono inizializzate in
modo differente (\ref{eq:Premessa-successioni-Euclide-esteso}). Euclide
Esteso ci permette di affermare che
\[
\mcd ab=d=a\cdot x_{k+1}+b\cdot y_{k+1}
\]
dove gli interi $x_{k+1}$ e $y_{k+1}$ sono ottenuti dalle successioni
(\ref{eq:Algoritmo-Euclide-esteso}); normalmente uno dei due è positivo
e l'altro è negativo.

\section{Congruenza in modulo}

\subsection{Definizione e proprietà}

Nelle sezioni precedenti abbiamo introdotto il simbolo di congruenza
`$\equiv$', che usato nel modo seguente implica che
\[
\cgm abn\implies\mod an=\mod bn\implies a-b=k\cdot n
\]
ovvero il fatto che $a$ sia congruente in modulo $n$ a $b$ implica
il fatto che $a$ e $b$ siano multipli; possiamo infatti dedurlo
osservando l'ultima implicazione, riscritta come
\[
a=b+k\cdot n
\]

Per la congruenza in modulo valgono alcune proprietà simili a quelle
dell'uguaglianza:
\begin{itemize}
\item $\cgm a0n\iff n\backslash a$
\item $\forall a\in\mathbb{Z}\tc\cgm aan$
\item $\cgm abn\iff\cgm ban$
\item $\cgm abn\land\cgm bcn\implies\cgm acn$
\end{itemize}

\subsection{Insieme dei residui}

Fin'ora abbiamo lavorato all'interno dell'insieme dei numeri interi
$\mathbb{Z}$; introduciamo l'insieme dei residui modulo $n$, indicato
come $\mathbb{Z}_{n}$, che contiene l'insieme dei valori da 0 a $n-1$
e al suo interno sono definite ciclicamente le operazioni di addizione,
sottrazione e moltiplicazione; osserviamo un esempio sull'addizione.
\begin{example}
\emph{\label{ex:Operazioni-insieme-residui}Determinare i risultati
delle seguenti operazioni, all'interno dell'insieme $\mathbb{Z}_{10}$:
$4+5,\,5+5,\,2-3,\,3\cdot4$.}

$\checked$Dalla definizione sappiamo che $\mathbb{Z}_{10}=\left\{ 0,1,2,3,4,5,6,7,8,9\right\} $,
allora le operazioni richieste valgono:
\[
4+5=9,\;5+5=0,\;2-3=9,\;3\cdot4=2
\]
\demo
\end{example}
La divisione in un insieme dei residui non è definita in modo banale
come le altre tre operazioni; introdurremo in seguito questa operazione.

\subsection{Insieme ridotto dei residui}

Dato un insieme dei residui $\mathbb{Z}_{n}$, possiamo definire il
suo insieme ridotto $\mathbb{Z}_{n}^{*}$, che contiene gli elementi
di $\mathbb{Z}_{n}$ che sono coprimi rispetto a $n$, ovvero
\[
\forall z\in\mathbb{Z}_{n}^{*}\tc z\in\mathbb{Z}_{n}\land z\perp n
\]
Procedendo con l'Esempio \ref{ex:Operazioni-insieme-residui}, l'insieme
ridotto dei residui modulo 10 avrà i seguenti elementi al suo interno:
\[
\mathbb{Z}_{10}^{*}=\left\{ 1,3,7,9\right\} 
\]
Notiamo che lo zero è sempre escluso dall'insieme ridotto, perché
non è coprimo rispetto ad alcun intero; la cardinalità di $\mathbb{Z}_{n}^{*}$
è determinata da una funzione di $n$ chiamata \emph{toziente} o \emph{$\varphi$
di Eulero}; in particolare vale $\varphi\left(10\right)=4$ (vedremo
in seguito come calcolare questa funzione).

\subsection{Equazioni congruenziali}

Una equazione congruenziale è una relazione definita su un'insieme
di residui; nel seguito vedremo delle proprietà che ci permetteranno
di operare con queste relazioni.
\begin{prop}
Prendiamo un intero $n\neq0$ e quattro interi $a,b,c,d$ tali che
\emph{$\cgm abn$ }e\emph{ $\cgm cdn$}; allora si verifica che\emph{
\[
\cgm{a+c}{b+d}n,\;\cgm{a-c}{b-d}n,\;\cgm{a\cdot c}{b\cdot d}n
\]
}
\end{prop}
Possiamo usare queste proprietà per risolvere la seguente equazione
congruenziale.
\begin{example}
\emph{Risolvere rispetto a $x$ l'equazione }$\cgm{x+7}3{17}$\emph{.}

$\checked$Dato che 7 è congruente a 3 in modulo 17, possiamo sfruttare
la seconda proprietà, per cui
\[
\begin{array}{c}
\cgm{x+7\boldsymbol{-7}}{3\boldsymbol{-7}}{17}\\
\cgm x{-4}{17}
\end{array}
\]
Osservando che $17-4=13$, otteniamo infine (è equivalente a scrivere
la congruenza con $-4$)
\[
\cgm x{13}{17}
\]
\demo
\end{example}
Ora introduciamo il concetto di divisione nell'insieme dei residui,
con una seconda proposizione.
\begin{prop}
Prendiamo un intero $n\neq0$ e tre interi $a,b,c$ con $a\perp n$
e vale \emph{$\cgm{a\cdot b}{a\cdot c}n$}; allora possiamo dire che
\emph{$\cgm{a\cdot b}{a\cdot c}n\implies\cgm bcn$}, tramite la moltiplicazione
da ambo i lati per l'inverso $a^{-1}$
\end{prop}
Possiamo risolvere una forma di equazione congruenziale più elaborata.
\begin{example}
\emph{Risolvere rispetto a $x$ l'equazione }$\cgm{2x+7}3{17}$\emph{.}

$\checked$Come nel caso precedente, possiamo sottrarre 7 da entrambi
i lati, dato che $\cgm 73{17}$, ottenendo
\[
\cgm{2x}{-4}{17}
\]
Ora sfruttando il fatto che $2\perp17$ la precedente diventa
\[
\cgm x{-2}{17}=\cgm x{15}{17}
\]
\demo
\end{example}
%
\begin{example}
\emph{Risolvere rispetto a $x$ l'equazione }$\cgm{5x+6}{13}{11}$\emph{.}

$\checked$Osservando che $\cgm 6{13}{11}$, applichiamo la proprietà
della divisione e otteniamo
\[
\cgm{5x}7{11}
\]
Se ora usiamo la proprietà della divisione (vale $5\perp11$) dovremo
scrivere
\[
\cgm x{\hat{\frac{7}{5}}}{11}
\]
dove la frazione $\hat{\nicefrac{7}{5}}$ in realtà non esiste nell'insieme
$\mathbb{Z}_{11}$; tuttavia sappiamo che $5x$ è congruente modulo
11 a 7, ma anche a (per la ciclicità dell'insieme dei residui) $7+11,\,7+22,\,\ldots\,,7+k\cdot11$;
il primo numero che sia un multiplo di 5 si ha per 3; abbiamo ottenuto
che $\left[7=40\right]\ni\mathbb{Z}_{11}$, quindi possiamo scrivere
\[
\begin{array}{c}
\cgm{5x}{40}{11}\\
\cgm x8{11}
\end{array}
\]
Possiamo in un certo senso affermare che 8 si comporta come $\nicefrac{7}{5}$
in $\mathbb{Z}_{11}$.

Esiste una seconda strada per risolvere questo esercizio; sapendo
che 5 e 11 sono primi relativi, usiamo il prodotto invece della divisione:
\[
\cgm{5x\cdot\boldsymbol{5^{-1}}}{7\cdot\boldsymbol{5^{-1}}}{11}
\]
L'inverso di un numero $n$ è quel numero $m$ tale che $n\cdot m=1$;
dunque cerchiamo l'elemento di $\mathbb{Z}_{11}$ che moltiplicato
per 5 risulta 1; troviamo $m\cdot5=1\parallel_{\mathbb{Z}_{11}}\implies m=9$,
da cui segue che
\[
\cgm x{7\cdot9}{11}
\]
e dato che $7\cdot9=63=5\cdot11+8$ la precedente si scrive come
\[
\cgm x8{11}
\]
Abbiamo ottenuto il medesimo risultato a cui siamo arrivati attraverso
il primo procedimento.\demo
\end{example}
\begin{rem}
Presi $a\in\mathbb{Z}_{n}$ e $b\notin\mathbb{Z}_{n}^{*}$, non è
definita la divisione $a\div b$ (deve infatti valere $b\perp n\implies b\in\mathbb{Z}_{n}^{*}$).
\end{rem}
%
\begin{rem}
Se prendiamo l'equazione $\cgm{a\cdot x}bn$, essa ammetterà soluzione
se vale $a\perp n$; in tal caso $\exists a^{-1}\in\mathbb{Z}_{n}^{*}$
e la soluzione sarà $\cgm x{b\cdot a^{-1}}n$.
\end{rem}
Cosa possiamo concludere nel caso in cui, data l'equazione $E:\,\cgm{a\cdot x}bn$,
non sia vero che $a\perp n$, cioè nel caso in cui $\mcd an=d>1$?
In tal caso, l'equazione può non ammettere soluzione o ammetterne
$d$.

Se $d\backslash b$ allora dividiamo per $d$ tutte le quantità costanti,
ottenendo
\[
\overline{E}:\,\cgm{\frac{a}{d}x}{\frac{b}{d}}{\frac{n}{d}}
\]
questa equazione ha ora una soluzione, perché $\mcd an=d\implies\mcd{\frac{a}{d}}{\frac{n}{d}}=\frac{d}{d}=1$
e ricadiamo nel caso dell'osservazione precedente.

Otteniamo la soluzione dell'equazione $\overline{E}$ e la chiamiamo
$x_{0}$, la quale sarà in modulo $\nicefrac{n}{d}$ ($x_{0}\in\mathbb{Z}_{n/d}$);
dato che l'equazione di partenza $E$ ha soluzioni in $\mathbb{Z}_{n}$,
esse saranno i termini della successione
\[
\left\{ x\right\} =x_{0},\,x_{0}+\frac{n}{d},\,x_{0}+2\frac{n}{d},\,\ldots\,,\,x_{0}+\left(d-1\right)\frac{n}{d}
\]
Osserviamo l'esempio di un'equazione con queste caratteristiche.
\begin{example}
\emph{Risolvere rispetto a $x$ l'equazione }$\cgm{12x}{21}{39}$\emph{.}

$\checked$Osserviamo subito che $\mcd{12}{39}=3$, dunque l'equazione
avrà 0 o 3 soluzioni; dividiamo le costanti per 3 e otteniamo
\[
\cgm{4x}7{13}
\]
da cui otteniamo $\cgm x{\hat{\frac{7}{4}}}{13}$ e trovando $4\backslash\left(7+1\cdot13\right)=20$
la precedente equazione fornisce una soluzione $\cgm{x_{0}}5n$; adesso
usiamo la successione delle soluzioni $\left\{ x\right\} $ per ottenere
tutte le soluzioni dell'equazione di partenza:
\[
x=\left\{ x_{0}=\boxed{5},\,x_{0}+\frac{39}{3}=\boxed{18},\,x_{0}+\frac{2\cdot39}{3}=\boxed{31}\right\} 
\]
Possiamo immaginare le radici di $E$ come dei punti su una circonferenza,
a distanza $d/n$ da $x_{0}$.\demo

Posto che valga $a\perp n$ (ovvero $\mcd an=1$), come possiamo calcolare
l'inverso $a^{-1}$? Potremmo tentare tutti i numeri da $1$ a $n-1$
conducendo un'analisi esaustiva, tuttavia per $n$ molto grande questo
non è pratico; usiamo allora l'algoritmo di Euclide esteso (\ref{eq:Algoritmo-Euclide-esteso}):
esso ci garantisce che
\[
\mcd an=1\implies\exists s,t\in\mathbb{Z}_{n}\tc a\cdot s+n\cdot t=1
\]
segue dalla precedente relazione che $a\cdot s=1-n\cdot t$, allora
abbiamo $\cgm{a\cdot s}1n$ e risolvendo l'equazione si ottiene
\[
\cgm s{a^{-1}}n
\]
ovvero il numero $s$ è proprio l'elemento finale $x_{k+1}$ della
sequenza di $x$ dell'algoritmo; esso risulta essere anche il valore
cercato dell'inverso $a^{-1}$.
\end{example}

\section{Teorema cinese del resto}

\subsection{Applicazione ed enunciato}

Mostriamo direttamente l'applicazione del teorema a un caso specifico:
prendiamo $\cgm x{25}{42}$; possiamo esprimere $x=25+6\cdot\left(7\cdot k\right)\rightleftarrows25+7\cdot\left(6\cdot k\right)$,
da cui ricaviamo
\begin{itemize}
\item per $x=25+6\cdot\left(7\cdot k\right)$: $\mod{25}6=1\implies\cgm x16$
\item per $x=25+7\cdot\left(6\cdot k\right)$: $\mod{25}7=3\implies\cgm x47$
\end{itemize}
Dalle due congruenze più semplici ottenute possiamo scrivere il sistema
\[
\cgm x{25}{42}\implies\begin{cases}
\cgm x16\\
\cgm x47
\end{cases}
\]
Il teorema cinese del resto afferma che:
\begin{thm}
Dati\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema cinese del resto}{\footnotesize{}\index{Cinese, teorema del resto@{\footnotesize{}Cinese, teorema del resto}}\label{thm:Teorema-cinese-del-resto}}}[0.0cm] due interi $n,\,m$ che siano \uline{primi relativi} (deve
valere $n\perp m$), e presi due interi $a,\,b$, allora il sistema
delle congruenze\emph{
\[
\begin{cases}
\cgm xan\\
\cgm xbm
\end{cases}
\]
}è equivalente alla singola congruenza\emph{
\[
\cgm xc{n\cdot m}
\]
}
\end{thm}
Il teorema afferma che, quanto introdotto all'inizio della sezione,
può valere nel senso opposto in alcune condizioni specifiche.Osserviamo
l'applicazione del teorema in un esempio.
\begin{example}
\emph{Sia dato il seguente insieme di congruenze:}
\[
\begin{cases}
\cgm x37\\
\cgm x5{15}
\end{cases}
\]
\emph{Scrivere una forma equivalente, con una singola congruenza.}

$\checked$Dato che $7\perp15$, per il Teorema \ref{thm:Teorema-cinese-del-resto}
possiamo affermare che esisterà una singola congruenza equivalente
alle due della consegna; essa sarà scritta nella forma $\cgm xc{105}$.
Per ottenere $c$ possiamo provare i numeri multipli di 5, i quali
in modulo 7 diano 3 come risultato; si ottiene facilmente $c=80$
(possiamo scomporlo come $80=11\cdot7+3$).

Nel caso di numeri molto grandi, non è possibile scegliere di procedere
per tentativi, ed è necessario usare gli strumenti della teoria dei
numeri: se sappiamo che $\cgm xan$ e anche $\cgm xbm$, allora possiamo
scrivere
\[
\cgm{x=b+\overline{k}\cdot m}an
\]
risolvendo questa relazione si ottiene $\cgm{a-b}{\overline{k}\cdot m}n$
da cui, rispetto a $\overline{k}$ otteniamo
\[
\cgm{\overline{k}}{\left(a-b\right)\cdot m^{-1}}n
\]
Il valore $\overline{k}$ corrisponde al $c$ del Teorema \ref{thm:Teorema-cinese-del-resto},
esso infatti è congruente sia ad $a$ in modulo $n$, sia a $b$ in
modulo $m$.\demo
\end{example}

\subsection{Estensione}

Il Teorema \ref{thm:Teorema-cinese-del-resto} ammette un'estensione
a un caso generale, con $N$ congruenze.
\begin{cor}
Prendiamo\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema cinese del resto esteso}{\footnotesize{}\index{Cinese, teorema del resto esteso@{\footnotesize{}Cinese, teorema del resto esteso}}\label{thm:Teorema-cinese-del-resto-esteso}}}[0.0cm] $N$ numeri interi, indicati come $m_{i}\tc i\in\left[1,\,N\right]$,
tali che a coppie siano tutti coprimi ($\forall i,j\in\left[1,\,N\right]\land i\neq j\tc m_{i}\perp m_{j}$).
Se abbiamo il seguente sistema di congruenze
\[
\begin{cases}
\cgm x{a_{1}}{m_{1}}\\
\cgm x{a_{2}}{m_{2}}\\
\\
\cgm x{a_{N}}{m_{N}}
\end{cases}
\]
è equivalente alla singola congruenza
\[
\cgm xC{\prod_{i=1}^{N}m_{i}}
\]
\end{cor}
Tale congruenza si costruisce a partire dalle seguenti serie:
\[
M=\prod_{i=1}^{N}m_{i};\quad Z_{i}=\frac{M}{m_{i}};\quad Y_{i}=\mod{Z_{i}^{-1}}{m_{i}}
\]
Otteniamo infine la seguente soluzione, equivalente a una singola
congruenza:
\begin{equation}
X=\mod{\serie{i=1}N{a_{i}Y_{i}Z_{i}}}M\label{eq:Congruenza-equivalente-sistema}
\end{equation}


\section{Square \& multiply\label{sec:Square-=000026-multiply}}

Tramite l'algoritmo chiamato square and multiply, è possibile calcolare
il modulo di un numero che abbia molte cifre; mostriamo un esempio
per illustrare l'idea dietro a questo algoritmo, usando numeri ``piccoli''.
\begin{example}
\emph{Si calcoli il risultato dell'operazione} $\mod{7^{11}}{26}$.

$\checked$Eseguiamo i seguenti passi per cercare il valore desiderato:\marginpar{LSB indica il least significant bit (bit meno significativo) e si
riferisce al primo bit da destra}[0.8cm]
\end{example}
\begin{enumerate}
\item Esprimiamo 11 (l'esponente) in forma binaria: $11_{10}=1011_{2}=1\cdot2^{3}+0\cdot2^{2}+1\cdot2^{1}+1\cdot2^{0}$;
\item Sostituire 11 con la sua rappresentazione binaria: $7^{11}=7^{\left(8+2+1\right)}=7^{8}\cdot7^{2}\cdot7$;
\item Scriviamo i bit di 11 in colonna, al contrario (a partire dal LSB):
$\begin{bmatrix}1 & 1 & 0 & 1\end{bmatrix}$;
\item Scriviamo accanto a ciascun bit la potenza di 7 corrispondente, ottenuta
dalla scomposizione al punto ${\scriptstyle \left(1\right)}$;
\item Scriviamo accanto alle potenze $7^{i}$ il risultato dell'operazione
$\mod{7^{i}}{26}$;
\item Componiamo il risultato prendendo il prodotto dei valori scritti al
punto ${\scriptstyle \left(5\right)}$ in corrispondenza di un 1,
scritto al punto ${\scriptstyle \left(3\right)}$
\end{enumerate}
Otterremo infine:
\[
\begin{array}{ccc}
\boldsymbol{1} & 7^{1} & \boxed{7}\\
\boldsymbol{1} & 7^{2} & \boxed{23}\\
0 & 7^{4} & 9\\
\boldsymbol{1} & 7^{8} & \boxed{3}
\end{array}\implies\mod{\left(7\cdot23\cdot3\right)}{26}=15
\]
Il vantaggio di questo metodo è il fatto che si basa solo sull'operazione
di elevamento al quadrato di numeri piccoli (relativamente al modulo,
nell'esercizio siamo in $\mathbb{Z}_{26}$). In totale, saranno necessari
(per questo caso dell'esercizio) $2\cdot\log_{2}\left(11\right)\simeq4$
passi.\demo

\section{Teorema piccolo di Fermat}
\begin{thm}
Sia\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema piccolo di Fermat}{\footnotesize{}\index{Fermat, teorema piccolo di@{\footnotesize{}Fermat, teorema piccolo di}}\label{thm:Teorema-piccolo-Fermat}}}[0.0cm] $p$ un intero primo, e $a$ un intero tale che $p$ \uline{non}
divida $a$, allora è vero che\emph{
\begin{equation}
\cgm{a^{p-1}}1p\label{eq:Teorema-piccolo-Fermat}
\end{equation}
}
\end{thm}
Non vale l'implicazione inversa, infatti prendendo $a$ ed $n$ due
interi qualsiasi, e osservando che $\cgm{a^{n-1}}1n$, non possiamo
dedurre che $n$ sia primo.

Piuttosto possiamo usare il Teorema \ref{thm:Teorema-piccolo-Fermat}
per provare che un numero sia composto (non primo); tuttavia i numeri
composti che danno resto 1 non ostante non siano primi sono pochi,
e sono definiti \emph{pseudo-primi}. Questi numeri sono sempre più
rarefatti all'aumentare dell'ordine di grandezza.

Non ostante la scelta di una base $a$ differente possa ``smascherare''
un numero pseudo-primo, esiste una categoria di interi chiamati \emph{pseudo-primi
assoluti}, i quali forniscono resto 1 con qualunque base scelta nel
test del teorema piccolo di Fermat.
\begin{rem}
Abbiamo concluso dal Teorema \ref{thm:Teorema-piccolo-Fermat} che,
se non è vero $p\backslash a$, allora vale $\cgm{a^{p-1}}1p$; possiamo
scrivere questa congruenza in modo equivalente come $\cgm{a\cdot a^{p-2}}1p$,
che può essere risolta con la regola della divisione nel modo seguente:
\begin{equation}
\cgm{a^{p-2}}{a^{-1}}p\label{eq:Osservazione-inverso-p-2}
\end{equation}
Abbiamo appena ottenuto un nuovo metodo per calcolare l'inverso di
un intero $a$.
\end{rem}
Poniamoci nel caso generale, in cui abbiamo un intero qualunque $a$
e un intero composto $n$: la condizione del teorema diventa che $a\perp n$;
in queste condizioni possiamo enunciare il seguente Teorema \ref{thm:Teorema-Eulero}.
\begin{thm}
Sia\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema di Eulero}{\footnotesize{}\index{Eulero, teorema di@{\footnotesize{}Eulero, teorema di}}\label{thm:Teorema-Eulero}}}[0.0cm] $a$ un intero qualunque e $n$ un intero composto, tali
che $a\perp n$, allora è vero che\emph{
\begin{equation}
\cgm{a^{\varphi\left(n\right)}}1n\label{eq:Teorema-Eulero}
\end{equation}
}
\end{thm}
La funzione \emph{toziente} $\varphi\left(p\right)$ con $p$ numero
primo, è il numero di primi relativi rispetto a $p$, in questo caso
$p-1$ numeri, tutti i predecessori di $p$, il quale essendo primo
ha come fattore comune con essi solo 1; vale dunque $\varphi\left(p\right)=p-1$
per $p$ numero primo.

In generale il toziente di un intero $n$ qualunque si può calcolare
in uno dei seguenti modi:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Toziente}{\footnotesize{}\index{Toziente@{\footnotesize{}Toziente}}\label{eqn:Toziente}}}[1.2cm]
\begin{itemize}
\item $\varphi\left(n\right)=n\cdot\prod_{i\in\left[1,n-1\right],\,p_{i}\backslash n}\left(1-\dfrac{1}{p_{i}}\right)$
\item $n=\prod_{i=1}^{m}p_{i}^{r_{i}}\implies\varphi\left(n\right)=\prod_{i=1}^{m}\left(p_{i}^{r_{i}}-p_{i}^{r_{i}-1}\right)$
\end{itemize}
Vediamo un esempio in cui calcoliamo il toziente di due numeri adoperando
entrambi i procedimenti:
\begin{example}
\emph{Calcolare il toziente di 1000.}

$\checked$Adoperando il primo metodo, scriviamo la scomposizione
di 1000 nei suoi fattori primi: $1000=2^{3}\cdot5^{3}$; scriviamo
dunque la produttoria usando i due fattori $p_{i}=\left\{ 2,\,5\right\} $
senza esponente
\[
1000\cdot\left(1-\frac{1}{2}\right)\cdot\left(1-\frac{1}{5}\right)=\boxed{400}=\varphi\left(1000\right)
\]
Se adoperiamo il secondo metodo, scriviamo direttamente la produttoria
a partire dai fattori primi $2^{3}$ e $5^{3}$:
\[
\left(2^{3}-2^{2}\right)\cdot\left(5^{3}-5^{2}\right)=\boxed{400}=\varphi\left(1000\right)
\]
Abbiamo ottenuto lo stesso toziente, mostrando che entrambi i procedimenti
si equivalgono.\demo
\end{example}
\begin{rem}
Se vogliamo calcolare l'inverso di un intero $a$ modulo $n$ non
primo, posto che $a\perp n$ possiamo scrivere la congruenza
\begin{equation}
\cgm{a^{-1}}{a^{\varphi\left(n\right)-1}}n\label{eq:Inverso-residuo-toziente}
\end{equation}
Questa relazione ci permette di calcolare un inverso utilizzando il
modulo di un elevamento a potenza (evitando la strada di Euclide esteso
(\ref{eq:Algoritmo-Euclide-esteso})), per esempio tramite square
and multiply eseguito su un calcolatore.
\end{rem}
Mettendo assieme quanto illustrato in questa sezione, possiamo rispondere
alla richiesta mostrata nel seguente esempio.
\begin{example}
\emph{Calcolare le ultime tre cifre di} $7^{803}$.\label{ex:Ultime-3-cifre-7}

$\checked$Le ultime tre cifre di un numero possono essere ottenute
usando il resto della sua divisione per $10^{3}$; allora dobbiamo
trovare il risultato di $\mod{7^{803}}{1000}$.

Per il teorema di Eulero (\ref{eq:Teorema-Eulero}) sappiamo che $\cgm{7^{\varphi\left(1000\right)}}1{1000}$
e dal precedente esempio abbiamo già calcolato $\varphi\left(1000\right)=400$,
per cui possiamo scomporre $7^{803}$ nel modo seguente:
\[
\mod{\left(7^{400}\cdot7^{400}\cdot7^{3}\right)}{1000}=\mod{\left(1\cdot1\cdot343\right)}{1000}=\boxed{343}
\]
\demo
\end{example}

\section{Principio fondamentale}

Se abbiamo gli interi $a,\,b,\,n,\,x,\,y$ e $n>0$, tali che $a\perp n$,
allora se $\cgm xy{\varphi\left(n\right)}$ vale
\begin{equation}
\cgm{a^{x}}{b^{y}}n\label{eq:Principio-fondamentale}
\end{equation}
tuttavia non vale l'implicazione inversa.

Concludiamo che, in una congruenza modulo $n$, in presenza di elevamenti
a potenza gli esponenti della stessa base lavorano in modulo di $\varphi\left(n\right)$.

Questo principio permette di risolvere rapidamente la richiesta dell'Esercizio
\ref{ex:Ultime-3-cifre-7}: dato che $\cgm{803}3{\varphi\left(1000\right)=400}$
otteniamo direttamente $\cgm{7^{803}}{7^{3}}{1000}$; abbiamo usato
(\ref{eq:Principio-fondamentale}) in cui $x=803$ e $y=3$.

\section{Radici in aritmetica modulare}

\subsection{Radici primitive}

Introduciamo il concetto di gruppo algebrico:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Gruppo algebrico}{\footnotesize{}\index{Gruppo algebrico@{\footnotesize{}Gruppo algebrico}}\label{def:Gruppo-algebrico}}}[0.3cm]

\begin{minipage}[t]{0.9\textwidth}%
\begin{center}
\emph{Chiamiamo }gruppo\emph{ una struttura formata da un insieme
e da un'operazione binaria definita su di esso, la quale soddisfi
gli assiomi di associatività, esistenza dell'elemento neutro ed esistenza
dell'elemento inverso}
\par\end{center}%
\end{minipage}

Ad esempio, se prendiamo l'insieme dei numeri interi $\mathbb{Z}$
e l'operazione di somma $+$, possiamo formare il gruppo $\left(\mathbb{Z},\,+\right)$
poiché la somma è associativa, l'elemento neutro è lo zero e l'inverso
di qualunque elemento è sempre definito; anche prendendo $\mathbb{Z}_{p}^{*}$
(insieme dei residui interi modulo $p$, escluso lo 0) e l'operazione
di prodotto, otteniamo di nuovo un gruppo $\left(\mathbb{Z}_{p}^{*},\,\cdot\right)$.
Non si ottiene un gruppo rispetto al prodotto per $\mathbb{Z}_{p}$
(residui modulo $p$, da 0 a $p-1$), poiché lo 0 non ha un inverso
definito.\bigskip{}

Se prendiamo un elemento $a\in\mathbb{Z}_{p}^{*}$ allora vale $\cgm{a^{p-1}}1p$
per il Teorema \ref{thm:Teorema-piccolo-Fermat}; chiamiamo inoltre
ordine dell'elemento $a$ (e lo indichiamo tramite $\ord a$) l'intero
$n>0$ più piccolo tale che
\begin{equation}
\cgm{a^{n}}1p\label{eq:Ordine-di-intero}
\end{equation}
Il teorema piccolo di Fermat (\ref{eq:Teorema-piccolo-Fermat}) ci
assicura che vale sempre $n\leq p-1$, ma non è detto che sia proprio
$n=p-1$. Chiamiamo quindi $\alpha$ l'elemento primitivo $a\in\mathbb{Z}_{p}^{*}$
se e solo se l'ordine di $a$ è 1, ovvero non esiste nessun altro
intero $n$ per cui $\cgm{a^{n}}1p$; in altri termini vale
\begin{equation}
\cgm{a^{n}}1p\iff n=1\label{eq:Condizione-elemento-primitivo}
\end{equation}
Se l'ordine di $a$ fosse proprio $p-1$, allora preso $\alpha^{i}$
l'elemento primitivo, presi tutti gli interi $i\in\left[1,\,p-1\right]$,
otteniamo dalla successione degli $\alpha^{i}$ tutti e soli gli elementi
dell'insieme $\mathbb{Z}_{p}^{*}$ (in ordine anche differente); chiameremo
l'elemento $\alpha$ la \emph{radice primitiva}.

\begin{minipage}[t]{0.9\columnwidth}%
\begin{center}
\emph{Chiamiamo $\alpha$ una radice primitiva per $p$ se vale (\ref{eq:Condizione-elemento-primitivo})
e inoltre l'ordine di $\alpha$ è pari a $n=p-1$.}
\par\end{center}%
\end{minipage}\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Radice primitiva}{\footnotesize{}\index{Radice primitiva@{\footnotesize{}Radice primitiva}}\label{def:Radice-primitiva}}}[-0.2cm]
\begin{example}
\emph{Trovare se $\alpha=3$ sia una radice primitiva di $p=7$.}
\end{example}
$\checked$Per trovare se $\alpha$ sia effettivamente una radice
primitiva di $p$, calcoliamo gli elementi:
\[
\left\{ \forall i\in\left[0,\,p-1\right]\,:\,\cgm{\beta}{\alpha^{i}}p\right\} 
\]
Otteniamo quindi:
\[
\begin{array}{c}
\cgm{3^{0}}17\\
\cgm{3^{1}}37\\
\cgm{3^{2}}27\\
\cgm{3^{3}}67\\
\cgm{3^{4}}47\\
\cgm{3^{5}}57\\
\vdots
\end{array}
\]
Abbiamo riottenuto tutti e soli gli elementi da $1$ a $p-1=6$ (i
membri di $\mathbb{Z}_{7}^{*}$), con periodo $p-1=6$. Si verifica
dunque la condizione che rende un elemento primitivo $\alpha$ una
radice per $p$; la radice primitiva è anche detta elemento generatore:
infatti, tramite essa è possibile ottenere tutti i residui in modulo
$p$ di un certo insieme $\mathbb{Z}_{p}^{*}$.\demo
\begin{example}
\emph{Trovare se $\alpha=2$ sia una radice primitiva di $p=7$.}
\end{example}
$\checked$Calcolando di nuovo gli $\alpha^{i}$ con $i\in\left[0,\,p-1\right]$
otteniamo
\[
\begin{array}{c}
\cgm{2^{0}}17\\
\cgm{2^{1}}27\\
\cgm{2^{2}}47\\
\cgm{2^{3}}17\\
\vdots
\end{array}
\]
In questo caso abbiamo ottenuto periodo 3; inoltre l'ordine di $\alpha$
è $n=3\neq p-1=6$, quindi $\alpha=2$ non è radice primitiva di $p=7$.\demo
\begin{rem}
Se prendiamo l'elemento primitivo $a\in\mathbb{Z}_{p}^{*}$, esso
avrà al massimo ordine $p-1$; tuttavia potrà presentare anche ordini
pari ai sottomultipli di $p-1$, ma non ordini differenti da essi.
\end{rem}
%
\begin{rem}
Se $\alpha$ è un elemento primitivo di $\mathbb{Z}_{p}^{*}$ e vale
$\cgm{\beta}{\alpha^{i}}p$ con $1\leq i\leq p-1$, questi $\beta$
sono tutti e soli gli elementi di $\mathbb{Z}_{p}^{*}$. Se ora prendiamo
un elemento primitivo di $\mathbb{Z}_{p}^{*}$ espresso come $\beta$
(tramite la precedente congruenza), il suo ordine sarà dipendente
dall'esponente $i$ usato per ottenerlo a partire da $\alpha,$e dovrà
valere
\begin{equation}
\ord{\beta}=\frac{p-1}{\mcd{p-1}i}\label{eq:Elemento-primitivo-MCD}
\end{equation}
dove $i$ è l'esponente a cui elevare $\alpha$ per ottenere $\beta$.
Questo si verifica perché i $\beta$ sono potenze di $\alpha$, ed
essendo $\ord{\alpha}=p-1$ ($\alpha$ è radice primitiva) necessariamente
l'ordine di $\beta$ sarà un sottomultiplo di $p-1$, determinato
da (\ref{eq:Elemento-primitivo-MCD})

Gli elementi primitivi di $\mathbb{Z}_{p}^{*}$ sono in numero $\varphi\left(p-1\right)$;
infatti saranno tutti gli elementi di $\mathbb{Z}_{p}^{*}$. coprimi
rispetto a $p-1$, per cui si verifica la condizione (\ref{eq:Elemento-primitivo-MCD}).
Notiamo infatti che $\beta$ è una radice primitiva di $p$ (vale
$\ord{\beta}=p-1$) quando si ha $\mcd{p-1}i=1$; concludiamo che
il numero di elementi primitivi $\beta$ di un insieme $\mathbb{Z}_{p}^{*}$
è il numero di elementi coprimi rispetto a $p-1$ (valore ottenuto
dalla funzione toziente di $p-1$).
\end{rem}

\subsection{Test di primitività}

Prendiamo un $\alpha\in\mathbb{Z}_{p}^{*}$ con $p$ qualunque, e
cerchiamo se $\alpha$ sia primitivo o meno rispetto a $p$; usiamo
il seguente test di primitività: scomporre $p-1$ nei suoi fattori
primi, in modo da avere una produttoria di quozienti elevati a un
certo esponente $p-1=\prod_{i}q_{i}^{r_{i}}$; diremo che $\alpha$
è primitivo rispetto a $p$ se e solo se vale\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Test primitività}{\footnotesize{}\index{Test primitività@{\footnotesize{}Test primitività}}}}[0.4cm]
\begin{equation}
\forall i\,:\,\ncgm{\alpha^{\left(p-1\right)/q_{i}}}1p\label{eq:Test-primitivit=0000E0}
\end{equation}
Si noti che $p$ è primo (per definizione), di conseguenza $p-1$
è sempre pari.
\begin{example}
\emph{Ottenere se $\alpha=2$ sia radice primitiva per $p=19$.}
\end{example}
$\checked$Usando il test (\ref{eq:Test-primitivit=0000E0}), scomponiamo
$19-1=18$ nei suoi fattori primi:
\[
18=2\cdot3^{2}
\]
Ora testiamo la congruenza per tutti i fattori primi (presi senza
esponente):
\[
\begin{array}{c}
\cgm{2^{18/3}=2^{6}=64}7{19}\\
\cgm{2^{18/2}=2^{9}=512}{18}{19}
\end{array}
\]
Per nessun fattore primo si ha congruenza a 1 modulo 19, dunque $\alpha=2$
è davvero una radice primitiva per $p=19$.

Osserviamo infine che gli elementi primitivi di $\mathbb{Z}_{19}$
sono $\varphi\left(18\right)=6$, distribuiti all'interno dell'insieme
in modo non predicibile.\demo

\subsection{Radici quadrate}

Poniamoci nel caso di radici quadrate in modulo a un intero $p$ primo;
inoltre, consideriamo per tale intero solamente la metà dei numeri
primi (si ricordi la separazione dei primi in classi di congruenza
(\ref{eq:Successione-primi-classi})):
\begin{equation}
\cgm p34\label{eq:Condizione-radici-quadrate-modulo-primo}
\end{equation}
Risolviamo, sotto queste condizioni, l'equazione $\cgm{x^{2}}ap$,
ovvero cerchiamo $\sqrt{a}\in\mathbb{Z}_{p}$; si dimostra che, se
esiste $\sqrt{a}$, allora vale:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Radice quadrata}{\footnotesize{}\index{Radice quadrata@{\footnotesize{}Radice quadrata}}}}[0.4cm]
\begin{equation}
\pm a^{\left(p+1\right)/4}=\sqrt{a}\,\lor\,\pm a^{\left(p+1\right)/4}=\sqrt{-a}\label{eq:Radice-quadrata-modulo-primo}
\end{equation}
dove abbiamo l'unione di due condizioni che sono esclusive (se non
esiste la radice di $a$ allora esisterà quella di $-a$, e vale quanto
indicato in (\ref{eq:Radice-quadrata-modulo-primo}), e vice versa).
\begin{rem}
\label{oss:Condizioni-esistenza-radici}Se avessimo $\ncgm p34$ ma
$\cgm p14$ ($p$ appartenente all'altra classe di congruenze), allora
nel caso in cui non esista una delle due radici ($\sqrt{a}$ o $\sqrt{-a}$)
non esiste nemmeno l'altra.
\end{rem}
\begin{example}
\emph{Si calcoli, se esiste, la radice di 5 in modulo 11.}
\end{example}
$\checked$Cercare $\mod{\sqrt{5}}{11}$ equivale a risolvere l'equazione
\[
\cgm{x^{2}}5{11}
\]
Dato che per 11 vale (\ref{eq:Condizione-radici-quadrate-modulo-primo}),
possiamo usare la formula (\ref{eq:Radice-quadrata-modulo-primo}):
\[
\pm5^{\left(11+1\right)/4}=\mod{\pm125}{11}=\pm4
\]
Per determinare se in modulo 11 i numeri $\pm4$ siano la radice di
$5$ o di $-5$, effettuiamo l'elevamento a potenza della radice cercata:
\[
\mod{4^{2}}{11=5},\quad-4^{2}=\mod{7^{2}}{11}=5
\]
Abbiamo ottenuto che la radice quadrata di 5 modulo 11 è $\pm4$.\demo
\begin{example}
\emph{Si calcoli, se esiste, la radice di 2 in modulo 11.}
\end{example}
$\checked$Come prima, impostiamo così l'equazione da risolvere:
\[
\cgm{x^{2}}2{11}
\]
Possiamo usare (\ref{eq:Radice-quadrata-modulo-primo}), dato che
per 2 vale (\ref{eq:Condizione-radici-quadrate-modulo-primo}):
\[
\pm2^{\left(11+1\right)/4}=\mod{\pm8}{11}=\pm8
\]
Infine effettuiamo l'elevamento a potenza della radice per ottenere
il segno:
\[
\mod{8^{2}}{11}=\mod 9{11}=-2
\]
Abbiamo ottenuto che in modulo 11 non esiste la radice quadrata di
2; la radice di $-2$ però esiste, e vale $\pm8$.\demo

\subsection{Test per segno della radice}

Prendiamo un primo $p$ dispari, un $a\neq0$ in modulo $p$, allora
\begin{equation}
\cgm{a^{\left(p-1\right)/2}}{\pm1}p\label{eq:Test-segno-radice-prima}
\end{equation}
Distinguiamo i due casi:
\begin{itemize}
\item se il segno in (\ref{eq:Test-segno-radice-prima}) è $+$, allora
esiste $\sqrt{a}$ in modulo $p$;
\item se il segno in (\ref{eq:Test-segno-radice-prima}) è $-$, allora
esiste $\sqrt{-a}$ in modulo $p$.
\end{itemize}
Ricordando l'Osservazione \ref{oss:Condizioni-esistenza-radici},
si nota che il test appena mostrato permette di affermare se la radice
non sia definita, nel caso in cui $\cgm p14$ e in cui il segno in
(\ref{eq:Test-segno-radice-prima}) sia $-$.

\subsection{Radice quadrata modulo composto}

Esaminiamo il problema $\cgm{x^{2}}an$ dove $n$ sia un numero composto;
dato che $n$ sarà scomponibile in fattori primi, possiamo scomporre
la congruenza esaminata in due congruenze più semplici in modulo $p$
e $q$, sapendo che $n=p\cdot q$. Le due soluzioni ottenute si combinano
infine tramite il Teorema \ref{thm:Teorema-cinese-del-resto}.

Questo problema ha la sua difficoltà nella fattorizzazione di $n$,
al punto che la complessità computazionale del calcolo della radice
modulo $n$ equivale a quella della sua scomposizione in fattori primi.
\begin{example}
\emph{Si calcoli, se esiste, la radice di 71 in modulo 77.}
\end{example}
$\checked$Notiamo subito che $77=7\cdot11$; per il Teorema \ref{thm:Teorema-cinese-del-resto}
possiamo scomporre la congruenza in esame nelle due più semplici:
\[
\cgm{x^{2}}{71}{77}\implies\begin{cases}
\cgm{x^{2}}17\\
\cgm{x^{2}}5{11}
\end{cases}
\]
Nella precedente abbiamo già sostituito $\mod{71}7=1$ e $\mod{71}{11}=5$;
possiamo risolvere le due congruenze in modo indipendente:
\begin{enumerate}
\item la radice quadrata di 1 è comunque $\pm1$, modulo 7;
\item la radice quadrata di 5 modulo 11 si può ottenere da (\ref{eq:Radice-quadrata-modulo-primo})
e risulta $\cgm x{\pm5^{\left(11+1\right)/4}}{11}\implies\cgm x{\pm4}{11}$.
\end{enumerate}
Abbiamo ottenuto due radici da ciascuna congruenza, che possono essere
combinate in $2^{2}=4$ modi possibili, per costruire la soluzione
tramite il Teorema \ref{thm:Teorema-cinese-del-resto}.
\begin{itemize}
\item $\left\{ \cgm x17;\;\cgm x4{11}\right\} $\\
Risolviamo la combinazione delle due congruenze analizzate:
\[
\begin{array}{c}
x=\cgm{1+k\cdot7}4{11}\\
\cgm{7\cdot k}3{11}\\
\cgm k{3\cdot7^{-1}}{11}
\end{array}
\]
Per trovare l'inverso utilizziamo (\ref{eq:Osservazione-inverso-p-2}),
da cui $\mod{7^{-1}}{11}=\mod{7^{9}}{11}=8$, da cui segue che $k=\mod{24}{11}=2$;
sostituendo nella prima si ottiene
\[
x=\cgm{14+1}4{11}\implies\boxed{\cgm x{15}{77}}
\]
dal Teorema \ref{thm:Teorema-cinese-del-resto}.\bigskip{}
\item $\left\{ \cgm x17;\;\cgm x{-4}{11}\right\} $
\[
\cgm x{-15}{77}
\]
\smallskip{}
\item $\left\{ \cgm x{-1}7;\;\cgm x4{11}\right\} $
\[
\cgm x{29}{77}
\]
\smallskip{}
\item $\left\{ \cgm x{-1}7;\;\cgm x{-4}{11}\right\} $
\[
\cgm x{-29}{77}
\]
\end{itemize}
Non è detto che le radici siano sempre 4, in questo caso esistevano
tutte le radici per ciascuna congruenza in cui è stata scomposta quella
iniziale.\demo

\subsection{Residui quadratici}

Abbiamo chiamato gli elementi di $\mathbb{Z}_{p}^{*}$ residui modulo
$p$; i residui quadratici sono residui che corrispondono anche al
quadrato di qualche elemento dello stesso insieme $\mathbb{Z}_{p}^{*}$.

Chiamiamo $a_{q}\in\mathbb{Z}_{p}^{*}$i residui quadratici per cui
valga
\[
\cgm{a_{q}}{\left(\pm b\right)^{2}}p
\]
con $b\in\mathbb{Z}_{p}^{*}$ un elemento dell'insieme a cui appartiene
anche $a_{q}$.

Osserviamo che $p\in\left\{ 1,\,2,\,\ldots,\,\frac{p-1}{2}\right\} $,
poiché i residui a partire da $\frac{p-1}{2}+1$ sono i residui negativi
dei precedenti dal minore al maggiore ($-1=p-1$).
\begin{example}
\emph{\label{exa:Trovare-i-residui}Trovare i residui quadratici dell'insieme
$\mathbb{Z}_{11}^{*}$.}
\end{example}
$\checked$Otteniamo subito che nell'insieme analizzato ci sono $\frac{p-1}{2}=\frac{11-1}{2}=5$
residui quadratici; possiamo ottenerli tramite il test (\ref{eq:Test-segno-radice-prima}):
\[
\ncgm{a^{\left(p-1\right)/2}}{+1}p\implies a\text{ \textbf{non} è residuo quadratico!}
\]
Effettuiamo questo test per ciascun elemento di $\mathbb{Z}_{11}^{*}$:
\[
\begin{array}{ll}
\cgm{1^{5}}{\boxed{1}}{11} & \cgm{6^{5}}{-1}{11}\\
\cgm{2^{5}}{-1}{11} & \cgm{7^{5}}{-1}{11}\\
\cgm{3^{5}}{\boxed{1}}{11} & \cgm{8^{5}}{-1}{11}\\
\cgm{4^{5}}{\boxed{1}}{11} & \cgm{9^{5}}{\boxed{1}}{11}\\
\cgm{5^{5}}{\boxed{1}}{11} & \cgm{10^{5}}{-1}{11}
\end{array}
\]
Raccogliendo i risultati dei test con la congruenza a $+1$, possiamo
scrivere l'insieme dei residui quadratici di $\mathbb{Z}_{11}^{*}$:
\[
a_{q}=\left\{ 1,\,3,\,4,\,5,\,9\right\} 
\]
\demo
\begin{rem}
Un modo più rapido per ottenere i residui quadratici consiste nel
sfruttare il fatto che essi saranno i quadrati dei primi $\frac{p-1}{2}$
elementi dell'insieme dei residui: 
\[
a_{q}=\left\{ 1^{2},\,\ldots,\,\left(\frac{p-1}{2}\right)^{2}\right\} 
\]
Riprendendo la consegna dell'Esempio \ref{exa:Trovare-i-residui},
i residui quadratici di $\mathbb{Z}_{11}^{*}$ si ottengono come:
\[
\begin{array}{lll}
\mod{1^{2}}{11}=1 & \mod{3^{2}}{11}=9 & \mod{5^{2}}{11}=3\\
\mod{2^{2}}{11}=4 & \mod{4^{2}}{11}=5
\end{array}\implies a_{q}=\left\{ 1,\,4,\,9,\,5,\,3\right\} 
\]
Otteniamo gli stessi residui quadratici trovati con i test, in ordine
diverso.
\end{rem}

\chapter{Cifrari elementari}

\section{Introduzione}

Facendo riferimento alla figura \ref{fig:Scenario-fondamentale- comunicazione},
possiamo individuare la caratteristica del sistema di cifratura modellizzato:
esso usa la stessa chiave $k$ per la cifratura e la decifratura del
messaggio; ammettiamo che essa sia consegnata al destinatario tramite
un canale sicuro.

Il testo in chiaro è definito all'interno di tutti i possibili messaggi
in chiaro componibili con l'alfabeto a disposizione ($p\in\mathscr{P}$),
il messaggio cifrato è anch'esso definito all'interno di un insieme
di ogni possibile messaggio cifrato componibile ($c\in\mathscr{C}$),
infine la chiave appartiene all'insieme di tutte le possibili chiavi
componibili ($k\in\mathscr{K}$).

Ogni chiave, all'interno dello spazio delle chiavi, è definita una
regola di cifratura ($\forall k\in\mathscr{K}\tc E_{k}\in\mathscr{E}$)
e anche una regola di decifratura ($\forall k\in\mathscr{K}\tc D_{k}\in\mathscr{D}$),
entrambe dipendenti da $k$.

Deve valere che la cifratura sia invertibile con la decifratura, ovvero
$\forall k\in\mathscr{K},\,p\in\mathscr{P},\,c\in\mathscr{C}\tc c=E_{k}\left(p\right)\land p=D_{k}\left(c\right)$;
in caso contrario la decifratura non sarebbe più possibile (collisioni
durante la cifratura di messaggi differenti).

\section{Cifrari a scorrimento e sostituzione}

\subsection{Cifrario di Cesare}

Il cifrario di Cesare utilizza uno scorrimento dell'alfabeto, la chiave
stessa è un simbolo dell'alfabeto:
\[
\mathscr{P}=\mathscr{C}=\mathscr{K}=\mathbb{Z}_{n}
\]
Si verifica nel caso dell'alfabeto inglese vale $n=26$; la funzione
di cifratura e di decifratura si indicano come:
\[
\begin{array}{c}
c=E_{k}\left(p\right)=\mod{\left(p+k\right)}n\\
p=D_{k}\left(c\right)=\mod{\left(c-k\right)}n
\end{array}
\]
Possiamo attaccare questo cifrario con una ricerca esaustiva dello
spazio delle chiavi, sapendo che $\left|\mathscr{K}\right|=n$, oppure
possiamo confrontare un testo in chiaro noto con un testo cifrato
per ottenere la chiave ($k=p-c$).

Chiamiamo questo tipo di cifrario \emph{mono-alfabetico}, ovvero ad
ogni carattere corrisponde un carattere.

\subsection{Cifrario affine\label{subsec:Cifrario-affine}}

Utilizza una combinazione lineare applicata al testo in chiaro; per
questo cifrario vale:
\[
\mathscr{P}=\mathscr{C}=\mathbb{Z}_{n},\,\mathscr{K}=k\left(a,\,b\right)
\]
La funzione di cifratura e di decifratura si indicano come:
\[
\begin{array}{c}
c=E_{k}\left(p\right)=\mod{\left(ap+b\right)}n\\
p=D_{k}\left(c\right)=\mod{\left(c-b\right)a^{-1}}n
\end{array}
\]
Bisogna prendere $a,\,b\in\mathbb{Z}_{n}$ e per la presenza dell'inversione
di $a$, è necessario che esso sia primo relativo a $n$ ($a\perp n$);
se così non fosse, si verificherebbero delle collisioni nella cifratura.

\subsection{Cifrario a sostituzione}

Ogni carattere è sostituito da un'altro, secondo una tabella arbitraria;
esso è la generalizzazione dei due precedenti cifrari (la chiave è
una permutazione dell'alfabeto), e vale
\[
\mathscr{P}=\mathscr{C}=\mathbb{Z}_{n},\,\left|\mathscr{K}\right|=n!
\]
La chiave è la tabella di sostituzione, e le funzioni di cifratura
e decifratura sono determinate dalle sostituzioni indicate nella tabella.

Possiamo attaccare questo cifrario (e tutti gli altri cifrari mono-alfabetici)
analizzando l'entropia dei singoli simboli dell'alfabeto: nel caso
di messaggi cifrati in linguaggio naturale, l'analisi delle frequenze
dei simboli può rivelare lettere molto usate.

Altri attacchi di questo tipo includono l'analisi della frequenza
dei digrammi e trigrammi (coppie e triple di lettere).

\subsection{Cifrario di Vigenère}

Questo cifrario lavora su blocchi di $h$ caratteri alla volta, e
per questo viene detto poli-alfabetico. In questo caso abbiamo:
\[
\mathscr{P}=\mathscr{C}=\mathscr{K}=\left(\mathbb{Z}_{n}\right)^{h}
\]
La chiave, il testo in chiaro e il testo cifrato saranno vettori di
$h$ elementi:
\[
k=\left(k_{1},\,\ldots,\,k_{h}\right),\,p=\left(p_{1},\,\ldots,\,p_{h}\right),\,c=\left(c_{1},\,\ldots,\,c_{h}\right)
\]
Le regole di cifratura e decifratura sono le stesse del cifrario di
Cesare, applicate su ciascun elemento del vettore $p$ o $c$:
\[
\begin{array}{c}
c=E_{k}\left(p\right)=\left(\mod{p_{1}+k_{1}}n,\,\ldots,\,\mod{p_{h}+k_{h}}n\right)\\
p=D_{k}\left(c\right)=\left(\mod{c_{1}-k_{1}}n,\,\ldots,\,\mod{c_{h}-k_{h}}n\right)
\end{array}
\]
In questo cifrario gli scorrimenti per ciascun elemento del blocco
dipendono dalla posizione al suo interno; la stessa lettera verrà
cifrata in modo diverso a seconda della sua posizione nel blocco;
l'analisi di frequenza si applica, suddividendo la frequenza di un
simbolo su $h$ possibili modi di cifrarlo (la difficoltà cresce all'aumentare
di $h$).

\section{Cifrario a permutazione}

Si tratta di un cifrario a blocco (lavora su $h$ simboli alla volta),
che permuta le posizioni dei caratteri in ogni blocco. Al contrario
del cifrario a sostituzione, la permutazione in ogni blocco è indipendente.
La chiave adottata è una permutazione delle posizioni all'interno
del blocco.
\begin{example}
\emph{Dato il cifrario a permutazione con blocchi di dimensione $n=6$
e permutazione $k=\left(3,\,5,\,1,\,6,\,4,\,2\right)$, cifrare il
messaggio $p=``\text{she sells sea shells}"$ (gli spazi tra le parole
non sono caratteri dell'alfabeto).}
\end{example}
$\checked$Identifichiamo i blocchi di $n=6$ caratteri; il primo
blocco da sinistra è $\mathbb{B}_{1}=``\text{shesel}"$, che possiamo
indicare come:
\[
p=\Bigl(\begin{array}{cccccc}
{\scriptscriptstyle 1} & {\scriptscriptstyle 2} & {\scriptscriptstyle 3} & {\scriptscriptstyle 4} & {\scriptscriptstyle 5} & {\scriptscriptstyle 6}\\
\text{s,} & \text{h}, & \text{e}, & \text{s}, & \text{e}, & \text{l}
\end{array}\Bigr)
\]
A questo punto applichiamo la permutazione $k$, che sposta i simboli
del blocco nella seguente configurazione:
\[
c=\Bigl(\begin{array}{cccccc}
{\scriptscriptstyle 3} & {\scriptscriptstyle 5} & {\scriptscriptstyle 1} & {\scriptscriptstyle 6} & {\scriptscriptstyle 4} & {\scriptscriptstyle 2}\\
\text{e,} & \text{e}, & \text{s}, & \text{l}, & \text{s}, & \text{h}
\end{array}\Bigr)
\]
\demo

Questo cifrario risulta poli-alfabetico, e ogni blocco di lunghezza
$n$ può essere cifrato in $n!$ modi differenti.

\section{Proprietà fondamentali dei cifrari a blocchi}

In un cifrario a blocco di lunghezza $n$, si prende un messaggio
in chiaro e a partire da esso si ottiene un messaggio cifrato, entrambi
della stessa lunghezza ($\left|p\right|=\left|c\right|=n$).

Nell'articolo\footnote{\emph{``Communication Theory of Secrecy Systems'' }(1949), Bell
System Technical Journal} sulla crittografia pubblicato da Shannon, egli espone due proprietà
fondamentali che ogni sistema crittografico dovrebbe avere:
\begin{description}
\item [{\noun{Diffusione}}] Si ha diffusione perfetta se, cambiando 1 bit
del blocco in chiaro, tutti i bit del blocco cifrato corrispondente
cambiano in maniera apparentemente casuale, con probabilità $1/2$.
La perfetta diffusione vale anche nel senso opposto: cambiando 1 bit
del blocco cifrato, tutti i bit del blocco in chiaro corrispondente
cambiano con probabilità $1/2$.
\item [{\noun{Confusione}}] La chiave deve avere effetto su tutti i bit
del blocco cifrato: a parità di blocco in chiaro, se cambia 1 bit
della chiave, tutti i bit del blocco cifrato cambieranno, con probabilità
$1/2$.
\end{description}
Queste due proprietà si riassumono nella seguente affermazione:
\begin{prop}
\label{prop:Propriet=0000E0-fondamentali-cifrari-Shannon}Non solo
ogni bit del blocco in chiaro hanno effetto su \uline{tutti} i
bit della chiave, ma anche tutti i bit della chiave hanno effetto
su \uline{ogni} bit del blocco in chiaro.
\end{prop}

\chapter{Cifrario DES}

\section{Introduzione}

\subsection{Nascita del DES come standard}

L'algoritmo Data Encryption Standard (DES) nasce negli anni '70 per
soddisfare la necessità degli Stati Uniti di usare un cifrario per
le comunicazioni segrete; allora l'NBS (attuale NIST) pubblica un
bando, a cui risponde IBM con l'algoritmo LUCIFER.

L'algoritmo di IBM conteneva delle tabelle di sostituzione, che furono
modificate dall'NBS: questo portò a pensare, per molti anni, che il
governo avesse introdotto una trapdoor nelle tabelle di sostituzione,
tuttavia non fu mai trovata.

Infine il DES fu pubblicato come standard nel '77; col progredire
della potenza di calcolo nei calcolatori, questo algoritmo è divenuto
suscettibile a diversi attacchi, così sono state introdotte delle
sue varianti (compatibilmente con l'hardware legacy), come il triplo
DES (3DES).

Di per sé l'algoritmo DES è robusto, tuttavia la sua chiave di 56bit
è relativamente corta ($\left|\mathscr{K}\right|=2^{56}\simeq2^{6}\cdot10^{15}$),
e questo permette di effettuare in breve tempo un'analisi esaustiva
dello spazio delle chiavi. Oltre a questo, DES sarebbe stato vulnerabile
ad attacchi di crittoanalisi differenziale (si cerca un errore nella
realizzazione della proprietà di perfetta diffusione, prendendo un
blocco di testo in chiaro e cifrandolo, cambiando un bit alla volta
e cercando evidenza statistica all'interno del blocco cifrato) se
il suo algoritmo avesse avuto 14 \emph{round}; tuttavia la specifica
di IBM prevede 16 \emph{round} (si veda \propref{Propriet=0000E0-fondamentali-cifrari-Shannon}).

DES è un cifrario a blocchi di 64bit, che nel modo più semplice lavora
prendendo un blocco, cifrandolo e poi ripetendo il processo in modo
indipendente per il blocco successivo (modo \emph{ECB}).

\subsection{Schema Feistel}

Descriviamo l'idea dietro a questo schema con la procedura da implementare
per realizzarlo:
\begin{itemize}
\item prendiamo un blocco di bit $B_{1}$, e dividiamolo in due metà, in
modo da avere la sinistra $L_{1}$ e la destra $R_{1}$;
\item usiamo la chiave $K$ per generare una sotto-chiave di round $K_{i}$;
\item permutiamo le due metà al round $i$-esimo, facendo passare la metà
di sinistra attraverso una funzione fortemente non lineare che utilizzi
la chiave: $B_{i}=R_{i-1}\parallel L_{i-1}\oplus f\left(R_{i-1},\,K_{i}\right)$;\marginpar{La notazione $A\parallel B$ indica la concatenazione di $B$ dopo
di $A$}
\item se vi sono $n$ round in totale, non si effettua la permutazione di
$L_{i}$ ed $R_{i}$ al round $n$-esimo, e si ottiene $B_{n}=R_{n}\parallel L_{n}$
\end{itemize}
Possiamo presumere che, continuando a permutare le due metà del blocco,
grazie alla funzione $f\left(\right)$, vi sarà un'ottima diffusione
dei bit in ingresso; inoltre la confusione sarà garantita dalla presenza
delle chiavi di round $K_{i}$, generate a partire dalla chiave iniziale.

Lo schema Feistel permette di decifrare con la stessa procedura della
cifratura, utilizzando $B_{n}$ e $K_{n}$ come ingresso, e ottenendo
$B_{1}$ alla fine degli $n$ round.

\section{Algoritmo DES}

Il DES applica 16 volte (round) il blocco di Feistel, utilizzando
la seguente procedura:
\begin{enumerate}
\item si applica una permutazione iniziale (IP) fissata al blocco di 64bit
in chiaro;
\item si prende la chiave DES (da 64bit), si rimuovono gli 8bit di parità
e si utilizzano i 56bit per produrre le successive chiavi di round
$K_{i}$;
\begin{enumerate}
\item si permutano i bit della chiave da 56bit, poi essa viene divisa in
due blocchi da 28bit, rispettivamente $C_{0}$ e $D_{0}$;
\item si produce la chiave di round secondo una tabella di shift fissa (funzione
$LS_{i}$), che fa scorrere i bit delle due metà della chiave ($C_{i}$,
$D_{i}$) in modo circolare di 1 o 2 posizioni, a seconda del numero
$i$ del round: $C_{i}=LS_{i}\left(C_{i-1}\right),\,D_{i}=LS_{i}\left(D_{i-1}\right)\implies K_{i}=C_{i}\parallel D_{i}$;
\item tramite una tabella di riduzione, si estraggono dalla chiave di round
48bit, da usare nella funzione $f\left(\right)$.
\end{enumerate}
\item si prende la chiave di round $K_{i}$ e il blocco sinistro di round
$R_{i-1}$ e si genera il blocco destro $L_{i}$ tramite la funzione
$f\left(\right)$
\begin{enumerate}
\item il blocco $R_{i-1}$ in ingresso viene espanso a 48bit tramite una
tabella di espansione;
\item si somma modulo due la chiave di round al blocco espanso: $E\left(R_{i-1}\right)\oplus K_{i}$;
\item si divide il risultato da 48bit in 8 gruppi da 6bit;
\item ciascun gruppo viene modificato tramite una S-Box (8 in totale), che
prende un blocco da 6bit e lo riduce a 4bit;
\item gli 8 gruppi da 4bit sono uniti in un blocco da 32bit, che viene permutato;
\item il blocco ottenuto viene infine usato assieme alla chiave nella funzione
$f\left(\right)$.
\end{enumerate}
\end{enumerate}

\subsection*{Initial Permutation (IP)}

Essa lavora su un blocco di 64bit, e produce un'altro blocco altrettanto
lungo. Osserviamo che la permutazione iniziale, nota e fissa, non
migliora diffusione o confusione; alcune ipotesi sostengono che poteva
essere un modo per inizializzare l'hardware dell'epoca ('70).

La seguente tabella di look-up realizza la permutazione iniziale del
DES:

\subsection*{Funzione $\boldsymbol{f}$}

Essa lavora su blocchi di 32bit, e garantisce ottima diffusione grazie
alle permutazioni effettuate sui blocchi di bit.

\subsection*{S-Box}

Tabella di sostituzione che prende un blocco da 6bit, e usando il
primo e l'ultimo per indicare la riga e i 4 centrali per indicare
la colonna, si ottiene un blocco da 4bit. Infatti, la tabella dell'S-Box
contiene valori di massimo 4bit, che vengono indirizzati nel modo
seguente: se $B_{h}=\overset{{\scriptscriptstyle \text{R}_{0}}}{0}\underset{{\scriptscriptstyle \text{C}_{0}}}{0}\underset{{\scriptscriptstyle \text{C}_{1}}}{1}\underset{{\scriptscriptstyle \text{C}_{2}}}{0}\underset{{\scriptscriptstyle \text{C}_{3}}}{0}\overset{{\scriptscriptstyle \text{R}_{1}}}{1}$,
allora il valore ottenuto sarà l'elemento alla riga $01_{2}=1_{10}$
e alla colonna $0100_{2}=4_{10}$ della S-Box $h$ (righe e colonne
sono numerate a partire da 0); queste tabelle sono state progettate
per realizzare una trasformazione non lineare sui blocchi.

\subsection*{Chiave di round}

Ogni bit della chiave sarà utilizzato mediamente in 14 su 16 round;
questo permette di realizzare ottima confusione. I bit di parità della
chiave, che portano la sua lunghezza da 56 a 64bit, sono un metodo
per controllarne l'integrità (per esempio per trasmettere la chiave
senza errori, come controllo aggiuntivo).

Notiamo che il DES rispetta il principio di Kerchoffs (pagina \pageref{thm:Principio-di-Kerchoffs})
infatti la chiave deve rimanere privata, ed è l'unico ``ingrediente''
che permette di decifrare un blocco cifrato; l'algoritmo è invece
pubblico e ben definito. L'algoritmo è infatti progettato per rendere
l'analisi esaustiva dello spazio delle chiavi l'unico tipo di attacco
possibile.

\section{Modi operativi\label{sec:Modi-operativi-cifrario-blocchi}}

I cifrari a blocchi, come DES, supportano i modi operativi descritti
nelle seguenti sotto-sezioni.

\subsection*{Electronic Code Book (ECB)}

Il messaggio in chiaro è diviso in blocchi, i quali sono cifrati in
modo indipendente, utilizzando la stessa chiave:
\[
c_{i}=E_{k}\left(p_{i}\right),\quad p_{i}=E_{k}\left(c_{i}\right)
\]
Risulta facile individuare i blocchi ripetuti, inoltre è possibile
costruire una tabella con le corrispondenze tra blocchi i chiaro e
blocchi cifrati.

\subsection*{Cipher Block Chaining (CBC)}

Si tratta di un modo operativo concatenato: in qualche modo, ciascun
blocco è legato agli altri, e si ottiene l'effetto di non avere blocchi
ripetuti (questo vale per ciascun modo concatenato). CBC usa un vettore
di inizializzazione (IV), come se fosse una chiave addizionale, come
primo blocco cifrato $c_{0}$; a partire da esso, le funzioni di cifratura
e decifratura sono definite come:
\[
c_{i}=E_{k}\left(p_{i}\oplus c_{i-1}\right),\quad p_{i}=c_{i-1}\oplus D_{k}\left(c_{i}\right)
\]
Si noti che IV può essere inviato anche in chiaro.

\subsection*{Cipher Feedback (CFB)}

Si tratta di un modo concatenato. Consiste nel cifrare il vettore
di inizializzazione e poi sommarlo al blocco in chiaro; il risultato
è usato come IV per il round successivo. Questo algoritmo crea una
sequenza di bit pseudo-casuali.

Per decifrare non è necessaria una funzione specifica, ma basta ripetere
la somma in base 2 con i blocchi cifrati al posto dei blocchi in chiaro:
\[
c_{i}=p_{i}\oplus E_{k}\left(c_{i-1}\right),\quad p_{i}=c_{i}\oplus E_{k}\left(c_{i-1}\right)
\]
Lo svantaggio di questo cifrario è l'amplificazione degli errori di
trasmissione, da un blocco al suo successivo.

\subsection*{Output Feedback Mode (OFB)}

Si tratta di un modo concatenato. Consiste nel cifrare il vettore
di inizializzazione, sommarlo al blocco in chiaro, e poi usare l'IV
cifrato come ingresso per il blocco successivo. La catena di cifrature
effettuate sull'IV costituisce una PRBS (pseudo-random binary sequence,
una sequenza pseudo-casuale di bit). L'unico modo per generare la
stessa sequenza è conoscere la chiave; inoltre un errore di trasmissione
non si propaga tra i blocchi.

Le funzioni di cifratura e decifratura sono definite come:
\[
c_{i}=p_{i}\oplus E_{k}^{\left(i\right)}\left(\text{IV}\right),\quad p_{i}=c_{i}\oplus E_{k}^{\left(i\right)}\left(\text{IV}\right)
\]
dove $E_{k}^{\left(i\right)}\left(\text{IV}\right)$ è la funzione
$E_{k}$ applicata in modo ricorsivo per $i$ volte all'IV.

\subsection*{Counter Mode (CTR)}

Questo modo \uline{non} è concatenato. Consiste nel cifrare un
IV con la chiave, per poi sommarlo al blocco in chiaro; per ciascun
blocco in chiaro $i$-esimo viene usato un $\text{IV}^{\left(i\right)}\coloneqq\text{IV}+i$,
e ogni blocco cifrato è prodotto in modo indipendente; la sicurezza
di questo modo si basa unicamente su quella della funzione di cifratura
(in caso di ottima diffusione e confusione, un attaccante non può
sapere se a IV sta venendo sommato un intero e quale esso sia).

LE funzioni di cifratura e decifratura sono definite come:
\[
c_{i}=p_{i}\oplus E_{k}\left(\text{IV}^{\left(i\right)}\right),\quad p_{i}=c_{i}\oplus E_{k}\left(\text{IV}^{\left(i\right)}\right)
\]


\section{Sicurezza del DES}

\subsection{Doppio DES}

Per aumentare la sicurezza di DES potremmo provare ad utilizzare una
chiave più lunga; in tal caso, ci chiediamo se esista una chiave $K^{\prime}=K_{1}\parallel K_{2}$
tale che $\left|K^{\prime}\right|=56+56=112\text{bit}$, e per essa
si verifichi che $E_{K^{\prime}}\left(p\right)\equiv E_{K_{2}}\left(E_{K_{1}}\left(c\right)\right)$.

Se prendiamo la funzione di cifratura \emph{affine} (si veda \subsecref{Cifrario-affine}),
dove abbiamo $K_{1}=\left(a,\,b\right)$, allora possiamo cifrare
un testo in chiaro $p$ come $c_{1}=E_{K_{1}}\left(p\right)=\mod{a\cdot p+b}n$;
prendiamo un'altra chiave $K_{2}=\left(c,\,d\right)$ e con essa cifriamo
di nuovo il messaggio $p$, ottenendo $c_{2}=E_{K_{2}}\left(p\right)=\mod{c\cdot p+d}n$.

Si nota subito che, per le caratteristiche della funzione di cifratura
(combinazione lineare con la chiave), esiste $K^{\prime}=\left(a\cdot c,\,b+d\right)$
per cui vale $c^{\prime}=E_{K_{2}}\left(E_{K_{1}}\left(p\right)\right)\equiv E_{K^{\prime}}\left(p\right)=\mod{ac\cdot p+b+d}n$.
Dato che il cifrario affine forma un gruppo algebrico (chiuso rispetto
alla composizione), cifrando due volte con due chiavi $K_{1}$ e $K_{2}$
non viene aumentata la cardinalità dello spazio delle chiavi, dato
che esiste in ogni caso una chiave equivalente $K^{\prime}$ di lunghezza
identica alle singole chiavi.

Il DES non gode di questa proprietà: cifrando più volte il messaggio
in chiaro con due chiavi differenti, aumenta di $2^{\left|K\right|}$
la cardinalità dello spazio delle chiavi. Nel caso del doppio DES
(2DES), si ha una chiave $K=K_{1}\parallel K_{2}$ lunga il doppio
di una chiave singola, dunque $\left|\mathscr{K}\right|=2^{112}\simeq2^{2}\cdot10^{33}$.

Il doppio DES è suscettibile dell'attacco Meet-in-the-Middle (MiM):
questa vulnerabilità permette di analizzare al più $2^{57}$ chiavi,
invece delle $2^{112}$ totali; per ovviare al problema si è scelto
di proseguire con la composizione, ottenendo il triplo DES.

\subsection{Triplo DES}

Questo cifrario è la composizione di tre chiavi DES, che portano la
cardinalità dello spazio delle chiavi a $2^{168}$; anche con un attacco
MiM lo spazio delle chiavi si riduce al più a $2^{112}$, e al giorno
d'oggi è considerato sicuro almeno quanto l'AES, ma è meno veloce
(bisogna cifrare 3 volte con DES).

Il metodo più intuitivo per implementare il 3DES è effettuare tre
volte la cifratura con tre chiavi differenti: $c=E_{K_{1}}\left(E_{K_{2}}\left(E_{K_{3}}\left(p\right)\right)\right)$;
un approccio che utilizza solo due chiavi, senza ridurre lo spazio
delle chiavi, è il seguente:
\[
c=E_{K_{1}}\left(D_{K_{2}}\left(E_{K_{1}}\left(p\right)\right)\right),\quad p=D_{K_{1}}\left(E_{K_{2}}\left(D_{K_{1}}\left(c\right)\right)\right)
\]
Questa implementazione del triplo DES è compatibile con l'hardware
per il singolo DES.

Rivest ha proposto la seguente alternativa, chiamata DESX, che usa
tre chiavi ma effettua una sola cifratura DES, ed è sicura quanto
il 3DES standard:
\[
c=K_{3}\oplus E_{K_{2}}\left(K_{1}\oplus p\right)
\]


\subsection{Attacco Meet-in-the-Middle}

Abbiamo già osservato che DES non è un gruppo; ci chiediamo come possiamo
affrontare questa caratteristica, per ridurre lo spazio delle chiavi
nel caso di una composizione. Conduciamo un attacco di testo in chiaro
noto, partendo da una coppia corrispondente di testo in chiaro e testo
cifrato $p\leftrightarrows c$, senza conoscere la chiave.

Poniamoci nel caso di un testo cifrato ricavato tramite 2DES come
$c=E_{K_{2}}\left(E_{K_{1}}\left(p\right)\right)$, e vogliamo ottenere
$K^{\prime}=K_{1}\parallel K_{2}$. Se quanto affermato sul testo
cifrato è vero, allora applicando a $c$ la decifratura con $K_{2}$
si ottiene
\begin{equation}
D_{K_{2}}\left(c\right)=E_{K_{1}}\left(p\right)\label{eq:MiM-2DES}
\end{equation}
Effettuiamo una esplorazione esaustiva dello spazio delle chiavi $K_{1}$
memorizzando i risultati in una tabella, per cui sarà necessario memorizzare
$2^{56}$ valori da 8Byte (64bit) ovvero circa 0.5EB; poi effettuiamo
la stessa analisi per lo spazio delle chiavi $K_{2}$, questa volta
evitando di memorizzare i risultati ma confrontando ciascuna chiave
trovata con i valori di $K_{1}$ salvati.

Notiamo che saranno necessarie al più $2\cdot2^{56}=2^{57}$ operazioni
di cifratura e decifratura con DES, e al più $2^{112}$ confronti.

\section{Sicurezza delle password}

\subsection{Funzioni di hash\label{subsec:Funzioni-di-hash} }

Per ragioni di sicurezza, una password non viene mai memorizzata in
chiaro; in pratica, si usa una funzione di \emph{hash}. Si tratta
di una funzione con le seguenti caratteristiche:
\begin{itemize}
\item accetta un ingresso di lunghezza arbitraria, produce una uscita di
lunghezza fissa;
\item non è invertibile (ci sono infiniti messaggi con lo stesso hash in
uscita dalla funzione);
\item sia unidirezionale (presa una uscita $y\left(x\right)$, sia impossibile
trovare uno qualunque degli infiniti $x$ che produca quell'uscita);
\item goda di ottima diffusione.
\end{itemize}
Usando una simile funzione, possiamo memorizzare lo hash della password,
e confrontarlo con l'hash calcolato sulla password quando fornita.

È possibile attaccare queste funzioni provando un gran numero di ingressi
casuali differenti, rispetto al numero delle possibili uscite; la
sicurezza viene determinata dalla lunghezza dell'uscita.

Si può mitigare questo attacco scegliendo una funzione di hash particolarmente
lenta.

\subsection{Attacco del vocabolario}

Dato che quasi nessuno sceglie una stringa veramente casuale come
password, è possibile attaccare l'hash corrispondente generando tutti
gli hash di tutte le parole di una lingua, apportando eventuali variazioni
sulle singole parole (aggiunta di un numero, iniziale maiuscola, eccetera...)
e poi confrontando gli hash ottenuti con quelli nel file delle password.

All'interno di sistemi con un gran numero di utenti, la probabilità
di trovare una password ``banale'' per almeno qualche utenza è molto
elevata.

La contromisura migliore è applicare un \emph{salt} (``sale'') alla
password; esso è una stringa di bit, memorizzata in chiaro nel file
delle password. L'hash ``salato'' è calcolato sulla stringa ottenuta
dalla concatenazione del sale con la password.

Il sale non aumenta la complessità dell'attacco sul singolo utente,
bensì ha il vantaggio che, nel caso di un attacco del vocabolario
su numerose utenze, essi abbiano tutti un hash diverso, anche a parità
di password, per via del sale (che sarà diverso per ogni utente).
Un attaccante dovrà calcolare l'hash per ogni parola del vocabolario,
per ogni sale possibile.

Nei sistemi UNIX, le password sono salate con un salt a 12bit, e la
funzione di hash è basata su DES; tradizionalmente si troncava la
password utente a 64bit (8 caratteri), da questi si ottenevano i primi
7 bit di ciascun Byte (per rappresentare solo i caratteri stampabili),
e i 56bit così ottenuti erano usati come chiave DES. Questa chiave
$K_{h}$ è poi usata per cifrare un blocco di 0 da 64bit, con 25 round
di DES; a ogni round, i 12bit del sale sono usati per perturbare la
funzione di cifratura (modificando le S-Box, rende inutile l'implementazione
hardware a priori). Infine sale e blocco cifrato sono codificati in
base 64.

La funzione così realizzata è reputata unidirezionale: infatti ottenere
la password senza conoscere la chiave e con un DES da più di 16 round,
per giunta perturbato dal sale, è un problema difficile.

\chapter{Cifrario AES}

\section{Introduzione}

Nel '97, quando DES era ancora in vigore, il NIST fece un bando per
la creazione di un nuovo standard crittografico, destinato alle informazioni
governative; l'algoritmo selezionato fu chiamato AES. Si tratta di
un cifrario a blocchi da 128bit, con chiave a 128, 192 o 256bit.

La procedura per selezionare l'algoritmo fu gestita in modo pubblico
e trasparente, attraverso delle conferenze; prima di selezionare l'algoritmo
che sarebbe divenuto AES, arrivarono ``in finale'' i cinque seguenti
algoritmi (oggi ancora usati, perché paragonabili all'AES nella sicurezza):
MARS, RC6, Rijndael, Serpent, Twofish.

Nel 2000 viene infine selezionato Rijndael, che viene rinominato in
AES; in particolare, Rijndael definisce una famiglia di cifrari: per
AES viene selezionato una dimensione del blocco di 128bit e chiavi
da 128 a 265bit.

Dal punto di vista matematico, AES non si basa su uno schema Feistel,
ma su una rete di sostituzioni e trasformazioni; a seconda della dimensione
della chiave, il Rijndael effettua 10, 12 o 14 cicli su ciascun blocco,
e può essere utilizzato in tutti i modi operativi concatenati mostrati
per il DES (vedere \secref{Modi-operativi-cifrario-blocchi}).

\section{Algoritmo AES}

Per maggiore semplicità, analizziamo il caso di Rijndael con chiave
a 128bit, e 10 round. Osserviamo che i blocchi da 128bit sono suddivisi
in 16Byte, organizzati in matrici $4\times4$; tutti gli elementi
di queste matrici sono ottetti del campo $\mathcal{GF}\left(2^{8}\right)$
e rappresentano i polinomi al suo interno, dove il polinomio irriducibile
per definire il campo è $P\left(x\right)=x^{8}+x^{4}+x^{3}+x^{2}+x+1$.
L'ottetto di zeri non è invertibile, tuttavia deve essere ammissibile
nel cifrario: si consideri l'elemento nullo come inverso di sé stesso.

Ogni round del Rijndael è composto da 4 livelli, che operano sulla
matrice $4\times4$ che rappresenta il blocco da 128bit:
\begin{itemize}
\item Substitute Byte (SB): tabella di sostituzione, simile alle S-Box del
DES, ma costruita algebricamente in maniera trasparente;
\item Shift Row (SR): scorrimento delle righe della matrice a sinistra;
\item Mix Column (MC): scorrimento delle colonne a sinistra, evita la degenerazione
del cifrario in 4 cifrari applicati alle singole colonne della matrice;
\item Add Round Key (ARK): per ciascun ciclo si aggiunge una chiave di round,
derivata da quella iniziale a 128bit.
\end{itemize}
L'algoritmo usa round e livelli nel modo seguente:
\begin{enumerate}
\item ARK con chiave di round 0;
\item nove round che usano i livelli $\text{SB}\rightarrow\text{SR}\rightarrow\text{MC}\rightarrow\text{ARK}$,
con le chiavi di round dalla 1 alla 9;
\item un ultimo round che usa i livelli $\text{SB}\rightarrow\text{SR}\rightarrow\text{ARK}$,
con la chiave di round 10.
\end{enumerate}
Le differenze col DES riguardano l'assenza del Feistel, rispetto al
rimescolamento dei bit dato dai quattro livelli di ciascun round;
il risultato è una apparente diffusione perfetta già dal secondo round.
Inoltre, tutte le operazioni sugli ottetti del blocco, sono all'interno
del campo $\mathcal{GF}\left(256\right)$.

\subsection*{SB}

Sostituzione\marginpar{La notazione $\boldsymbol{A}$ in maiuscolo corsivo e grassetto, indica
che A è una matrice} non lineare applicata ai Byte (elementi) della matrice; secondo una
matrice di sostituzione con 16 righe e 16 colonne, numerate a partire
da 0, indirizzate tramite gli stessi bit degli ottetti, nel modo seguente:
sia $\boldsymbol{A}$ la matrice che rappresenta il blocco di partenza,
e sia $a_{1,0}=10001011$; sia $\boldsymbol{B}$ la matrice ottenuta
al termine del livello SB; allora $b_{1,0}$ si ottiene prendendo
il valore indicato all'incrocio della riga 8 con la colonna 11, nella
tabella di sostituzione, e sostituendolo al valore di un elemento
di $\boldsymbol{A}$ ( per esempio $a_{i,j}=\overset{\text{riga}}{\overbrace{1000}}\underset{\text{colonna}}{\underbrace{1011}}\rightarrow61$).

Questa tabella si calcola nel modo seguente:
\begin{itemize}
\item l'input è un ottetto di bit $a_{i,j}=x_{7}x_{6}x_{5}x_{4}x_{3}x_{2}x_{1}x_{0}$
\item calcoliamo il suo inverso in $\mathcal{GF}\left(256\right)\ni a_{i,j}^{-1}=y_{7}y_{6}y_{5}y_{4}y_{3}y_{2}y_{1}y_{0}$
(assumendo che 000000000 sia l'inverso di sé stesso)
\item prendiamo l'ottetto $a_{i,j}^{-1}$, scriviamolo partendo dal bit
meno significativo e come un vettore colonna $\left(y_{0}y_{1}y_{2}y_{3}y_{4}y_{5}y_{6}y_{7}\right)^{\text{T}}$
\item computiamo $b_{i,j}=z_{7}z_{6}z_{5}z_{4}z_{3}z_{2}z_{1}z_{0}$ e scriviamolo
come $\left(z_{0}z_{1}z_{2}z_{3}z_{4}z_{5}z_{6}z_{7}\right)^{\text{T}}$
\end{itemize}
per computare $b_{i,j}$ usiamo la seguente trasformazione, per diffondere
e confondere ulteriormente i bit:
\[
b_{i,j}=\begin{bmatrix}1 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\
1 & 1 & 0 & 0 & 0 & 1 & 1 & 1\\
1 & 1 & 1 & 0 & 0 & 0 & 1 & 1\\
1 & 1 & 1 & 1 & 0 & 0 & 0 & 1\\
1 & 1 & 1 & 1 & 1 & 0 & 0 & 0\\
0 & 1 & 1 & 1 & 1 & 1 & 0 & 0\\
0 & 0 & 1 & 1 & 1 & 1 & 1 & 0\\
0 & 0 & 0 & 1 & 1 & 1 & 1 & 1
\end{bmatrix}\cdot\begin{bmatrix}y_{0}\\
y_{1}\\
y_{2}\\
y_{3}\\
y_{4}\\
y_{5}\\
y_{6}\\
y_{7}
\end{bmatrix}+\begin{bmatrix}1\\
1\\
0\\
0\\
0\\
1\\
1\\
0
\end{bmatrix}
\]


\subsection*{SR}

Spostamento a sinistra delle 4 righe rispettivamente di 0, 1, 2, 3
passi (la prima riga rimane immutata, la seconda è spostata di 1,
ecc...); sia $\boldsymbol{B}$ la matrice proveniente dal livello
SB, allora da questo livello otteniamo la seguente matrice $\boldsymbol{C}$:
\[
C=\begin{bmatrix}c_{0,0} & c_{0,1} & c_{0,2} & c_{0,3}\\
c_{1,0} & c_{1,1} & c_{1,2} & c_{1,3}\\
c_{2,0} & c_{2,1} & c_{2,2} & c_{2,3}\\
c_{3,0} & c_{3,1} & c_{3,2} & c_{3,3}
\end{bmatrix}=\begin{bmatrix}b_{0,0} & b_{0,1} & b_{0,2} & b_{0,3}\\
b_{1,1} & b_{1,2} & b_{1,3} & b_{1,0}\\
b_{2,2} & b_{2,3} & b_{2,0} & b_{2,1}\\
b_{3,3} & b_{3,0} & b_{3,1} & b_{3,2}
\end{bmatrix}
\]


\subsection*{MC}

Prendiamo la matrice $\boldsymbol{C}$ ottenuta dal livello precedente
ed effettuiamo il suo prodotto per una matrice $M$ per ottenere $\boldsymbol{D}=\boldsymbol{M}\cdot\boldsymbol{C}$,
nel modo seguente:
\[
D=\begin{bmatrix}00000010 & 00000011 & 00000001 & 00000001\\
00000001 & 00000010 & 00000011 & 00000001\\
00000001 & 00000001 & 00000010 & 00000011\\
00000011 & 00000001 & 00000001 & 00000001
\end{bmatrix}\cdot\begin{bmatrix}c_{0,0} & c_{0,1} & c_{0,2} & c_{0,3}\\
c_{1,0} & c_{1,1} & c_{1,2} & c_{1,3}\\
c_{2,0} & c_{2,1} & c_{2,2} & c_{2,3}\\
c_{3,0} & c_{3,1} & c_{3,2} & c_{3,3}
\end{bmatrix}
\]
Per garantire la decifratura, sarà necessario che la matrice $\boldsymbol{M}$
sia invertibile; l'inversa $\boldsymbol{M}^{-1}$ avrà più 1 che 0,
e per questo la decifratura in AES è più lenta (di poco) della cifratura.

\subsection*{ARK}

La chiave di round viene sommata bit a bit col blocco ottenuto al
livello precedente: $\boldsymbol{E}=\boldsymbol{D}\oplus\boldsymbol{K}^{\left(i\right)}$.
Ad ogni round $i$-esimo ricaviamo una chiave di 16Byte a partire
da quella iniziale; se abbiamo chiavi da 128bit l'algoritmo prevede
10 round e quindi saranno necessarie 11 chiavi di round.

Esprimendo la chiave iniziale come matrice $4\times4$ chiamata $\boldsymbol{K}$,
possiamo indicarla come la giustapposizione di 4 colonne di 4 elementi
ciascuna; le 11 chiavi necessarie saranno costituite in totale da
44 colonne di 4Byte ciascuna. Allora le colonne 0, 1, 2, 3 appartengono
alla chiave $\boldsymbol{K}^{\left(0\right)}$, le colonne 4, 5, 6,
7 costituiscono $\boldsymbol{K}^{\left(1\right)}$, e così via.

Le altre 40 colonne si ottengono dalle 4 iniziali nel modo seguente;
sia $\vec{w}\left(i\right)$ la $i$-esima colonna:
\[
\begin{cases}
\vec{w}\left(i\right)=\vec{w}\left(i-4\right)\oplus\vec{w}\left(i-1\right) & \mod i4\neq0\\
\vec{w}\left(i\right)=\vec{w}\left(i-4\right)\oplus T\left[\vec{w}\left(i-1\right)\right] & \mod i4=0
\end{cases}
\]
La trasformazione $T$ è definita nel modo seguente; sia $r\left(i\right)=00000010^{\left(i-4\right)/4}\in\mathcal{GF}\left(2^{8}\right)$,
e sia SB il livello Substitute Byte dell'algoritmo Rijndael:
\[
T\left[\left(a,\,b,\,c,\,d\right)\right]=\begin{bmatrix}a\\
b\\
c\\
d
\end{bmatrix}\rightarrow\begin{bmatrix}b\\
c\\
d\\
a
\end{bmatrix}\rightarrow\text{SB}\rightarrow\begin{bmatrix}e\\
f\\
g\\
h
\end{bmatrix}\rightarrow\begin{bmatrix}e\oplus r\left(i\right)\\
f\\
g\\
h
\end{bmatrix}
\]
In questo modo si ottiene la chiave di round come:
\[
\boldsymbol{K}^{\left(i\right)}=\left[\vec{w}\left(4i\right),\,\vec{w}\left(4i+1\right),\,\vec{w}\left(4i+2\right),\,\vec{w}\left(4i+3\right)\right]
\]


\subsection*{Decifratura}

I quattro livelli di ciascun ciclo dell'algoritmo Rijndael sono invertibili:
\begin{itemize}
\item Inverted Substitute Byte (ISB): tabella di sostituzione inversa a
quella del livello SB;
\item Inverted Shift Row (ISR): scorrimento delle righe a destra invece
che a sinistra;
\item Inverted Mix Column (IMC): si usa l'inversa della matrice $\boldsymbol{M}$:
$\boldsymbol{C}=\boldsymbol{M}^{-1}\cdot\boldsymbol{D}$;
\item Add Round Key (ARK): questo livello, basato sulla somma bit a bit,
è l'inverso di sé stesso.
\end{itemize}
Possiamo decifrare un blocco applicando all'inverso i 10 round:
\begin{enumerate}
\item il primo round usa $\boldsymbol{K}^{\left(10\right)}$ e i livelli
$\text{ARK}\rightarrow\text{ISR}\rightarrow\text{ISB}$;
\item i nove round successivi usano le chiavi dalla 9 alla 1, con i livelli
$\text{ARK}\rightarrow\text{IMC}\rightarrow\text{ISR}\rightarrow\text{ISB}$;
\item un ultimo round usa ARK con la chiave $\boldsymbol{K}^{\left(0\right)}$.
\end{enumerate}

\section{Sicurezza dell'AES}

Al contrario del DES, le cui S-Box avevano fatto sorgere il dubbio
della presenza di trapdoor segrete, in AES la tabella di sostituzione
è ottenuta tramite una procedura algebrica definita; inoltre, il livello
Substitute Byte consente di ottenere un elevato livello di non linearità,
con la trasposizione dei vettori.

Ad oggi, gli unici attacchi che funzionano contro AES, sfruttano debolezze
dell'implementazione, e non dell'algoritmo.

\chapter{Successioni Pseudo-casuali}

\section{Sequenze binarie pseudo-casuali (PRBS)\label{sec:Sequenze-binarie-pseudo-casuali}}

Se pensiamo che l'AES sia sicuro, dobbiamo limitare questa osservazione
alla pratica: infatti, anche se non è possibile trovare la chiave
di cifratura in un periodo di tempo accettabile, dal punto di vista
teorico e con un tempo infinito a disposizione, è possibile eludere
la sicurezza di AES.

Esiste tuttavia un cifrario inviolabile anche dal punto di vista teorico:
prendiamo una sequenza di bit da cifrare $p$ e la sommiamo bit a
bit con una sequenza casuale $r$, ottenendo la sequenza cifrata:
\[
c=p\oplus r
\]
La sequenza $r$ deve essere veramente casuale (nessuna autocorrelazione
del primo o secondo ordine) e impredicibile, ottenuta per esempio
osservando un fenomeno aleatorio. Per decifrare un $c$ ottenuto in
questo modo, è necessario sommare bit a bit a $c$ la stessa sequenza
casuale $r$ usata nella cifratura.

Osserviamo che la sequenza casuale $r$ deve avere la stessa lunghezza
dei dati da cifrare ($\left|r\right|=\left|p\right|$, per consentire
la somma bit a bit con $p$), ed essa deve essere trasportata in modo
sicuro al destinatario; inoltre, la sequenza $r$ va usata una volta
sola, per mantenere la sua impredicibilità.

Questo sistema di cifratura ha rilevanza se possiamo generare una
sequenza $r$ pseudo-casuale, ovvero a parità di inizializzazione,
è possibile generare in modo indipendente la stessa sequenza $r$.

\subsection{Generatore lineare congruenziale}

Ricaviamo l'elemento $i$-esimo della sequenza pseudo-casuale attraverso
una trasformazione lineare applicata al precedente, modulo un composto:
\[
x_{i}=\mod{\left(a\cdot x_{i-1}+b\right)}n
\]
La sequenza viene generata a partire dai tre parametri $a$, $b$,
$n$ e il suo sviluppo è determinato dal seme iniziale, il primo elemento
$x_{0}$.

Anche se il modulo aggiunge della complessità alla trasformazione
lineare, in molti casi è possibile ottenere i tre parametri osservando
abbastanza a lungo la sequenza $r$.

\subsection{Funzione unidirezionale}

Un metodo algoritmicamente sicuro ma computazionalmente non efficiente,
consiste nell'impiego di funzioni unidirezionali nella generazione
della sequenza. Le funzioni non invertibili $y=f\left(x\right)$ permettono
di tentare di trovare un $\overline{y}$ provando per tentativi degli
$\overline{x}$ tali che $\overline{y}=f\left(\overline{x}\right)$,
mentre le funzioni unidirezionali (invertibili o meno) non permettono
di ``tirare a indovinare'' l'$\overline{x}$ che genera un $\overline{y}$
(anche provando per tentativi non è possibile trovare $\overline{x}$).

Una sequenza pseudo-casuale del genere si inizializza con un seme
$x_{0}$, mentre l'elemento $i$-esimo si ottiene come:
\[
x_{i}=f\left(x_{0}+i\right)
\]
Se la funzione unidirezionale $f\left(\right)$ è la funzione di cifratura
del DES con chiave $K=x_{0}+i$ (va applicata la funzione per generare
ciascun bit $i$-esimo), abbiamo una buona funzione unidirezionale
(genera una sequenza apparentemente casuale, per invertire la funzione
sarebbe necessario trovare la chiave DES) che tuttavia risulta non
pratica per l'elevato costo computazionale.

\subsection{Generatore ai residui quadratici (Blum, Blum e Shub)}

Si prendano due primi $p$ e $q$ grandi, entrambi congruenti a 3
in modulo 4:
\[
p\gg1,\,q\gg1\tc\cgm p34\land\cgm q34
\]
Definiamo il prodotto $n=p\cdot q$, e prendiamo un numero casuale
che non abbia $p$ o $q$ tra i suoi fattori ($x\perp n$).

La successione viene inizializzata a partire da un residuo quadratico
$\cgm{x_{0}}{x^{2}}n$; l'$i$-esimo elemento viene calcolato come:
\[
\cgm{x_{i}}{x_{i-1}^{2}}n
\]
mentre il bit $i$-esimo della sequenza sarà il bit meno significativo
dell'elemento $x_{i}$ ($b_{i}={\scriptstyle \text{LSB}}\left(x_{i}\right)$):

Normalmente, la sequenza di bit $\left\{ b_{i}\right\} $ ha una statistica
ben fatta (probabilità circa$\nicefrac{1}{2}$ che esca 0 o 1), ha
autocorrelazione nulla, ed assenza di memoria ($b_{i}$ non dipende
da $b_{i-1}$). La differenza con una sequenza casuale vera è che
essa è periodica (dovrà essere garantito un periodo lungo); inoltre
si tratta di un generatore lento (per il calcolo di un quadrato per
ciascun bit).

Con una sequenza generata in questo modo, è possibile prevedere un
bit successivo $b_{i+k}$ una volta noti un $x_{i}$ e $n$; tuttavia
è impossibile ottenere un $b_{i-h}$, poiché sarebbe necessario calcolare
la radice quadrata modulo $n$, e quindi sono necessari i fattori
$p$ e $q$ (e con $p$ e $q$ scelti adeguatamente il problema della
fattorizzazione risulta impraticabile).
\begin{example}
\emph{Usare il generatore di Blum, Blum e Shub con $p=43$ e $q=31$,
cercando di determinare il suo periodo.}
\end{example}
$\checked$Ricaviamo subito $n=p\cdot q=1333$; scegliamo inoltre
$x_{0}=50\perp1333$. Applichiamo l'algoritmo:
\[
\begin{array}{ccc}
i & x_{i} & b_{i}\\
0 & \cgm{50^{2}}{\boldsymbol{1167}}{1333} & 1\\
1 & \cgm{1167^{2}}{\boldsymbol{896}}{1333} & 0\\
2 & \cgm{896^{2}}{\boldsymbol{350}}{1333} & 0\\
3 & \cgm{350^{2}}{\boldsymbol{1197}}{1333} & 1\\
4 & \cgm{1197^{2}}{\boldsymbol{1167}}{1333} & 1
\end{array}
\]
Notiamo che il periodo vale 4 (il generatore continuerà a produrre
$1,\,0,\,0,\,1\ldots$).\demo

\section{Periodo del generatore ai residui quadratici}

\subsection{Calcolare il periodo}

Gli studi di Blum, Blum e Shub hanno mostrato che il periodo $\tau$
della sequenza del loro generatore, è un divisore della funzione della
funzione di Carmichael, del prodotto $n=p\cdot q$:
\[
\tau\backslash\lambda\left(\lambda\left(n\right)\right),\,n=p\cdot q
\]
La funzione di Carmichael di un numero $n$ è, a sua volta, un divisore
del toziente di $n$ ($\lambda\left(n\right)\backslash\varphi\left(n\right)$);
essa si calcola nel modo seguente; preso un intero composto positivo
$n$, esso può essere espresso come prodotto di fattori primi $p_{i}$,
ciascuno con la propria potenza $a_{i}$:
\[
n=p_{1}^{a_{1}}\cdot p_{2}^{a_{2}}\cdot\ldots\cdot p_{r}^{a_{r}}
\]
La funzione di Carmichael è pari al minimo comune multiplo degli ordini
(tozienti) di ciascuno dei $p_{i}^{a_{i}}$, per $i$ da 1 a $r$
(elementi del gruppo moltiplicativo degli elementi invertibili di
$\mathbb{Z}_{n}$):\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Funzione di Carmichael}{\footnotesize{}\index{Carmichael, funzione di@{\footnotesize{}Carmichael, funzione di}}}}[0.2cm]
\begin{equation}
\lambda\left(n\right)=\mcm{\left\{ \varphi\left(p_{i}^{a_{i}}\right)\right\} }{i\in\left[1,\,r\right]}\label{eq:Funzione-di-Carmichael}
\end{equation}

Prendiamo in mano le ipotesi del Teorema \ref{thm:Teorema-piccolo-Fermat},
il quale afferma che preso un intero $a$ e un primo $p$, vale $\cgm{a^{p-1}}1p$;
se $p$ non fosse primo, il Teorema \ref{thm:Teorema-Eulero} ci dice
che $\cgm{a^{\varphi\left(p\right)}}1p$. Nel primo caso, ci chiediamo
infine se esista un intero $q<p-1$ per cui il residuo modulo $p$
di $a$ vale sempre 1 ($\cgm{a^{q}}1p$); in generale questo dipende
da $a$, e chiamiamo questo intero $\ord a=q$.

Nel secondo caso, ci chiediamo se esista un divisore di $\varphi\left(p\right)$
per cui il residuo modulo $p$ di $a$ sia sempre 1; questo accade
per $\lambda\left(p\right)$, che possiamo considerare come l'analogo
dell'ordine di $a$.

Facciamo un paragone tra ordine e funzione di Carmichael:
\begin{itemize}
\item $\ord a\in\mathbb{Z}_{p}$ è il minimo intero $n$ tale che $\cgm{a^{n}}1p$;
l'ordine di $a$ è massimo $p-1$ o comunque un suo divisore.
\item $\lambda\left(n\right)\in\mathbb{Z}_{p}$ è il minimo intero $N$
tale che $\cgm{a^{N}}1p$; $\lambda\left(n\right)$ è al massimo $\varphi\left(n\right)$
o comunque un suo divisore.
\end{itemize}
\begin{example}
Calcolare il periodo del generatore BBS (Blum, Blum e Shub), con $p=23,\,q=19,\,x_{0}=7$.
\end{example}
$\checked$Sia $p$ che $q$ sono congruenti a 3 modulo 4, inoltre
$x_{0}$ essendo primo è sicuramente primo relativo rispetto a $p\cdot q=n=437$.
Calcoliamo la successione (si ricorda che tutti i conti per la colonna
$x_{i}$ sono quadrati in modulo $n$, mentre la colonna $b_{i}$
contiene l'LSB corrispondente):\\
\begin{table}[!h]
\begin{tabular}{cc}
$\begin{array}{ccc}
i & x_{i} & b_{i}\\
0 & 49 & 1\\
1 & 216 & 0\\
2 & 334 & 0\\
3 & 121 & 1\\
4 & 220 & 0\\
5 & 330 & 0
\end{array}$ & $\begin{array}{ccc}
i & x_{i} & b_{i}\\
6 & 87 & 1\\
7 & 140 & 0\\
8 & 372 & 0\\
9 & 292 & 0\\
10 & \boxed{49} & 1\\
\\
\end{array}$\tabularnewline
\end{tabular}
\end{table}
\\
Dalla successione costruita osserviamo che il periodo vale 10. Sappiamo
che il periodo sarà un divisore di $\lambda\left(\lambda\left(n\right)\right)$;
calcoliamo $\lambda\left(n\right)$:
\begin{align*}
\lambda\left(n\right) & =\lambda\left(437\right)=\lambda\left(23\cdot19\right)=\mcm{\varphi\left(23\right)}{\varphi\left(19\right)}\\
 & =\mcm{22}{18}=\mcm{2\cdot11}{2\cdot3^{2}}=11\cdot2\cdot9\\
 & =198
\end{align*}
Ora possiamo calcolare $\lambda\left(\lambda\left(n\right)\right)$:
\begin{align*}
\lambda\left(198\right) & =\lambda\left(2\cdot3^{2}\cdot11\right)=\mcm{\varphi\left(2\right)}{\varphi\left(9\right),\,\varphi\left(11\right)}\\
 & =\mcm 1{2\cdot3,\,2\cdot5}=2\cdot3\cdot5=30
\end{align*}
Concludiamo che il periodo $\tau$ sarà uno tra i possibili divisori
di 30, a seconda dal $x_{0}$ selezionato: $\tau\in\left\{ 1,\,2,\,3,\,5,\,6,\,10,\,15,\,30\right\} $;
presi $p=23,\,q=19$ il periodo è un divisore di 30; con $x_{0}=7$
si ha esattamente $\pi=10$.\demo

\subsection{Massimizzare il periodo}

Per avere un periodo lungo di una sequenza BBS, è necessario scegliere
un $x_{0}$ tale che $\pi=\lambda\left(\lambda\left(n\right)\right)\gg1$;
perché ciò si verifichi, scegliamo $p$ e $q$ nel modo seguente:
\begin{itemize}
\item prendiamo un primo $p_{2}$, tale che anche un $p_{1}=2p_{2}+1$ sia
primo; scegliamo il primo $p=2\cdot p_{1}+1$
\item prendiamo un primo $q_{2}$, tale che anche un $q_{1}=2q_{2}+1$ sia
primo; scegliamo il primo $q=2\cdot q_{1}+1$
\item deve valere $p\neq q$, e $p,\,q\gg1$
\end{itemize}
Scegliendo i due primi col criterio appena mostrato, si otterrà in
periodo più lungo possibile.

\section{Successioni LFSR\label{sec:Successioni-LFSR}}

Si tratta di successioni lineari di bit, con aritmetica modulo 2;
definiamo una sequenza PRBS con la seguente costruzione:
\[
\cgm{x_{n+5}}{x_{n}+x_{n+2}}2
\]
Una notazione equivalente per la precedente congruenza è:
\begin{equation}
\cgm{x_{n}}{x_{n-5}+x_{n-3}}2\label{eq:successione-LFSR-5}
\end{equation}
Chiamiamo successione LFSR con memoria 5 la congruenza (\ref{eq:successione-LFSR-5}).

In generale, data una memoria di $M$ bit (la quale genera una ricorrenza
di ordine $M$), possiamo definire una successione LFSR come:
\[
\cgm{x_{n+M}}{c_{M}\cdot x_{n}+c_{M-1}\cdot x_{n+1}+\ldots+c_{1}\cdot x_{n+M-1}}2
\]
Come prima, una costruzione alternativa (vedremo che essa semplificherà
la sintesi di un circuito sequenziale) per la precedente è:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Successione LFSR}{\footnotesize{}\index{Successione LFSR@{\footnotesize{}Successione LFSR}}}}[0.2cm]
\begin{equation}
\cgm{x_{n}}{c_{M}\cdot x_{n-M}+c_{M-1}\cdot x_{n-M+1}+\ldots+c_{1}\cdot x_{n-1}}2\label{eq:successione-LFSR-M}
\end{equation}
Possiamo descrivere la ricorrenza $M$ relativa alla successione (\ref{eq:successione-LFSR-M})
tramite il seguente polinomio, che ha per coefficienti i $c_{i}$
della ricorrenza:
\begin{equation}
P\left(Y\right)=c_{M}Y^{M}+c_{M-1}Y^{M-1}+\ldots+c_{1}Y+c_{0}\label{eq:polinomio-LFSR-M}
\end{equation}
Il polinomio è nella variabile $Y$ per distinguere chiaramente la
sua variabile da quella della successione (\ref{eq:successione-LFSR-M});
usiamo un polinomio per descrivere la ricorrenza, per lavorare con
i campi di Galois.

Il polinomio (\ref{eq:polinomio-LFSR-M}) ha grado $M$ e descrive
una successione con periodo al più $2^{M}-1$; i polinomi di grado
esattamente $M$ sono in numero $2^{M}-1$: infatti possiamo affermare
che $c_{0}=1$ (riferito all'elemento presente) e $c_{M}=1$ (altrimenti
il polinomio non arriverebbe al grado $M$), sottraendo due gradi
di libertà dal numero totale di polinomi di grado $M$.

Per avere una ricorrenza di periodo massimo, dovremo scegliere un
polinomio \emph{irriducibile}, da cercare tra i $2^{M}-1$ disponibili.

Questa ricorrenza può essere implementata via hardware, tramite dei
registri a scorrimento; per esempio per avere una ricorrenza con periodo
di un milione serviranno almeno 20 celle di memoria ($2^{20}-1\simeq10^{6}$).
La sequenza $\left\{ x_{M}\right\} $ generata in questo modo potrà
essere usata come sequenza pseudo-casuale $r$, nel sistema di cifratura
introdotto all'inizio de \secref{Sequenze-binarie-pseudo-casuali}.
In tal caso la chiave sarà costituita da:
\begin{itemize}
\item i coefficienti del polinomio (\ref{eq:polinomio-LFSR-M}), tranne
il primo e l'ultimo \textemdash~sappiamo che essi valgono sempre
1 \textemdash~ovvero $M-1$ bit in totale, a rappresentare i rimanenti
coefficienti (che essendo residui modulo 2 valgono 0 o 1);
\item i valori degli $x$ con i quali inizializzare il polinomio, ovvero
$M$ bit.
\end{itemize}
Questo metodo è vulnerabile all'attacco del testo in chiaro, ed è
usato quando la velocità di cifratura va privilegiata rispetto alla
sicurezza.

\begin{minipage}[c]{0.5\textwidth}%
\begin{example}
\emph{Consideriamo la successione LFSR definita con la congruenza
seguente:}
\[
\cgm{x_{n}}{x_{n-2}+x_{n-3}}2
\]
\emph{Implementare la ricorrenza in esame con un circuito sequenziale.}
\end{example}
$\checked$Possiamo rappresentare la successione col seguente polinomio:
\[
P\left(Y\right)=Y^{3}+Y^{2}+1
\]

Infatti l'ordine della ricorrenza è 3 (ottenuto osservando gli indici
delle $x$), sappiamo che $c_{3}=c_{0}=1$ e infine i termini $x_{n-2}$
e $x_{n-3}$ rappresentano $Y^{2}$ e $Y^{3}$ rispettivamente; il
periodo massimo della sequenza vale $2^{3}-1=7$ (sarebbe sicuramente
massimo se $P\left(Y\right)$ fosse irriducibile).

Implementiamo la successione LFSR col circuito ne \figref{registro-scorrimento-3}.\demo%
\end{minipage}%
\begin{minipage}[c]{0.5\textwidth}%
\begin{center}
\includegraphics{\string"Illustrazioni/5_2-1 Successione LFSR v1\string".pdf}
\par\end{center}
\captionof{figure}{Registro a scorrimento con 3 celle di memoria}\label{fig:registro-scorrimento-3}%
\end{minipage}
\begin{rem}
Abbiamo già concluso che il periodo di una successione LFSR definita
dal polinomio (\ref{eq:successione-LFSR-M}) \emph{irriducibile},
sarà al massimo $2^{M}-1$, oppure un suo sottomultiplo (può essere
un numero diverso se $P\left(Y\right)$ non è irriducibile); tuttavia,
se $2^{M}-1$ è \emph{primo}, il suo unico sottomultiplo è lui stesso
(si ottiene il periodo massimo possibile). In breve vale la seguente
condizione:
\[
P\left(Y\right)\text{ irriducibile}\land2^{M}-1\text{ primo}\implies\left\{ x_{M}\right\} \text{ periodo massimo }\left(2^{M}-1\right)
\]
\end{rem}

\section{Stato della successione}

Supponiamo di prendere il polinomio $P\left(Y\right)$ irriducibile
(\ref{eq:polinomio-LFSR-M}), allora possiamo definire il campo di
Galois con questo polinomio:
\[
\mathcal{GF}\left(2^{M}\right)=\mod{\mathbb{Z}_{2}\left[Y\right]}{P\left(Y\right)}
\]
I polinomi appartenenti a questo campo, che chiamiamo $s_{j}\left(Y\right)$,
avranno al massimo grado $M-1$ e gli $M$ coefficienti di ciascun
polinomio rappresentano lo stato al passo $j$-esimo di un circuito
sequenziale che genera una successione LFSR, che chiameremo \emph{scrambler}.

Possiamo anche considerare $s_{j}\left(Y\right)\in\mathcal{GF}\left(2^{M}\right)$
come un vettore a $M$ dimensioni, dove le coordinate valgono in modulo
2 (0 o 1).

Se moltiplichiamo per $Y$ un polinomio $s_{j}\left(Y\right)$ \textemdash~il
quale rappresenta lo stato delle $M$ celle di memoria \textemdash~otteniamo
lo shift in avanti di un passo del circuito combinatorio:
\[
Y\cdot s_{j}\left(Y\right)=s_{j+1}\left(Y\right)
\]
A questo punto, possiamo scrivere lo stato al passo $j$-esimo come
un residuo in modulo $P\left(Y\right)$, rispetto allo stato iniziale:
\[
\cgm{s_{j}\left(Y\right)}{s_{0}\left(Y\right)\cdot Y^{j}}{P\left(Y\right)}
\]
Chiediamoci dunque sotto quali condizioni $s_{j}\left(Y\right)=s_{0}\left(Y\right)$,
o in altre parole quanto vale il passo al quale inizia il secondo
periodo; questo si verifica quando $\cgm{Y^{j}}1{P\left(Y\right)}$.
Ci interessa il $j$ per cui questa congruenza è vera, quindi ci interessa
l'intero minimo per cui $Y$ (elemento del campo) elevato a quell'intero
dia 1 come residuo: in pratica cerchiamo l'ordine dell'elemento $Y$:
\[
s_{j}\left(Y\right)=s_{0}\left(Y\right)\implies j=\ord Y,\,Y\in\mathcal{GF}\left(2^{M}\right)
\]

\begin{prop}
\label{prop:Ordine-massimo-da-elemento-GF}L'ordine di un elemento
del campo sarà del tipo $\left(2^{M}-1\right)/d$, con $d$ un qualche
intero; si verifica $d=1$ (ordine massimo, pari a $2^{M}-1$) quando
$Y$ è un elemento generatore del campo:
\[
\ord Y=2^{M}-1\implies Y\text{ elemento generatore}
\]
\end{prop}
%
\begin{prop}
\label{prop:Condizione-tutti-elementi-GF-generatori}Condizione sufficiente
perché il periodo della ricorrenza sia $2^{M}-1$ è che il numero
$2^{M}-1$ sia primo; in tal caso tutti gli elementi del campo $\mathcal{GF}\left(2^{M}\right)$
saranno generatori.
\end{prop}

\section{Scrambler}

Consideriamo un apparato di telecomunicazioni: esso avrà un canale
che trasporta una sequenza di bit; in generale le proprietà statistiche
della sequenza di bit, emessi dalla sorgente, non saranno uniformi.
È possibile che una sorgente trasmetta sequenze lunghe di 0 o 1 (sia
per volontà degli utenti, che per segnalare una condizione o un evento,
o uno stato dell'infrastruttura).

Il modo più banale per codificare bit su un canale di comunicazione,
per esempio sulla fibra ottica, è quello di emettere potenza (luce)
quando si vuole inviare un 1, e non emettere nulla quando si vuole
inviare uno 0. In ricezione, si pone il problema di capire se sia
arrivato un 1 o uno 0: si misura la potenza ricevuta, a intervalli
di tempo regolari $T$ (periodo di cifra), e si determina dell'intensità
del segnale in arrivo è maggiore di una certa soglia e può essere
considerata la codifica di un 1 piuttosto che di uno 0.

Tuttavia i componenti che costituiscono i circuiti del trasmettitore
e del ricevitore, a causa della propria tolleranza di fabbricazione,
non possono essere allineati in partenza sulla frequenza di trasmissione
(sarà sempre presente uno sfasamento del segnale ricevuto, chiamato
\emph{jitter}, o rumore di fase). Si usa quindi un circuito chia\-mato
\emph{clock recovery}, che estrae il sincronismo dal segnale ricevuto;
questo è usato come base per generare un segnale di clock che pilota
un campionatore, facendolo agire esattamente a metà del periodo di
cifra ($T/2$); per estrarre il clock si utilizzano i fronti di salita
e discesa del segnale in ricezione.

Il\marginpar{Un test a livello fisico che si effettua sul ricevitore è chiamato
CID (consecutive identical digits, ovvero cifre identiche consecutive)} problema del clock recovery è l'incapacità di estrarre il sincronismo
da una sequenza di cifre uguali (tutte 1 o 0). VI sono due strade
per ovviare al problema:
\begin{enumerate}
\item usare una modulazione differente per codificare il segnale nel canale
(per esempio HDB3 trasmette transizioni di potenza a prescindere dalla
cifra codificata);
\item su fibra, dove si trasmette con la modulazione on/off, si usa uno
\emph{scrambler}.
\end{enumerate}
La seconda strada prevede l'impiego dello scrambler, che genera una
sequenza pseudo-casuale (non ci saranno più sequenze lunghe di cifre
ripetute); esso dovrà avere le seguenti proprietà:
\begin{itemize}
\item equalizza la statistica del primo ordine (la \emph{media} degli 1
e 0 trasmessi sia \emph{uguale});
\item equalizza la statistica del secondo ordine (l'autocorrelazione degli
1 e degli 0 deve essere uguale, ovvero la sequenza deve avere \emph{assenza
di memoria} \textemdash~essere non periodica).
\end{itemize}
Per realizzare uno scrambler si usa una successione LFSR (si veda
\secref{Successioni-LFSR}); possiamo realizzare gli scrambler in
due modi.

\subsection{Scrambler auto-sincronizzante}

Si prenda la sequenza $\left\{ I_{k}\right\} $ dei dati da confondere,
la si somma in modulo 2 al contenuto di una serie di celle di memoria,
collegando in retroazione solo quelle identificate dal polinomio caratteristico
che descrive la successione LFSR usata. Si ottiene la sequenza $\left\{ U_{k}\right\} $
dei dati confusi.\bigskip{}

\begin{minipage}[c]{0.7\textwidth}%
\begin{example}
\emph{Consideriamo la successione LFSR definita dal polinomio:}
\[
P\left(Y\right)=Y^{3}+Y+1
\]
\emph{Implementare uno scrambler descritto da $P\left(Y\right)$.}
\end{example}
$\checked$Possiamo rappresentare il polinomio con la congruenza:
\[
\cgm{x_{n}}{x_{n-1}+x_{n-3}}2
\]

Infatti l'ordine della ricorrenza è 3 (ottenuto osservando il grado
di $P\left(Y\right)$), sappiamo che $c_{3}=c_{0}=1$ e infine i termini
$Y$ e $Y^{3}$ rappresentano rispettivamente $x_{n-1}$ e $x_{n-3}$;
il periodo massimo della sequenza vale $2^{3}-1=7$ (sarebbe sicuramente
massimo se $P\left(Y\right)$ fosse irriducibile).

Lo scrambler è implementato dal circuito ne \figref{scrambler-auto-sincronizzante-3}.\demo%
\end{minipage}%
\begin{minipage}[c]{0.4\textwidth}%
\begin{center}
\includegraphics[scale=0.65]{\string"Illustrazioni/5_5-1 Scrambler auto-sincronizzante ord 3\string".pdf}
\par\end{center}
\captionof{figure}{Scrambler auto-sincronizzante di ordine 3}\label{fig:scrambler-auto-sincronizzante-3}%
\end{minipage}

Uno scrambler come quello realizzato nell'esempio, avrà periodo massimo
7, nel caso in cui l'ingresso sia costituito da una sequenza si cifre
uguali.

Per effettuare l'operazione inversa dello scrambling, basta invertire
il senso delle frecce che escono da $\left\{ I_{k}\right\} $ e entrano
in $\left\{ U_{k}\right\} $ (grazie alle somme modulo 2, bisogna
solamente invertire la direzione di ingresso e uscita); inoltre non
è necessario conoscere il contenuto di $M_{1}$, $M_{2}$ e $M_{3}$,
tuttavia saranno necessari 3 passi iniziali per inizializzare lo stato
dello scrambler. In pratica sarà necessario conoscere unicamente il
polinomio $P\left(Y\right)$.

\subsection{Scrambler additivo}

~

\begin{minipage}[c]{0.5\textwidth}%
Il funzionamento di questo scrambler è simile al precedente, con la
differenza che l'ingresso viene spento (sostituito da zeri), e il
circuito LFSR genera una sequenza casuale $\left\{ R_{k}\right\} $
(come un generatore PRBS), che viene infine sommata all'ingresso per
generare l'uscita. In questo caso è necessario conoscere anche l'inizializzazione
delle celle $M_{i}$, oltre al polinomio $P\left(Y\right)$.

Lo scrambler additivo sopperisce a un difetto di quello auto-sincronizzante:
quest'ultimo infatti propaga gli errori; un bit sbagliato ricevuto
da uno scrambler auto-sincronizzante interrompe la sequenza, e sono
necessari $M$ passi per inizializzare nuovamente il registro a scorrimento.%
\end{minipage}%
\begin{minipage}[c]{0.6\textwidth}%
\begin{center}
\includegraphics[scale=0.7]{\string"Illustrazioni/5_5-2 Scrambler additivo ord M\string".pdf}
\par\end{center}
\captionof{figure}{Scrambler additivo di ordine $M$}\label{fig:registro-scorrimento-3-1-1}%
\end{minipage}

Per effettuare il \emph{descrambling} (operazione inversa dello scrambling),
si effettua di nuovo l'inversione delle frecce collegate all'ingresso
e all'uscita.\pagebreak{}
\begin{fact}
Tutti i dati trasmessi da un utente, prima di essere mappati nel canale
trasmissivo tramite un protocollo di livello 2 o 1, passano attraverso
un scrambler auto-sincronizzante con polinomio $P\left(Y\right)=Y^{43}+1$;
questa configurazione comporta una propagazione di eventuali errori,
tuttavia garantisce maggiore sicurezza, impedendo che un attaccante
manipoli l'uscita $\left\{ U_{k}\right\} $ dello scrambler (sarebbe
necessario conoscere lo stato del registro a scorrimento, è possibile
ottenerlo tramite $2^{43}$ tentativi \textemdash~circa $10^{12}$).\marginpar{In tutti i sistemi di comunicazione si disaccoppiano i dati trasmessi
dall'utente da quelli che circolano sul mezzo trasmissivo}[-2.5cm]
\end{fact}

\chapter{RSA}

\section{Introduzione}

Trattiamo l'algoritmo di cifratura a chiave pubblica Rivest-Shamir-Adleman
(RSA). La peculiarità degli algoritmi a chiave pubblica è la condivisione
di una chiave pubblica con chiunque voglia cifrare un messaggio, il
quale potrà essere decifrato solo dalla chiave privata, custodita
dal destinatario. La generazione della coppia di chia\-vi pubblica
e privata è realizzata mediante una funzione unidirezionale (si veda
\subsecref{Funzioni-di-hash}); in questo modo, si ricava la chiave
pubblica da quella privata. In questo modo chi entrerà in possesso
della chiave pubblica non sarà in grado di ricavarne la chiave privata.

Nel caso dell'RSA, la funzione unidirezionale è la seguente. Prendiamo
una coppia di primi $p$ e $q$ molto grandi, e scelti secondo un
criterio (mostrato più avanti); calcoliamo $n=p\cdot q$, e a questo
punto avremo un intero composto computazionalmente impossibile da
fattorizzare. Il prodotto dei due primi costituisce una funzione invertibile,
e se essi sono scelti correttamente è anche unidirezionale; il composto
$n$ sarà pubblico, e i primi $p,\,q$ saranno mantenuti segreti.

\section{Algoritmo}

Prendiamo un composto $n=p\cdot q$, costituito da due primi $p$
e $q$ scelti adeguatamente; prendiamo un intero $e$, che chiamiamo
esponente di cifratura, tale che $e\perp\varphi\left(n\right)$. Dato
che $n$ è costituito da due primi, vale $\varphi\left(n\right)=\left(p-1\right)\left(q-1\right)$.

Il messaggio in chiaro $m$ e quello cifrato $c$ sono entrambi elementi
di $\mathbb{Z}_{n}$; le funzioni di cifratura e decifratura sono
definite come:
\begin{equation}
\begin{array}{c}
\cgm c{p^{e}}n\\
\cgm m{c^{d}}n
\end{array}\label{eq:RSA-cifra-decifra}
\end{equation}
L'intero $d$, chiamato esponente di decifratura, è legato a $e$
nel modo seguente:
\[
\cgm{e\cdot d}1{\varphi\left(n\right)}\implies\boxed{\cgm d{e^{-1}}{\varphi\left(n\right)}}
\]
Dalla congruenza con 1 modulo $\varphi\left(n\right)$ e il prodotto
degli esponenti di cifratura, si deduce che:
\[
e\cdot d=1+k\cdot\varphi\left(n\right)
\]
A questo punto dalla funzione di decifratura (\ref{eq:RSA-cifra-decifra})
otteniamo:
\[
c^{d}=m^{e\cdot d}=m^{1+k\cdot\varphi\left(n\right)}\overset{*}{=}\boxed{m}\cdot1^{k}
\]
Nella relazione $*$ abbiamo usato (\ref{eq:Teorema-Eulero}); si
è voluto mostrare che esiste una corrispondenza univoca tra $m$ e
$c$, per l'ipotesi che $e\perp\varphi\left(n\right)$ (esiste un
solo $d$ che sia inverso di $e$ in modulo $\varphi\left(n\right)$,
e vice versa).

La \emph{chiave pubblica} è costituita da $n,\,e$ mentre la \emph{chiave
privata} è $d$, insieme a $p,\,q$ oppure a $\varphi\left(n\right)$.
\begin{example}
\emph{Siano dati due primi $p_{{\scriptscriptstyle \mathbb{S}}}=3,\,q_{{\scriptscriptstyle \mathbb{S}}}=11$
e un intero $e_{{\scriptscriptstyle \mathbb{P}}}=7$, cifrare tramite
RSA il messaggio $m=19$.}
\end{example}
$\checked$Calcoliamo\marginpar{All'interno di questo esempio, abbiamo usato i pedici ${\scriptscriptstyle \mathbb{P}}$
e ${\scriptscriptstyle \mathbb{S}}$ per indicare un elemento della
chiave pubblica o della chiave privata} il composto $n_{{\scriptscriptstyle \mathbb{P}}}=p\cdot q=33$; calcoliamo
inoltre $\varphi\left(n\right)_{{\scriptscriptstyle \mathbb{S}}}=\varphi\left(33\right)=\left(3-1\right)\left(11-1\right)=2\cdot10=20$.
A questo punto possiamo calcolare $d$:
\[
\begin{array}{c}
\cgm d{e^{-1}}{\varphi\left(n\right)}\\
\cgm d{e^{\varphi\left(\varphi\left(n\right)\right)-1}}{\varphi\left(n\right)}\\
\cgm d{7^{7}}{20}\\
\boxed{\cgm{d_{{\scriptscriptstyle \mathbb{S}}}}3{20}}
\end{array}
\]
Nella precedente relazione abbiamo usato (\ref{eq:Inverso-residuo-toziente}),
e abbiamo calcolato $\varphi\left(\varphi\left(n\right)\right)=\left(2^{2}-2\right)\left(5-1\right)=8$.

Cifriamo il messaggio $m=19$ applicando (\ref{eq:RSA-cifra-decifra}):
\[
c=\mod{19^{7}}{33}=13
\]
Si noti che possiamo riottenere $m=\mod{13^{3}}{33}=19$.\demo
\begin{rem}
Per effettuare la decifratura (operazione adibita alla chiave privata)
è necessario l'esponente $d$, il quale a sua volta viene calcolato
tramite $\varphi\left(n\right)$, che a sua volta deriva dai due primi
$p,\,q$. Ebbene, la conoscenza dei primi $p,\,q$ o del toziente
del loro prodotto $\varphi\left(n\right)$, compromette nello stesso
modo la sicurezza dell'algoritmo, e permette di calcolare $d$ (la
chiave privata).
\end{rem}
\begin{example}
\emph{Sia dato il composto $n=p\cdot q=11413$, prodotto di due primi,
e il suo toziente sia noto $\varphi\left(n\right)=$$\left(p-1\right)\left(q-1\right)=11200$.
Calcolare i due primi $p$ e $q$.}
\end{example}
$\checked$Analizziamo la relazione $n-\varphi\left(n\right)+1$,
con le seguenti riscritture:
\begin{align*}
n-\varphi\left(n\right)+1 & =p\cdot q-\left(p-1\right)\left(q-1\right)+1\\
214 & =p+q
\end{align*}
Con la conoscenza della somma dei primi cercati, possiamo risolvere
la seguente equazione:
\[
\begin{array}{c}
\left(x-p\right)\left(x-q\right)=0\\
x^{2}-\overset{n-\varphi\left(n\right)+1}{\overbrace{\left(p+q\right)}}x+\overset{n}{\overbrace{p\cdot q}}=0\\
x^{2}-214x+11413
\end{array}
\]
Otteniamo le seguenti soluzioni:\marginpar{Nella formula risolutiva deve valere $\Delta>0$, altrimenti $n$
e $\varphi\left(n\right)$ non sarebbero corretti}
\[
x=\frac{214\pm\sqrt{214^{2}-4\cdot11413}}{2}=\left\{ 101,\,113\right\} 
\]
Abbiamo ottenuto $p=101,\,q=113$. Avremmo ottenuto il risultato con
una bassa complessità computazionale (risolvere un'equazione di secondo
grado), anche nel caso di $p$ e $q$ molto grandi.\demo

\section{Sicurezza di RSA}

In teoria, l'RSA correttamente implementato è sicuro, fintanto che
la scomposizione in fattori primi molto grandi rimane un problema
difficile; tuttavia esistono delle insidie che influenzano la corretta
realizzazione, di cui parleremo in questa sezione.
\begin{thm}
Sia\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Debolezza sulle cifre dei primi in RSA}{\footnotesize{}\index{RSA, debolezza sulle cifre dei primi@{\footnotesize{}RSA, debolezza sulle cifre dei primi}}\label{thm:RSA-debolezza-sulle-cifre-primi}}}[-0.3cm] $m$ il numero di cifre di $n=p\cdot q$ ($m=\left\lceil \log_{10}\left(p\cdot q\right)\right\rceil $);
se si conoscono almeno le \uline{prime} o le \uline{ultime}
$m/4$ cifre di uno dei due primi $p$ o $q$, allora è possibile
fattorizzare in modo efficiente $n$.
\end{thm}
\begin{rem}
Se $n$ ha $m$ cifre, e $p$ e $q$ sono confrontabili, allora essi
avranno ciascuno $m/2$ cifre.
\end{rem}
Il Teorema \ref{thm:RSA-debolezza-sulle-cifre-primi} può essere sfruttato
se il metodo che il mittente utilizza per ricavare i primi $p$ e
$q$ è noto e predicibile: provando per tentativi le cifre dei primi
in un intorno di candidati, è possibile trovare le prime o le ultime
$m/4$ cifre di $p$ o $q$.
\begin{cor}
Consideriamo una chiave pubblica RSA costituita da $n,\,e$, sia $m$
il numero di cifre di $n$; se si conoscono almeno le ultime $m/4$
cifre di $d$ (esponente di decifratura, segreto) allora è possibile
fattorizzare in modo efficiente $d$.
\end{cor}
\begin{rem}
Dato che $\cgm d{e^{-1}}{\varphi\left(n\right)}$, esso avrà da 1
a $m$ cifre, per il limite imposto dal modulo di $\varphi\left(n\right)$
(il toziente avrà al più il numero di cifre di $n$).
\end{rem}
Abbiamo enunciato nelle sezioni precedenti che la scelta di $p$ e
$q$ deve essere fatta prendendo due primi grandi (nella pratica si
usano numeri di 150 cifre, ottenendo un $n$ di 300 cifre). per la
scelta dell'esponente di cifratura, bisogna evitare invece un $e$
troppo piccolo, il quale favorirebbe la velocità di cifratura ma sicuramente
causerebbe la comparsa di un $d$ molto grande. Nella scelta di $e$
bisogna anche tenere a mente l'ipotesi che esso sia $e\perp\varphi\left(n\right)$.

Un valore per l'esponente di cifratura comunemente usato e comprovato
è il seguente:
\[
e_{{\scriptscriptstyle \text{RSA}}}=2^{16}+10=65537
\]
Esso è un numero primo (è altamente improbabile che abbia fattori
in comune con $p-1$ o $q-1$, possiamo verificarlo con (\ref{eq:Algoritmo-Euclide-esteso}));
inoltre è facile calcolare il suo valore, tramite square and multiply
(si veda \secref{Square-=000026-multiply}).

Un altro approccio consiste nello scegliere un $d$ sufficientemente
robusto (50 cifre sono sufficienti), e a partire da esso si calcola
$e$ effettuando l'inverso in modulo $\varphi\left(n\right)$.

\section{Test di primalità}

Normalmente testare la primalità di un numero e fattorizzarlo sono
problemi differenti: è molto più semplice determinare che un numero
sia primo o meno. Vi sono per esempio numeri molto grandi di cui si
sa con certezza che sono composti, ma nessuno è stato in grado di
determinare i loro fattori.

\subsection{Test di Fermat}

Richiamiamo\marginpar{Si ricorda che è possibile testare che due interi siano primi relativi
($a\perp b$) tramite Euclide Esteso (\ref{eq:Algoritmo-Euclide-esteso})} il Teorema \ref{thm:Teorema-piccolo-Fermat}: $\cgm{a\perp p\land\,p\text{ primo}\implies a^{p-1}}1p$;
usando questo risultato, ci chiediamo se, preso un $n$ intero da
testare e un $a\perp n$ qualunque, valga
\begin{equation}
\cgm{a^{n-1}}1n\label{eq:Test-prim-Fermat}
\end{equation}
In caso di residuo esattamente 1, possiamo essere abbastanza sicuri
che $n$ sia un primo: lo chiameremo \emph{pseudo-primo di Fermat
rispetto alla base} $a$. Se il residuo della congruenza fosse diverso
da 1, potremo affermare che $n$ sia composto.
\begin{rem}
Gli interi primi diventano rarefatti tanto più si cercano con un valore
grande, quindi per $n\gg1$ la probabilità che uno pseudo-primo di
Fermat sia davvero un primo è elevata.
\end{rem}
\begin{example}
\emph{Applicare il test di Fermat all'intero} $n=341$.
\end{example}
$\checked$Scegliamo una base che sia prima relativa rispetto a $n$;
dato che 341 è dispari, prendiamo $a=2$. Applichiamo (\ref{eq:Test-prim-Fermat}):\marginpar{Gli pseudo-primi di Fermat rispetto alla base 2 sono detti anche \emph{numeri
di Poulet, Sarrus o Fermatians}}
\[
\mod{2^{340}}{341}=1
\]
Possiamo affermare che 341 sia uno pseudo-primo di Fermat rispetto
alla base 2; con un'analisi veloce tuttavia, otteniamo che $11\backslash341$
(infatti $341=11\cdot31$).

Ripetiamo il test per un'altra base, rispettando l'ipotesi che sia
prima relativa rispetto a $n$; scegliamo $a^{\prime}=3$, dal test
si ottiene:
\[
\mod{3^{340}}{341}=56\neq1
\]
Dato che il candidato al test $n$ non passa il test di Fermat per
qualunque base $a$, possiamo affermare che si tratta di un composto.
La condizione appena enunciata è rappresentata da:
\[
\exists a\in\mathbb{Z}\tc\ncgm{a^{n-1}}1n\implies n\text{ composto}
\]
\demo
\begin{example}
\emph{\label{exa:Esempio-pseudo-primo-assoluto}}Applicare il test
di Fermat all'intero $n=561$.

$\checked$Prendiamo la base $a=2$, e applichiamo il test:
\[
\mod{2^{560}}{561}=1
\]
Possiamo quindi affermare che 561 è uno pseudo-primo di Fermat rispetto
alla base 2; proviamo a usare un'altra base $a=3$, in tal caso il
test vale:
\[
\mod{3^{560}}{561}=375
\]
Da quest'ultimo risultato deduciamo che 561 è composto; tuttavia quello
che abbiamo appena effettuato \uline{non} era un test di Fermat!
Infatti 3 è un fattore di 561 ($561=3\cdot11\cdot17$); inoltre l'intero
561 appare pseudo-primo per tutte le basi, ad eccezione dei suoi fattori.\demo
\end{example}
\begin{defn}
\label{def:pseudoprimo-assoluto-Carmichael}Un\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Numeri di Carmichael}{\footnotesize{}\index{Carmichael, numeri di@{\footnotesize{}Carmichael, numeri di}}}}[-0.2cm] intero pseudo-primo di Fermat rispetto ad ogni base, ad
eccezione di quelle che sono i suoi fattori, è chiamato \emph{pseudo-primo
assoluto}, oppure \emph{numero di Carmichael}.
\end{defn}
\begin{rem}
La distribuzione dei primi di Carmichael è estremamente rarefatta:
il promo elemento è proprio 561, il secondo è 41041, ecc$\ldots$
Il numero $\mathcal{C}\left(x\right)$ dei primi di Carmichael da
0 a $x$ è limitato superiormente nel modo seguente:
\begin{equation}
\mathcal{C}\left(x\right)<x\cdot e^{\frac{-k\cdot\ln\left(x\right)\cdot\ln\left(\ln\left(\ln x\right)\right)}{\ln\left(\ln\left(x\right)\right)}}\label{eq:Quantit=0000E0-nuemri-Carmichael}
\end{equation}
\end{rem}
%
\begin{rem}
Non esistono pseudo-primi che siano forti e assoluti; tuttavia, sia
$\mathbb{B}$ un insieme finito di basi, $b$ un suo elemento, e $\#_{\text{F}}\left(b\right)$
il numero di pseudo-primi forti rispetto a una base $b$, allora
\[
\forall b\in\mathbb{B}\tc\#_{\text{F}}\left(b\right)=\infty
\]
\end{rem}

\subsection{Test del principio fondamentale}

Richiamiamo il principio fondamentale (\ref{eq:Principio-fondamentale});
possiamo usare questo risultato per dedurre:
\begin{equation}
\exists a,\,b\in\mathbb{Z}\tc\cgm{a^{2}}{b^{2}}n\land\ncgm a{\pm b}n\implies n\text{ composto}\label{eq:Test-prim-principio-fondamentale}
\end{equation}
Il test (\ref{eq:Test-prim-principio-fondamentale}) ci fornisce anche
la seguente informazione: il massimo comune divisore tra $a-b$ e
$n$ è un fattore non banale di $n$ (diverso da 1 e da $n$), ovvero
vale:
\[
\mcd{a-b}n\neq\left\{ 1,\,\text{n}\right\} 
\]
Tramite la conoscenza di un fattore non banale, si può scomporre $n$
e ridurre il problema alla fattorizzazione di un intero più piccolo.

\subsection{Test di Miller-Rabin\label{subsec:Test-di-Miller-Rabin}}

Dato un candidato $n$ da testare, esso viene prima testato con Fermat
(\ref{eq:Test-prim-Fermat}); se $n$ si rivela uno pseudo-primo di
Fermat, viene sottoposto al test del principio fondamentale (\ref{eq:Test-prim-principio-fondamentale});
gli interi che passano anche il secondo test sono chiamati \emph{pseudo-primi
forti} (non sono sicuramente dei primi, ma lo sono con alta probabilità).
Gli interi che non passano il test di Miller-Rabin sono sicuramente
composti.

Se prendiamo il candidato $n=561$ dell'Esempio \ref{exa:Esempio-pseudo-primo-assoluto},
esso non passa il test di Miller-Rabin, quindi è uno pseudo-primo
assoluto ma non uno pseudo-primo forte.

\subsection{Densità dei primi}

Vogliamo trovare un intero primo che abbia 100 cifre; la densità dei
numeri primi intorno a $10^{100}$ può essere calcolata usando la
quantità di primi dal Teorema \ref{thm:Numeri-primi}:
\[
\frac{\text{\# primi}}{\text{\# interi}}=\frac{\pi\left(10^{100}\right)}{10^{100}}=\frac{1}{\ln\left(10^{100}\right)}=\frac{1}{100\cdot\ln\left(10\right)}\simeq\frac{1}{230}
\]
Possiamo scrivere in generale, chiamando $\delta\left(x\right)$ la
densità di primi intorno a $x$:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Densità di interi primi}{\footnotesize{}\index{Densità di interi primi@{\footnotesize{}Densità di interi primi}}}}[0.4cm]
\begin{equation}
\delta\left(x\right)=\frac{1}{\ln\left(x\right)}\label{eq:Densit=0000E0-interi-primi}
\end{equation}
La densità calcolata attorno a $10^{100}$ si traduce nella seguente
osservazione: prendendo a caso un intero di 10 cifre, la probabilità
che sia primo è circa $1/230$.

\section{Fattorizzazione}

Consideriamo un numero $n$ che sappiamo essere composto (possiamo
prendere un intero che non abbia passato il test di Miller-Rabin §\ref{subsec:Test-di-Miller-Rabin});
possiamo adottare dei metodi algoritmici per trovare i suoi fattori
primi, se $n$ soddisfa certe condizioni, da evitare nella scelta
dei primi per RSA.

\subsection{Metodo di fattorizzazione di Fermat}

Proviamo ad esprimere il numero che sappiamo essere composto, come
differenza di due quadrati; otteniamo:
\[
n=x^{2}-y^{2}=\bigl(\overset{p}{\overbrace{x+y}}\bigr)\bigl(\overset{q}{\overbrace{x-y}}\bigr)
\]
Costruiamo la sequenza $\left\{ x^{2}\right\} $ seguente, e ci fermiamo
quando $n+y^{2}$ è un quadrato perfetto:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Fattorizzazione di Fermat}{\footnotesize{}\index{Fermat, fattorizzazione@{\footnotesize{}Fermat, fattorizzazione}}}}[0.2cm]
\begin{equation}
\left\{ x^{2}\right\} =\left\{ y\in\left[0,\,\infty\right)\tc n+y^{2}=x^{2}\right\} \label{eq:Successione-fattorizzazione-Fermat}
\end{equation}
Una volta trovato un quadrato perfetto, siamo anche a conoscenza della
$x$ e della $y$, con le quali possiamo calcolare i fattori di $n$:
$p=\left(x+y\right)$ e $q=\left(x-y\right)$.

L'efficienza computazionale di questo metodo dipende da quanto siano
vicini i fattori di $n$; infatti se $n=p\cdot q$ e $p\sim q$, allora
avremo un $y$ piccolo che permetterà di arrivare velocemente alla
soluzione.
\begin{example}
\emph{Fattorizzare l'intero $n=295927$ col metodo di Fermat.}
\end{example}
$\checked$Costruiamo la successione (\ref{eq:Successione-fattorizzazione-Fermat}):
\begin{align*}
295927+1 & \neq x^{2}\\
295927+4 & \neq x^{2}\\
295927+9 & =544^{2}
\end{align*}
Possiamo affermare che $x=544$, $y=3$ e vale $n=\left(544+3\right)\left(544-3\right)$.
Si noti che i fattori ottenuti \uline{non} sono necessariamente
primi.\demo

\subsection{Algoritmo di Pollard $\boldsymbol{\left(p-1\right)}$}

Consideriamo un primo $p$, in tal caso $p-1$ sarà pari, quindi composto:
\[
p-1=2\cdot\prod_{i=1}^{i=\ldots}q_{i}
\]
Possiamo sfruttare questa osservazione solo quando i fattori $q_{i}$
sono piccoli: se abbiamo almeno un fattore $q_{i}$ grande, l'algoritmo
di Pollard non semplifica il problema della fattorizzazione.

Dato un intero $n$ da fattorizzare, si scelga una base $a>1$, poi
si sviluppi la successione $\left\{ b_{j}\right\} $ come:
\[
\begin{array}{c}
\cgm{b_{1}}an\\
\cgm{b_{2}}{b_{1}^{2}}n\\
\cgm{b_{3}}{b_{2}^{3}}n\\
\vdots
\end{array}
\]
Formalizziamo la successione con le seguenti scritture:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Algoritmo di Pollard}{\footnotesize{}\index{Pollard, algoritmo di@{\footnotesize{}Pollard, algoritmo di}}}}[0.2cm]
\begin{equation}
\cgm{b_{j}}{b_{j-1}^{j}}n,\quad d_{j}=\mcd{b_{j}-1}n\label{eq:Successione-fattorizzazione-Pollard}
\end{equation}
Continuiamo per ogni $j$ fino a che $d_{j}\neq1$; in tal caso $d_{j}$
è un fattore non banale di $n$, e l'algoritmo termina.
\begin{example}
\emph{Fattorizzare l'intero $n=11413$ con l'algoritmo di Pollard.}
\end{example}
$\checked$Scegliamo la base $a=2$, e costruiamo la successione (\ref{eq:Successione-fattorizzazione-Pollard}):
\[
\begin{array}{ll}
\cgm{b_{1}}2{11413}, & d_{1}=\mcd 1{11413}=1\\
\cgm{b_{2}}{2^{2}}{11413}, & d_{2}=\mcd 3{11413}=1\\
\cgm{b_{3}}{4^{3}}{11413}, & d_{3}=\mcd{63}{11413}=1\\
\cgm{b_{4}}{64^{4}}{11413}, & d_{4}=\mcd{105}{11413}=1\\
\cgm{b_{5}}{106^{5}}{11413}, & d_{5}=\mcd{-309}{11413}=1\\
\cgm{b_{6}}{-309^{6}}{11413}, & d_{6}=\mcd{9992}{11413}=1\\
\cgm{b_{7}}{9993^{7}}{11413}, & d_{7}=\mcd{5085}{11413}=1\\
\cgm{b_{8}}{5086^{8}}{11413}, & d_{8}=\mcd{-1017}{11413}=1\\
\cgm{b_{9}}{-1016^{9}}{11413}, & d_{9}=\mcd{5537}{11413}=\boxed{113}
\end{array}
\]
Otteniamo che un fattore non banale di $n$ è proprio $p=d_{9}=113$,
mentre il secondo fattore di $q=n/p=101$.\demo

\chapter{Firma digitale}

\section{Logaritmo discreto}

\subsection{Definizione}

Consideriamo la congruenza seguente:
\begin{equation}
\cgm{\beta}{\alpha^{x}}p\label{eq:Equazione-congruenziale-log-discreto}
\end{equation}
dove $p$ è un primo e $\alpha,\,\beta\in\mathbb{Z}_{p}^{*}$; essa
è una equazione congruenziale nell'incognita $x$, a cui dovremo assegnare
il valore a cui elevare $\alpha$ per ottenere $\beta$.

Dunque, abbiamo un problema analogo a quello del logaritmo; osserviamo
inoltre che l'equazione (\ref{eq:Equazione-congruenziale-log-discreto})
ha sempre soluzione se la base $\alpha$ è radice primitiva di $\mathbb{Z}_{p}^{*}$,
infatti in tal caso si ha $\ord{\alpha}=p-1$, quindi elevando $\alpha$
a tutti gli interi da 1 a $p-1$ si ottengono tutti gli elementi di
$\mathbb{Z}_{p}^{*}$; dal momento che anche $\beta$ è contenuto
in $\mathbb{Z}_{p}^{*}$, sarà certo produrre $\beta$ da una alle
potenze di $\alpha$.

Chiamiamo \emph{logaritmo discreto} questo problema, e lo indichiamo
come:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Logaritmo discreto}{\footnotesize{}\index{Logaritmo discreto@{\footnotesize{}Logaritmo discreto}}}}[0cm]
\begin{equation}
x=\logd{\alpha}{\beta}\label{eq:Logaritmo-discreto}
\end{equation}
Risolvendo un logaritmo discreto, si ottengono infinite soluzioni
\textemdash~una classe di congruenze del tipo $\cgm x{\logd{\alpha}{\beta}}{\ord{\alpha}}$;
il logaritmo discreto gode delle stesse proprietà dei logaritmi.
\begin{example}
\emph{Calcolare la soluzione del logaritmo discreto in base $\alpha=2$
di $\beta=9$, nell'insieme dei residui modulo $p=11$.}
\end{example}
$\checked$Le soluzioni apparterranno alla classe di congruenze:
\[
\cgm x{\logd 29}{11}
\]
In questo caso, essendo 10 le possibili soluzioni, possiamo effettuare
una esplorazione esaustiva dello spazio delle radici; provando ad
elevare 2 a tutti gli interi da 1 a 10 si ottiene:
\[
\cgm x6{11}
\]

Possiamo porci nello stesso caso, considerando $\alpha=3$; il problema
sarà allora:
\[
\cgm{3^{x}}9{11}\implies\cgm x{\logd 39}{11}
\]
Effettuando di nuovo un'analisi esaustiva dello spazio delle radici
otteniamo che:
\[
\cgm x25
\]
Notiamo che la classe di residui non è in modulo 11 questa volta,
poiché 3 non è una radice primitiva in $\mathbb{Z}_{11}^{*}$.\demo
\begin{rem}
In generale non abbiamo un algoritmo efficiente che risolva il logaritmo
discreto per un primo $p$ arbitrario. Quindi la funzione logaritmo
discreto non è unidirezionale; infatti, dato $\beta$, non si riesce
a calcolare $x$ in modo semplice. Questo rende il logaritmo discreto
una funzione adatta a essere usata in un cifrario a chiave pubblica.
\end{rem}

\subsection{Parità del logaritmo discreto}

Possiamo ottenere se la soluzione di un logaritmo discreto sia pari
o meno: consideriamo il primo $p$, gli interi $\alpha,\,\beta\in\mathbb{Z}_{p}^{*}$
e l'intero $x\in\left[0,\,p-1\right]$, tali che:
\[
\cgm{\beta}{\alpha^{x}}p
\]
Vogliamo trovare il valore di $x$.

Notiamo che, con la seguente riscrittura, se $\alpha$ è radice primitiva
in $\mathbb{Z}_{p}^{*}$ (implicazione $\star$), otteniamo una congruenza
a 1:
\[
\cgm{\left(\alpha^{\frac{p-1}{2}}\right)^{2}\equiv\alpha^{p-1}}1p\overset{\star}{\implies}\cgm{\alpha^{\frac{p-1}{2}}}{\pm1}p
\]
Dato che $p-1$ è l'esponente minore che verifica la congruenza a
$+1$, consideriamo nella precedente solo ``$\cgm{}{-1}p$''.

Elevando entrambi i membri della prima congruenza a $\left(p-1\right)/2$
si ottiene:
\[
\cgm{\beta^{\frac{p-1}{2}}\equiv\alpha^{\frac{p-1}{2}\cdot x}}{\left(-1\right)^{x}}p
\]
Nella precedente, se abbiamo $\cgm{\beta^{\left(p-1\right)/2}}{+1}p$
allora $x$ è pari, altrimenti sarà dispari.

\subsection{Algoritmo di Pohlig-Hellman}

Osserviamo che $p-1$ sarà pari, dato un primo $p$: allora $p-1$
dovrà essere un composto. Scriviamolo come:
\[
p-1=2\cdot\prod_{i=1}^{h}p_{i}^{r_{i}}
\]
Dato che la soluzione del logaritmo discreto è della forma $\cgm x{\logd{\alpha}{\beta}}{\left(p-1\right)}$,
possiamo scomporre il problema col Teorema \ref{thm:Teorema-cinese-del-resto}
in $h$ pezzi diversi, ognuno in modulo $p_{i}^{r_{i}}$.

Questi problemi sono più facili da risolvere perché più piccoli; se
tuttavia è presente un fattore $p_{i}^{r_{i}}$ molto grande, allora
non vi è riduzione della complessità; concludiamo che la difficoltà
del problema del logaritmo discreto modulo $p-1$ dipende strettamente
dalla grandezza del fattore più grande di $p-1$.

\subsection{Algoritmo baby step, giant step\label{subsec:Baby-step-giant-step}}

Consideriamo le ipotesi per il pro\-blema descritto dall'equazione
(\ref{eq:Equazione-congruenziale-log-discreto}), e scegliamo un intero
$N\tc N^{2}\geq p-1$; segue che:
\[
N=\left\lfloor \sqrt{p-1}\right\rfloor +1
\]
Costruiamo ora due successioni $\left\{ \alpha^{j}\right\} $ e $\left\{ \beta\cdot\alpha^{-N\cdot k}\right\} $
tali che $0\leq j<N$ e $0\leq k<N$>; le successioni così fatte saranno
sviluppate come:
\[
\begin{array}{ccccc}
\boldsymbol{j} & \boldsymbol{\alpha^{i}} & \boldsymbol{} & \boldsymbol{k} & \boldsymbol{\beta\cdot\alpha^{-N\cdot k}}\\
0 & 1 &  & 0 & \beta\\
1 & \alpha &  & 1 & \beta\cdot\alpha^{-N}\\
2 & \alpha^{2} &  & 2 & \beta\cdot\alpha-2N\\
\vdots & \vdots &  & \vdots & \vdots
\end{array}
\]
Tutti i termini delle successioni $\alpha$ e $\beta$ sono in modulo
$p$; inoltre, una volta sviluppata la successione $\alpha$, cerchiamo
la prima corrispondenza con uno dei termini della successione $\beta$.
Una corrispondenza tra le due successioni vuol dire aver trovato dei
valori per $j$ e $k$ che verificano:
\[
\cgm{\alpha^{j}}{\beta\cdot\alpha^{-N\cdot k}}p\implies\cgm{\alpha^{j+N\cdot k}}{\beta}p
\]
Per il principio fondamentale, dalla precedente possiamo scrivere
la congruenza degli esponenti modulo $p-1$, trovando la risposta
al problema del logaritmo discreto (a quale esponente elevare $\alpha$
per ottenere $\beta$):
\[
\cgm x{j+N\cdot k}{\left(p-1\right)}
\]

\begin{rem}
Con questo algoritmo esprimiamo il valore del logaritmo discreto in
base $N$; la complessità computazionale è proporzionale a $\sqrt{p}$,
rispetto all'analisi esaustiva delle soluzioni del logaritmo discreto,
che può essere condotta con $p-1$ elevamenti a potenza. Infatti dovremo
certamente sviluppare la successione di $\alpha$ fino a $j=N-1$,
e nel peggiore dei casi anche la successione di $\beta$ fino a $k=N-1$.
\end{rem}

\section{Pattuizione della chiave Diffie-Hellman\label{sec:Pattuizione-chiave-Diffie-Hellman}}

Il metodo Diffie-Hellman permette di scambiare una chiave simmetrica
attraverso un canale non sicuro, sfruttando la complessità del problema
del logaritmo discreto. Consideriamo un mittente $\mathbf{A}$ e un
destinatario $\mathbf{B}$; ipotizziamo che un attaccante $\mathbf{O}$
possa osservare tutto il traffico che transita sul canale tra $\mathbf{A}$
e $\mathbf{B}$; nel seguente elenco sono indicati i messaggi scambiati
tra $\mathbf{A}$ e $\mathbf{B}$:
\begin{enumerate}
\item $\mathbf{A}\leftrightarrows\mathbf{B}$: mittente e destinatario concordano
un primo $p$ e una radice primitiva $\alpha\in\mathbb{Z}_{p}^{*}$
(sia $\alpha$ che $p$ sono pubblici);
\item $\mathbf{A}\rightarrow\mathbf{B}$: $\mathbf{A}$ sceglie a caso un
intero $x\in\left[1,\,p-2\right]$, e invia a $\mathbf{B}$ $\mod{\alpha^{x}}p$;
\item $\mathbf{A}\leftarrow\mathbf{B}$: $\mathbf{B}$ sceglie a caso un
intero $y\in\left[1,\,p-2\right]$, e invia ad $\mathbf{A}$ $\mod{\alpha^{y}}p$;
\item $K_{\mathbf{A}\rightarrow\mathbf{B}}$: la chiave che $\mathbf{A}$
usa per scrivere a $\mathbf{B}$ è costruita come $\mod{\left(\alpha^{y}\right)^{x}}p$;
\item $K_{\mathbf{A}\leftarrow\mathbf{B}}$: la chiave che $\mathbf{B}$
usa per rispondere ad $\mathbf{A}$ è costruita come $\mod{\left(\alpha^{x}\right)^{y}}p$.
\end{enumerate}
Si verifica facilmente che le chiavi generate con questo algoritmo
sono uguali:
\[
\cgm{K_{\mathbf{A}\rightarrow\mathbf{B}}\equiv K_{\mathbf{A}\leftarrow\mathbf{B}}}{\alpha^{x\cdot y}}p
\]
Consideriamo il punto di vista di un attaccante $\mathbf{O}$ che
osserva il traffico sul canale: egli non potrà ricavare $x$ e $y$
a meno che non risolva il problema del logaritmo discreto; è quindi
necessario concordare un primo $p$ che renda intrattabile il problema
del logaritmo discreto in $\mathbb{Z}_{p}^{*}$.
\begin{problem}
\noun{\label{prob:Problema-computazionale-Diffie-Hellman}{Problema computazionale di Diffie-Hellman}.}
Dati $\alpha^{x}$ e $\alpha^{y}$, entrambi residui modulo $p$,
calcolare $\mod{\alpha^{x\cdot y}}p$ non è più difficile di calcolare
il logaritmo discreto $\logd{x\cdot y}{\alpha}$. Risolvere il logaritmo
discreto è quindi condizione sufficiente per il problema computazionale
di Diffie-Hellman.
\end{problem}
%
\begin{problem}
\noun{\label{prob:Problema-decisionale-Diffie-Hellman}{Problema decisionale di Diffie-Hellman}.
}Dati $\alpha^{x}$, $\alpha^{y}$ e un intero $c$, tutti residui
modulo $p$, determinare se si verifica $\cgm c{\alpha^{x\cdot y}}p$.
Risolvere il problema computazionale permette di risolvere anche quello
decisionale, tuttavia non è vero il contrario: non sappiamo se risolvere
il problema decisionale possa ridurre a priori la complessità di quello
computazionale.
\end{problem}

\section{Crittosistema a chiave pubblica El Gamal}

Consideriamo un mittente $\mathbf{A}$ e un destinatario $\mathbf{B}$;
ipotizziamo che un attaccante $\mathbf{O}$ possa osservare tutto
il traffico che transita sul canale tra $\mathbf{A}$ e $\mathbf{B}$,
e il messaggio $m$ che $\mathbf{A}$ desidera inviare a $\mathbf{B}$:
\begin{enumerate}
\item $\mathbf{B}$: sceglie un primo $p$ tale che il problema del logaritmo
discreto in $\mathbb{Z}_{p}^{*}$ sia intrattabile e una radice primitiva
$\alpha$ in tale insieme (pubblici); inoltre sceglie un intero $a\in\left[1,\,p-2\right]$
(segreto); infine, egli computa $\cgm{\beta}{\alpha^{a}}p$;
\item $\mathbf{A}\leftarrow\mathbf{B}$: $\mathbf{B}$ invia ad $\mathbf{A}$
la propria chiave pubblica, costituita da $\left(\alpha,\,\beta,\,p\right)$;
\item $\mathbf{A}$: sceglie un intero $k\in\left[1,\,p-2\right]$, e calcola:
\[
\cgm r{\alpha^{k}}p,\quad\cgm t{\beta^{k}\cdot m}p
\]
\item $\mathbf{A}\rightarrow\mathbf{B}$: $\mathbf{A}$ invia il messaggio
cifrato costituito da $\left(r,\,t\right)$ a $\mathbf{B}$;
\item $\mathbf{B}$: decifra il messaggio ricevuto computando $\mod{t\cdot r^{-a}}p$:
\[
\cgm{t\cdot r^{-a}\equiv\left(\beta^{k}\cdot m\right)\left(\alpha^{k}\right)^{-a}\equiv\left(\cancel{\alpha^{a\cdot k}}\cdot m\right)\left(\cancel{\alpha^{a\cdot k}}\right)}{\boxed{m}}p.
\]
\end{enumerate}
\begin{rem}
Mentre $a$ rimane il segreto di $\mathbf{B}$ fin dall'inizio della
comunicazione, il segreto $k$ di $\mathbf{A}$ invece è casuale ed
è bene che sia usato una sola volta; esso è un segreto effimero chiamato
\emph{nonce} (dalla crasi di number e once, un numero da usare una
sola volta).
\end{rem}
%
\begin{rem}
Notiamo che il messaggio in chiaro $m$ appartiene a $\mathbb{Z}_{p}^{*}$,
tuttavia il messaggio cifrato è dato dalla coppia di numeri $\left(r,\,t\right)\in\mathbb{Z}_{p}^{*}\times\mathbb{Z}_{p}^{*}$.
\end{rem}
%
\begin{rem}
Possiamo calcolare $r^{-a}$ sia passando per l'inverso di $r$ elevato
ad $a$, sia considerando che $\cgm{r^{-a}}{r^{p-1-a}}p$, per il
Teorema \ref{thm:Teorema-piccolo-Fermat}.
\end{rem}
Ipotizziamo di utilizzare lo stesso nonce due volte; chiamiamo $m_{i}$
il testo in chiaro, $c_{i}$ il messaggio cifrato, e $m_{1}\neq m_{2}$,
allora dalla cifratura si ottiene:
\[
E\left(m_{1}\right)=c_{1}\left(r,\,t_{1}\right),\quad E\left(m_{2}\right)=c_{2}\left(r,\,t_{2}\right)
\]
I due interi $r$ per i messaggi cifrati coincidono, e questo permette
all'attaccante (se egli possiede anche un testo in chiaro noto, per
esempio $m_{1}$ associato a $c_{1}$) di provare a computare:
\[
\cgm{\frac{t_{1}}{m_{1}}}{\frac{t_{2}}{m_{2}}}p\implies\cgm{m_{2}}{\frac{t_{2}}{t_{1}}\cdot m_{1}}p
\]
Dalla precedente congruenza è possibile ricavare tutti i messaggi
successivi alla ripetizione di un nonce, sfruttando la relazione di
proporzionalità mostrata.
\begin{rem}
Se avessimo un dispositivo che risolve il Problema \ref{prob:Problema-computazionale-Diffie-Hellman},
potremmo usarlo per decifrare i messaggi cifrati tramite il crittosistema
di El Gamal; se avessimo un dispositivo che risolve il Problema \ref{prob:Problema-decisionale-Diffie-Hellman},
potremmo usarlo per decidere se un messaggio cifrato $\left(r,\,t\right)$
sia compatibile con un messaggio in chiaro $m$ (permette di attuare
l'attacco del testo in chiaro noto), non ostante il segreto effimero
$k$. Questa è la differenza con l'RSA nel quale, dato un messaggio
cifrato e uno in chiaro, è possibile verificare direttamente la loro
corrispondenza.
\end{rem}

\section{Funzioni di Hash}

\subsection{Definizione e proprietà}

Una \marginpar{Le funzioni di hash sono state introdotte nella sottosezione §\ref{subsec:Funzioni-di-hash}}[0.5cm]funzione
di hash è una funzione matematica che prende in ingresso un messaggio
di lunghezza arbitraria, e produce una uscita (di solito corta) di
lunghezza prefissata.

La funzione matematica selezionata deve:
\begin{itemize}
\item essere veloce da calcolare;
\item avere uscita pseudo-casuale (deve godere delle proprietà descritte
dalla Proposizione \ref{prop:Propriet=0000E0-fondamentali-cifrari-Shannon});
\item essere non-invertibile (non c'è corrispondenza univoca tra ingresso
e uscita, risulta non-invertibile per definizione);
\item essere\marginpar{La proprietà di unidirezionalità è anche detta \emph{resistenza alla
contro-immagine}} unidirezionale (non deve essere possibile trovare nemmeno una uscita
delle infinite che producono un certo ingresso);
\item non esista una coppia di messaggi differenti $m_{1}\neq m_{1}$, tali
che i loro hash siano uguali, ovvero (detta $h\left(m\right)$ la
funzione di hash del messaggio $m$)
\[
\forall\left(m_{1},\,m_{2}\right)\tc m_{1}\neq m_{2}\implies h\left(m_{1}\right)\neq h\left(m_{2}\right)
\]
se questo si verifica, diremo che la funzione $h\left(\right)$ è
\emph{fortemente resistente alle collisioni};
\item dato un messaggio $m$, sia impossibile trovare un messaggio diverso
$m^{\prime}\neq m$ per il quale gli hash dei due messaggi siano uguali,
ovvero
\[
\forall m\,\nexists m^{\prime}\tc m^{\prime}\neq m\implies h\left(m\right)=h\left(m^{\prime}\right)
\]
se questo si verifica, diremo che la funzione $h\left(\right)$ è
\emph{debolmente resistente alle collisioni}.
\end{itemize}
Ottenere la resistenza debole alle collisioni è più difficile: infatti
essa fornisce un grado di libertà in meno rispetto alla resistenza
forte (uno dei due messaggi viene fissato).
\begin{example}
\emph{Determinare se le seguenti funzioni siano invertibili, unidirezionali
e prive di collisioni:}
\end{example}
\begin{enumerate}
\item $h\left(x\right)=\mod xn$ con $n$ intero composto qualunque;
\item $h\left(x\right)=\mod{\alpha^{x}}p$ con $\alpha$ radice primitiva
di $\mathbb{Z}_{p}$;
\item $h\left(x\right)=\mod{x^{2}}n$ con $n=p\cdot q$ prodotto di due
primi;
\item $h\left(x\right)={\scriptstyle \text{DES}}_{x}\left(000\ldots\right)$
con chiave $x\in\left[0,\,2^{56}\right]$.
\end{enumerate}
$\checked$Analizziamo una alla volta le quattro funzioni, nelle sottosezioni
seguenti.

\subsubsection*{Funzione $\left(1\right)$}

Questa funzione non è invertibile, poiché esistono infiniti messaggi
che producono la stessa uscita della funzione ($\forall k\tc h\left(x\right)=\mod{\left(x+k\cdot n\right)}n$);
per quanto appena osservato, tale funzione non è unidirezionale, poiché
è possibile trovare uno qualunque di quegli infiniti messaggi che
producono la stessa uscita (basta trovare un $x+k\cdot n$). Per lo
stesso motivo, è possibile trovare una collisione (per esempio $h\left(x\right)=h\left(x+n\right)$).

\subsubsection*{Funzione $\left(2\right)$}

Questa funzione non è invertibile, poiché esistono infiniti numeri
nella classe di congruenza $\cgm k{\overline{x}}{\left(p-1\right)}$
che danno resto $k$; l'inverso di questa funzione ricade nel problema
del logaritmo discreto (\ref{eq:Logaritmo-discreto}): con un $p$
scelto in modo opportuno, la funzione risulta unidirezionale.

Possiamo ottenere una collisione prendendo $x_{1}$ e $x_{2}=x_{1}+k\left(p-1\right)$,
da cui si ottiene la stessa uscita ($h\left(x_{1}\right)=h\left(x_{2}\right)$).

\subsubsection*{Funzione $\left(3\right)$}

Questa funzione non è invertibile, poiché esistono infiniti valori
di $x$ per cui la congruenza in modulo $n$ possa essere soddisfatta;
presi $p$ e $q$ tali da rendere computazionalmente intrattabile
la fattorizzazione di $n$, questa funzione risulta unidirezionale.

Possiamo ottenere una collisione usando il fatto che un quadrato abbia
due radici opposte: $h\left(x\right)=h\left(-x\right)$.

\subsubsection*{Funzione $\left(4\right)$}

Cifriamo un blocco di 64 zeri col DES, usando il messaggio come chiave
di 56bit. Dato che il messaggio usato come chiave è da 56bit, e l'uscita
è un blocco da 64bit, la funzione non è invertibile; grazie alle proprietà
del DES la funzione risulta unidirezionale (non è possibile ottenere
la chiave $x$ che produca un'uscita $h\left(x\right)$ desiderata),
infatti DES resiste all'attacco del testo in chiaro noto.

Per quanto appena affermato, non è possibile trovare collisioni (equivale
a trovare due chiavi che cifrano nello stesso modo lo stesso blocco).

Osserviamo che non possiamo usare questa funzione come una funzione
di hash: infatti essa non rispetta la proprietà sulla lunghezza arbitraria
dell'ingresso, che è limitato a un massimo di 56bit.\demo

\subsection{Algoritmo SHA}

Si tratta di una famiglia di algoritmi classificati, in base alla
lunghezza dell'uscita, la lunghezza dei blocchi e il numero di round,
in SHA-0 (160bit), SHA-1 (160bit), SHA-2 (256bit), SHA-3 (512bit,
standard approvato dal NIST). Il loro funzionamento può essere schematizzato
nel modo seguente; sia dato un messaggio $m$, di cui si vuole calcolare
l'hash:

\textbf{\noun{Inizializzazione}}
\begin{itemize}
\item concatena al messaggio $m$ dei bit di ``padding'', in modo che
la sua lunghezza $\ell$ sia un multiplo di 512;
\item concatena al messaggio $m$ la sua lunghezza $\ell$, sotto forma
di intero senza segno a 64bit (questo pone un limite intrinseco alla
lunghezza dell'ingresso);
\item inizializza 5 registri $H_{0},\,\ldots,\,H_{4}$ con dei valori costanti
(sono parte della specifica dell'algoritmo).
\end{itemize}
\textbf{\noun{Esecuzione}}
\begin{enumerate}
\item dividiamo il messaggio $m$ in blocchi da 512bit chiamati $M_{i}$;
\item dividiamo ciascun blocco $M_{i}$ in 16 blocchi da 32bit, che chiamiamo
$W_{i,j}$;
\item per $j$ da 16 a 79:\marginpar{La funzione $f_{j}\left(\right)$ e il valore $K_{j}$ sono specifici
dell'algoritmo SHA-1; la funzione $B\protect\hookleftarrow r$ fa
scorrere in modo ciclico i bit di $B$ a sinistra di $r$ posizioni}
\begin{enumerate}
\item $W_{i,j}=\left(W_{i,j-3}\oplus W_{i,j-8}\oplus W_{i,j-14}\oplus W_{i,j-16}\right)\hookleftarrow1$;
\end{enumerate}
\item assegniamo $A=H_{0},\,B=H_{1},\,C=H_{2},\,D=H_{3},\,E=H_{4}$;
\item per $j$ da 0 a 79:
\begin{enumerate}
\item $T=\left(A\hookleftarrow5\right)+f_{j}\left(B,\,C,\,D\right)+E+W_{j}+K_{j}$;
\item $E=D$;
\item $D=C$;
\item $C=\left(B\hookleftarrow30\right)$;
\item $B=A$;
\item $A=T$;
\end{enumerate}
\item assegniamo $H_{0}=H_{0}+A,\,H_{1}=H_{1}+B,\,H_{2}=H_{2}+C,\,H_{3}=H_{3}+D,\,H_{4}=H_{4}+E$;
\item il risultato dell'algoritmo è la stringa $H_{0}\parallel H_{1}\parallel H_{2}\parallel H_{3}\parallel H_{4}$,
il valore a 160bit dell'hash.
\end{enumerate}

\subsection{Paradosso del compleanno}

Consideriamo una coppia di persone: la probabilità che esse \uline{non}
abbiano il compleanno nello stesso giorno è pari a $\frac{364}{365}\simeq99.7\%$
(stiamo escludendo gli anni bisestili). Prendiamo ora un campione
di 100 persone; esse possono formare in totale $100\cdot99=990$ coppie
differenti; allora la probabilità che \uline{nessuna} delle coppie
abbia il compleanno nello stesso giorno si ottiene come:
\[
\left(\frac{364}{365}\right)^{990}\simeq6.6\%
\]
Calcoliamo ora la probabilità che, all'interno del campione di 100
persone, almeno due abbiano il compleanno nello stesso giorno:
\[
1-\left(1-\frac{1}{365}\right)\cdot\left(1-\frac{2}{365}\right)\cdot\ldots\cdot\left(1-\frac{99}{365}\right)\underset{N\gg r}{\sim}1-e^{-r^{2}/2N}\rightarrow1-e^{-10000/730}\simeq0.999999
\]
Nel caso in esame si ha $r=100$ e $N=365$; se invece vogliamo ottenere
il numero di persone $r$ che rende la probabilità di avere almeno
una coppia con lo stesso compleanno, possiamo usare al contrario la
formula approssimata appena enunciata:
\[
1-e^{-r^{2}/2N}=0.5\rightarrow\frac{r^{2}}{2N}=\ln\left(2\right)\rightarrow r^{2}\simeq1.17\sqrt{N}
\]
Quando $r$ è circa uguale alla radice di $N$, la probabilità di
collisioni è superiore al 50\%.

Consideriamo un terzo caso, più rilevante dal punto di vista crittografico;
prendiamo due insiemi di $r$ persone, ognuna delle quali ha il compleanno
in uno degli $N$ giorni dell'anno (le ripetizioni vengano considerate):
si dimostra che la probabilità che vi sia una corrispondenza per i
compleanni di una coppia di persone, ciascuna da un gruppo differente,
è pari a:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Collisione nel paradosso del compleanno}{\footnotesize{}\index{Compleanno, collisione nel paradosso del@{\footnotesize{}Compleanno, collisione nel paradosso del}}}}[-0.2cm]
\begin{equation}
1-e^{-r^{2}/N}\label{eq:Paradosso-compleanno-prob-corrispondenza}
\end{equation}

Possiamo adottare questo principio per attaccare la firma digitale
tramite hash. Sia data una funzione di hash con lunghezza 60bit: vi
saranno in totale $2^{60}\simeq10^{19}=N$ ``compleanni'' (hash
possibili); la probabilità di ottenere un hash desiderato scegliendo
il messaggio è pari a $1/2^{60}$ (pressoché nulla).

Se prendiamo due insiemi di $r$ documenti, e calcoliamo l'hash di
ciascuno di essi, troveremo una collisione al 50\% di probabilità
se $r$ vale:
\[
r\simeq\sqrt{2^{60}}=2^{30}\simeq10^{10}
\]
In pratica, nel caso di un hash a 60bit, possiamo generare un miliardo
di variazioni per un messaggio legittimo e un miliardo di variazioni
per un messaggio malevolo (modificando virgole, spazi o lettere maiuscole,
in modo che un osservatore distratto non noti la differenza); dalla
(\ref{eq:Paradosso-compleanno-prob-corrispondenza}) sappiamo che
otterremo una collisione dell'hash con probabilità circa $63.2\%$;
in questo modo è possibile ottenere un messaggio malevolo che appaia
firmato dall'autore del messaggio legittimo.
\begin{example}
\emph{Sia $h_{n}\left(x\right)$ una funzione di hash con ingresso
$x$ e lunghezza dell'uscita $n$ (espressa in bit). Calcolare le
probabilità di collisione per} $h_{4}\left(x\right)$, $h_{8}\left(x\right)$
e $h_{12}\left(x\right)$.
\end{example}
$\checked$Nella seguente tabella sono riassunte le considerazioni
per le tre funzioni di hash:\smallskip{}
\begin{table}[!h]
\begin{tabular}{lll}
$h_{4}\left(x\right)\implies16$ hash & $\mathbb{P}\left(\text{collisione}\right)=\frac{1}{16}$ & $1-\left(1-\frac{1}{16}\right)^{16}=0.6439$\tabularnewline
$h_{8}\left(x\right)\implies256$ hash & $\mathbb{P}\left(\text{collisione}\right)=\frac{1}{256}$ & $1-\left(1-\frac{1}{256}\right)^{256}=0.6328$\tabularnewline
$h_{12}\left(x\right)\implies4096$ hash & $\mathbb{P}\left(\text{collisione}\right)=\frac{1}{4096}$ & $1-\left(1-\frac{1}{4096}\right)^{4096}=0.6321$\tabularnewline
\end{tabular}
\end{table}
\smallskip{}
Nella terza colonna è stata valutata la probabilità $p$ di trovare
la collisione desiderata in $2^{n}$ tentativi (con $n$ il numero
di bit dell'uscita della funzione); osservando i valori di probabilità
ottenuti, possiamo dimostrare che essi tendono a un valore limite,
che possiamo descrivere nel seguente modo:
\[
\lm n{\infty}{\left(1-\frac{1}{n}\right)^{n}\rightarrow\frac{1}{e}\implies}p=1-\frac{1}{e}
\]
\demo

\subsection{Attacco del compleanno al logaritmo discreto}

Riprendiamo le ipotesi del problema del logaritmo discreto (\ref{eq:Logaritmo-discreto}):
\[
\cgm{\alpha^{x}}{\beta}p\implies\cgm x{\logd{\alpha}{\beta}}p
\]
Per risolvere il logaritmo discreto abbiamo introdotto l'algoritmo
``baby step, giant step'' (§\ref{subsec:Baby-step-giant-step}),
che consiste nel generare due liste lunghe al più $\sqrt{p}$; attuiamo
l'attacco del compleanno costruendo prima di tutto due liste: la prima
contiene $\left\{ \mod{\alpha^{k}}p\right\} $, la seconda $\left\{ \mod{\beta\cdot\alpha^{-\ell}}p\right\} $,
dove $k,\ell\in\mathbb{Z}_{p-1}^{*}$ sono scelti a caso.

Troviamo una corrispondenza tra le due liste al 50\% di probabilità,
calcolando $\sqrt{p}$ valori possibili per $k$ ed $\ell$; indicando
con $\overline{k}$ ed $\overline{\ell}$ i valori che permettono
di ottenere una corrispondenza tra le liste, possiamo scrivere:
\[
\cgm{\alpha^{\overline{k}}}{\beta\cdot\alpha^{-\overline{\ell}}}p\implies\cgm{\beta}{\alpha^{\overline{k}+\overline{\ell}}}p\implies\cgm{\overline{k}+\overline{\ell}}{\logd{\alpha}{\beta}}p
\]
In pratica possiamo affermare che il valore $\overline{k}+\overline{\ell}$
sia il valore che risolve il logaritmo discreto cercato, tuttavia
osserviamo che esso non è più efficace dell'algoritmo ``baby step,
giant step''; infatti, per applicare tale algoritmo non è necessario
compilare completamente la seconda lista, ma basta fermarsi alla prima
corrispondenza, inoltre i valori di $\overline{k}$ ed $\overline{\ell}$
sono casuali e non possono essere computati progressivamente. Infine,
la probabilità trovare una corrispondenza non è migliore di quella
ottenuta dall'applicazione del ``baby step, giant step''.

\section{Firma digitale}

La firma digitale è una stringa di bit associata al messaggio da firmare,
che include un segreto del firmatario. In pratica si utilizza lo hash
del messaggio da firmare, al quale viene aggiunto un segreto del firmatario,
cosicché solo chi è a conoscenza del segreto (il firmatario del messaggio)
è in grado di creare la firma associata; inoltre la firma deve essere
verificabile pubblicamente \textemdash~è l'opposto della cifratura
in un crittosistema a chiave pubblica: firmando con la chiave segreta
si permette a tutti di verificare la firma decifrandola con la chiave
pubblica; questo garantisce che solo chi è in possesso della chiave
privata associata alla forma, possa generarla.

Si firma l'hash del messaggio per evitare di avere una firma molto
lunga (pari o maggiore della lunghezza del messaggio) e questo non
compromette la sicurezza della firma, per le proprietà della funzione
di hash.

Altre\marginpar{Autenticazione di questo tipo viene classificata come \emph{HMAC}:
Hash-based Message Autentication Code} applicazioni delle funzioni di hash sono il controllo di integrità
(cambiando anche un bit di un messaggio, il suo hash cambia) e l'autenticazione
del messaggio (si usa una chiave simmetrica insieme al messaggio,
per generare l'hash).

\subsection{Firma RSA\label{subsec:Firma-RSA}}

Consideriamo due parti \textbf{A} e \textbf{B}, e \textbf{B} voglia
inviare un messaggio $m$ ad \textbf{A} in modo che lo firmi. L'algoritmo
per la firma RSA in questo caso si svolge come segue:
\begin{itemize}
\item \textbf{A} pubblica $n$ ed $e_{\text{A}}$, mantiene segreto $d_{\text{A}}$
\begin{itemize}
\item sceglie due primi grandi $p,\,q$ e li usa per calcolare $n=p\cdot q$
in modo da rendere questo intero computazionalmente non fattorizzabile;
\item sceglie\marginpar{Negli intervalli di definizione, 1 e $\varphi\left(n\right)$ sono
esclusi poiché $e_{\text{A}}$ e $d_{\text{A}}$ sono esponenti (elevando
a 1 non cambia la base, ed elevare al toziente di $n$ un residuo
modulo $n$ dà 1)} la sua chiave di cifratura pubblica come $e_{\text{A}}\in\left(1,\,\varphi\left(n\right)\right)$;
\item crea la sua chiave di decifratura come $d_{\text{A}}\in\left(1,\,\varphi\left(n\right)\right)$,
che deve essere l'inverso di $e_{\text{A}}$ ($\cgm{d_{\text{A}}\cdot e_{\text{A}}}1{\varphi\left(n\right)}$);
\end{itemize}
\item \textbf{B} invia ad \textbf{A} il messaggio $m$ da firmare;
\item \textbf{A} firma il messaggio, producendo ${\scriptstyle \text{SIG}}_{\text{A}}\left(m\right)=\mod{m^{d_{\text{A}}}}n$;
\item \textbf{B} verifica la firma di \textbf{A} provando che valga $\mod{{\scriptstyle \text{SIG}}_{\text{A}}\left(m\right)^{e_{\text{A}}}}{n\overset{?}{=}m}$.
\end{itemize}
\begin{rem}
In RSA, per decifrare un messaggio cifrato da \textbf{A}, conoscendo
solo i dati pubblici $n$ ed $e_{\text{A}}$, dobbiamo ottenere l'esponente
di decifratura $\cgm{d_{\text{A}}}{e_{\text{A}}^{-1}}{\varphi\left(n\right)}$;
per calcolare questo inverso possiamo usare (\ref{eq:Teorema-Eulero})
oppure (\ref{eq:Algoritmo-Euclide-esteso}) ma in entrambi i casi
avremo bisogno di $\varphi\left(n\right)=\left(p-1\right)\left(q-1\right)$.

La firma digitale RSA funziona nel modo inverso, usando l'esponente
di decifratura per firmare e quello di cifratura per verificare la
firma.
\end{rem}
%
\begin{rem}
Questo tipo di firma nasconde il messaggio al suo interno; inoltre
intercettando una qualunque firma ${\scriptstyle \text{SIG}}_{\text{A}}\left(m\right)$
ed elevandola ad $e_{\text{A}}$ modulo $n$, otteniamo un messaggio
valido firmato da A; tuttavia esso risulterà una serie casuale di
bit.
\end{rem}

\subsection{Firma cieca}

Consideriamo la seguente variazione dell'algoritmo della firma digitale
RSA. \textbf{B} vuole che \textbf{A} firmi un messaggio $m$, senza
che \textbf{A} conosca il suo contenuto:
\begin{itemize}
\item \textbf{A} pubblica $n$ ed $e_{\text{A}}$, mantiene segreto $d_{\text{A}}$
(tutti e tre gli interi sono costruiti come in §\ref{subsec:Firma-RSA});
\item \textbf{B} sceglie un intero casuale $k\perp n$, da usare una volta
sola (nonce);
\begin{itemize}
\item \textbf{B} calcola $\cgm t{m\cdot k^{e_{\text{A}}}}n$;
\item \textbf{B} invia ad \textbf{A} il messaggio cifrato $t$;
\end{itemize}
\item \textbf{A} firma il messaggio calcolando $\cgm s{t^{d_{\text{A}}}}n={\scriptstyle \text{SIG}}_{\text{A}}\left(t\right)$;
\begin{itemize}
\item \textbf{A} invia la firma $s$ a \textbf{B};
\end{itemize}
\item \textbf{B} verifica la firma calcolando $\mod{s\cdot k^{-1}}n$, ottenendo
\[
\cgm{\overset{s}{\overbrace{m^{d_{\text{A}}}\cdot k^{e_{\text{A}}\cdot d_{\text{A}}}}}\cdot k^{-1}}{m^{d_{\text{A}}}\cdot\bcancel{k}\cdot\cancel{k^{-1}}}n
\]
ovvero \textbf{B} computa proprio la firma di \textbf{A} del messaggio
$m$ (secondo l'algoritmo della firma digitale RSA).
\end{itemize}

\subsection{Firma di El Gamal}

Seguendo l'applicazione della firma RSA, l'algoritmo per la firma
di El Gamal si applica firmando con la chiave privata e verificando
la firma tramite la chiave pubblica; in questo caso la chiave privata
può essere ottenuta a partire da quella pubblica solo risolvendo il
problema del logaritmo discreto.

Consideriamo le stesse premesse delle sezioni precedenti \textemdash~\textbf{B}
ha un messaggio $m$ che vuole far firmare ad \textbf{A} (se il messaggio
è più lungo di $p$, deve essere spezzato blocchi di dimensione $p$,
dato che l'algoritmo opera in $\mathbb{Z}_{p}^{*}$):
\begin{itemize}
\item A pubblica un primo $p$ e un intero $\alpha$;
\begin{itemize}
\item $p$ tale da rendere intrattabile il problema del logaritmo discreto
in $\mathbb{Z}_{p}^{*}$;
\item $\alpha$ sia una radice primitiva di $\mathbb{Z}_{p}^{*}$ (per garantire
l'esistenza di una soluzione al problema del logaritmo discreto);
\end{itemize}
\item \textbf{A} sceglie un esponente intero segreto $a\in\left(1,\,p-2\right)$;
\begin{itemize}
\item \textbf{A} calcola e pubblica $\cgm{\beta}{\alpha^{a}}p$ (nella pratica
è impossibile ottenere il segreto $a$ risolvendo questa equazione
con un logaritmo discreto);
\end{itemize}
\item \textbf{A} sceglie un esponente casuale $k\in\left(1,\,p-2\right)$
tale che $k\perp p-1$, da considerarsi come nonce;
\begin{itemize}
\item A produce la firma ${\scriptstyle \text{SIG}}_{\text{A}}\left(m\right)=\left(r,\,s\right)$;
\item $\cgm r{\alpha^{k}}p$;
\item $\cgm s{k^{-1}\left(m-a\cdot r\right)}{\left(p-1\right)}$;
\end{itemize}
\item B verifica la firma $\left(r,\,s\right)$ usando solo dati pubblici;
\begin{itemize}
\item la firma risulta corretta se si verifica la congruenza $\cgms{\beta^{r}\cdot r^{s}}{\alpha^{m}}p?$;
\end{itemize}
\end{itemize}
%
Mostriamo ora come la congruenza appena enunciata sia una verifica
corretta per la firma di El Gamal; dalla definizione di $s$, moltiplichiamo
per $k$ entrambi i lati della congruenza:
\[
\begin{array}{c}
\cgm{k\cdot s}{\bcancel{k}\cdot\cancel{k^{-1}}\left(m-a\cdot r\right)}{\left(p-1\right)}\\
\cgm m{k\cdot s+a\cdot r}{\left(p-1\right)}\\
\cgms{\alpha^{m}}{\overset{\varhexstar}{\overbrace{\alpha^{k\cdot s+a\cdot r}}}}p{{\scriptscriptstyle \bigstar}}\\
\cgm{\overset{\varhexstar}{\overbrace{\underset{{\scriptscriptstyle \blacktriangle}}{\underbrace{\left(\alpha^{a}\right)^{r}}}\cdot\underset{{\scriptscriptstyle \blacksquare}}{\underbrace{\left(\alpha^{k}\right)^{s}}}}}}{\overset{{\scriptscriptstyle \blacktriangle}}{\overbrace{\beta^{r}}}\cdot\overset{{\scriptscriptstyle \blacksquare}}{\overbrace{r^{s}}}}p\\
\cgm{\alpha^{m}}{\beta^{r}\cdot r^{s}}p
\end{array}
\]
Nella relazione ${\scriptstyle \bigstar}$ abbiamo usato (\ref{eq:Principio-fondamentale}),
dato che gli esponenti di $\alpha$ sono congruenti in modulo $p$;
l'ultima congruenza è proprio quella che verifica la firma di El Gamal.
\begin{rem}
La firma generata in questo modo non è sempre la stessa, fissato il
messaggio: infatti essa dipende dal segreto effimero $k$; quindi
ci sono $p-2$ firme valide per lo stesso messaggio $m$. Rispetto
alla firma cieca, in questo modo non è neanche possibile capire se
è lo stesso messaggio ad essere firmato due volte.
\end{rem}
%
\begin{rem}
La firma RSA è lunga quanto il messaggio firmato; la firma di El Gamal
è lunga il doppio del messaggio firmato (essa è espressa da due interi
$r$ ed $s$, con lo stesso ordine di grandezza); questo riconferma
la necessità di firmare l'hash del messaggio e non il messaggio stesso,
altrimenti la firma avrebbe una dimensione troppo grande rispetto
al messaggio.
\end{rem}

\subsection{Attacco del nonce ripetuto}

Un attaccante è in grado di firmare con El Gamal un messaggio al posto
di \textbf{A} in modo che \textbf{B} possa comunque verificare correttamente
la sua firma; questo accade quando \textbf{A} utilizza due volte lo
stesso $k$ per firmare.

Dal punto di vista di un osservatore esterno, quando A emette due
firme differenti ${\scriptstyle \text{SIG}}_{\text{A}}\left(m_{1}\right)=\left(r_{1},\,s_{1}\right)\neq{\scriptstyle \text{SIG}}_{\text{A}}\left(m_{2}\right)=\left(r_{2},\,s_{2}\right)$
tali che $r_{1}=r_{2}=r^{\prime}$, si può ricavare il nonce $k$
nel modo seguente:
\[
\begin{cases}
\cgm{-a\cdot r^{\prime}}{s_{1}\cdot k-m_{1}}{\left(p-1\right)}\\
\cgm{-a\cdot r^{\prime}}{s_{2}\cdot k-m_{2}}{\left(p-1\right)}
\end{cases}\implies\;\cgm{\left(s_{1}-s_{2}\right)k}{m_{1}-m_{2}}{\left(p-1\right)}
\]
La seconda relazione è il frutto della differenza tra le prime due;
possiamo calcolare $k$ dall'equazione lineare in una incognita:
\begin{equation}
\cgm k{\left(m_{1}-m_{2}\right)\cdot\left(s_{1}-s_{2}\right)^{-1}\,}{\left(p-1\right)}\label{eq:Attacco-nonce-ripetuto}
\end{equation}
Per risolverla dobbiamo ottenere l'inverso di $s_{1}-s_{2}$ modulo
$p-1$ (non è detto che esista): calcoliamo quindi $\mcd{s_{1}-s_{2}}{p-1}=d$;
esso dovrebbe essere un numero relativamente piccolo e rappresenta
il numero di soluzioni dell'equazione.

Una volta ottenuti $d$ valori di $k$, possiamo ricavare il segreto
$a$ risolvendo una equazione congruenziale lineare in una incognita:
\[
\cgm a{r^{-1}\left(m-k\cdot s\right)}{\left(p-1\right)}
\]
Di nuovo, otterremo non uno ma $n$ possibili valori di $a$ che risolvono
l'equazione.

\chapter*{Esercizi}

\section*{Equazioni congruenziali}
\begin{xca}
Risolvere la seguente equazione congruenziale:\marginpar{$\blacktriangleright$ \emph{Esercizio: equazione congruenziale, modulo
composto}}
\[
\cgm{28x}{16}{412}
\]
\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Procediamo calcolando $\mcd{28}{412}=4$; allora possiamo dividere
per 4 tutti i termini dell'equazione, ottenendo
\[
\cgm{7x}4{103}
\]
L'equazione originale avrà 4 soluzioni, e la prima si ricava dall'equazione
ridotta appena trovata:
\[
\cgm{x_{0}}{4\cdot7^{-1}}{103}
\]
Per calcolare l'inverso di 7 modulo 103 possiamo usare il Teorema
\ref{thm:Teorema-piccolo-Fermat} oppure l'algoritmo (\ref{eq:Algoritmo-Euclide-esteso}).\bigskip{}

\noun{Teorema piccolo di Fermat}\\
Il teorema afferma che, in questo caso, vale
\[
\cgm{7^{-1}}{7^{101}}{103}
\]
dato che 103 è primo; adesso effettuiamo l'operazione di $\mod{7^{101}}{103=59}$
(possiamo usare l'algoritmo descritto ne \secref{Square-=000026-multiply}),
da cui segue che
\[
\cgm{7^{-1}}{59}{103}
\]

\noun{Algoritmo di Euclide Esteso}\\
Usiamo l'algoritmo per ottenere che $7\perp103$ e in tal caso anche
$7^{-1}$; cominciamo a costruire la sequenza (\ref{eq:Algoritmo-Euclide}):
\[
\begin{array}{cc}
103=14\cdot7+5 & q_{1}=14\\
7=1\cdot5+2 & q_{2}=1\\
5=2\cdot2+\boxed{1} & q_{3}=2\\
2=2\cdot1+0 & q_{4}=1
\end{array}
\]
Otteniamo che $\mcd 7{103}=1$, e per quanto riguarda l'inverso costruiamo
la sequenza (\ref{eq:Algoritmo-Euclide-esteso}):
\[
\begin{array}{c}
x_{0}=0\\
x_{1}=1\\
x_{2}=-q_{1}x_{1}+x_{0}=-14\\
x_{3}=-q_{2}x_{2}+x_{1}=15\\
x_{4}=-q_{3}x_{3}+x_{2}=\boxed{-44}
\end{array}
\]
Segue che $\mod{-44}{103}=59=7^{-1}$.

\bigskip{}

Ora che abbiamo l'inverso di 7 in modulo 103, siamo in grado di scrivere
la soluzione dell'equazione ridotta:
\[
\begin{array}{c}
\cgm{x_{0}}{4\cdot59}{103}\\
\cgm{x_{0}}{30}{103}
\end{array}
\]
Le soluzioni successive saranno altre tre, a 103 di distanza da $x_{0}$,
esse inoltre saranno in modulo 412:
\[
X=\left\{ 30,\,133,\,236,\,339\right\} \mod{}{412}
\]
\demo
\end{sol}
\begin{xca}
Trovare\marginpar{$\blacktriangleright$ \emph{Esercizio: sistema di 2 congruenze}}
la congruenza equivalente al seguente sistema di congruenze:
\[
\begin{cases}
\cgm x5{11}\\
\cgm x2{20}
\end{cases}
\]
\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Esisterà una sola congruenza equivalente, per il Teorema \ref{thm:Teorema-cinese-del-resto},
infatti vale $11\perp20$; per riassumere le due congruenze in una
sola, cerchiamo un valore $x$ della successione $5+k\cdot11$ che
sia anche congruente a 2 in modulo 20:
\[
x=\cgm{5+k\cdot11}2{20}
\]
Questo sarà vero per un valore di $k$ pari a
\[
\begin{array}{c}
\cgm{k\cdot11}{2-5}{20}\\
\cgm k{-3\cdot11^{-1}}{20}
\end{array}
\]
Troviamo l'inverso di 11 in modulo 20 usando il Teorema \ref{thm:Teorema-Eulero}:
\[
\cgm{11^{-1}}{11^{\varphi\left(20\right)-1}}{20}
\]
sapendo che la funzione toziente di 20 vale $\varphi\left(20\right)=\left(2^{2}-2^{1}\right)\left(5^{1}-5^{0}\right)=2\cdot4=8$,
e che $\mod{11^{8-1}}{20}=11$, abbiamo la seguente congruenza per
$k$:
\[
\begin{array}{c}
\cgm k{-33}{20}\\
\cgm k7{20}
\end{array}
\]
Ritornando alla congruenza per $x$, si ottiene dalla precedente (con
$k=7$):
\[
\begin{array}{c}
x=\cgm{5+77}2{20\cdot11}\\
\cgm x{82}{220}
\end{array}
\]
dove abbiamo usato il Teorema \ref{thm:Teorema-cinese-del-resto}
per comporre la congruenza in modulo 220.\demo
\end{sol}
\begin{xca}
Trovare\marginpar{$\blacktriangleright$ \emph{Esercizio: sistema di 3 congruenze}}
il valore della variabile $x$, che compare nel sistema di congruenze:
\[
\begin{cases}
\cgm x1{10}\\
\cgm x2{11}\\
\cgm x03
\end{cases}
\]
\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Mettiamo assieme la prima congruenza con la seconda, ottenendo:
\[
x=\cgm{1+k\cdot10}2{11}
\]
Risolviamo la precedente rispetto a $k$:
\[
\cgm{k\cdot10}1{11}
\]
Notando che $100=9\cdot11+1\implies\mod{100}{11}=1$ possiamo affermare
subito che $k=10$; per il Teorema \ref{thm:Teorema-cinese-del-resto}
scriviamo:
\[
\cgm x{101}{110}
\]
Unendo quanto ottenuto con la terza congruenza del sistema, si ha:
\[
x=\cgm{101+k\cdot110}03
\]
Effettuando l'operazione di modulo 3 sui termini dell'equazione, avremo:
\[
x=\cgm{2+h\cdot2}03
\]
Risolviamo la precedente rispetto ad $h$:
\[
\begin{array}{c}
\cgm{2\cdot h}{-2}3\\
\cgm h{1\cdot2^{-1}}3
\end{array}
\]
Osserviamo che l'inverso di 2 in $\mathbb{Z}_{3}$ è proprio 2, infatti
$2\cdot2=\mod 43=1$; allora $h$ è congruente a 2 in modulo 3, e
sostituendo nella congruenza di $x$ otteniamo:
\[
\begin{array}{c}
\cgm x{101+220}{110\cdot3}\\
\cgm x{321}{330}
\end{array}
\]
Abbiamo trovato che $x$ deve valere $321+k\cdot330$ per generare
le tre congruenze esaminate.\demo
\end{sol}

\section*{Elementi primitivi}
\begin{xca}
Quanti elementi primitivi ha l'insieme $\mathbb{Z}_{31}^{*}$, e quali
sono?\marginpar{$\blacktriangleright$ \emph{Esercizio: elementi primitivi di un insieme
dei residui}}

\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Gli elementi primitivi sono in numero $\varphi\left(31-1\right)=\varphi\left(30\right)=\left(2^{1}-2^{0}\right)\left(3^{1}-3^{0}\right)\left(5^{1}-5^{0}\right)=1\cdot2\cdot4=8$
(applichiamo una delle formule \vpageref{eqn:Toziente} per calcolare
il toziente $\varphi\left(\circ\right)$).

Per capire quali siano gli elementi primitivi, usiamo il test (\ref{eq:Test-primitivit=0000E0})
con i quozienti $q_{i}=\left\{ 2,\,3,\,5\right\} $, per ciascun elemento
di $\mathbb{Z}_{31}^{*}$ (da 1 a 30); facendo le prove col test rispetto
ai tre quozienti, si ottengono i seguenti elementi primitivi:
\[
\alpha=\left\{ 3,\,11,\,12,\,13,\,\ldots\right\} 
\]
\demo
\end{sol}
\begin{xca}
Trovare gli elementi primitivi dell'insieme $\mathbb{Z}_{13}^{*}$\marginpar{$\blacktriangleright$ \emph{Esercizio: elementi primitivi di un insieme
dei residui}}

\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Usiamo un secondo metodo, a partire da un elemento sicuramente primitivo
$\alpha\in\mathbb{Z}_{13}^{*}$; proviamo con 2, sottoponendolo al
test (\ref{eq:Test-primitivit=0000E0}):
\[
\cgm{2^{6}}{-1}{13},\quad\cgm{2^{4}}3{13}
\]
Allora $\alpha=2$ è un elemento primitivo rispetto a $p=13$; possiamo
elevare $\alpha$ a tutte le potenze, per ottenere tutti gli elementi
dell'insieme. Tuttavia solo le potenze positive pari restituiranno
un altro elemento primitivo rispetto a $p$ che è un quadrato:
\[
\begin{array}{lll}
\cgm{\alpha^{1}}2{13} & \cgm{\alpha^{5}}6{13} & \cgm{\alpha^{9}}5{13}\\
\cgm{\alpha^{2}}{\boxed{4}}{13} & \cgm{\alpha^{6}}{\boxed{12}}{13} & \cgm{\alpha^{10}}{\boxed{10}}{13}\\
\cgm{\alpha^{3}}8{13} & \cgm{\alpha^{7}}{11}{13} & \cgm{\alpha^{11}}7{13}\\
\cgm{\alpha^{4}}{\boxed{3}}{13} & \cgm{\alpha^{8}}{\boxed{9}}{13} & \cgm{\alpha^{12}}{\boxed{1}}{13}
\end{array}
\]
Le radici primitive in $\mathbb{Z}_{13}^{*}$ sono:
\[
a_{q}=\left\{ 1,\,3,\,4,\,9,\,10,\,12\right\} 
\]
Si noti che ci troviamo nel caso $\cgm p14$, per cui se non esiste
$\sqrt{a}$ nemmeno $\sqrt{-a}$ è definita rispetto a $p$.\demo
\end{sol}

\section*{Scrambling}
\begin{xca}
Si\marginpar{$\blacktriangleright$ \emph{Esercizio: scrambler auto-sincronizzante}}
consideri uni scrambler auto-sincronizzante con polinomio caratteristico
$P\left(Y\right)=Y^{3}+Y+1$; esso è inizializzato come $M_{1}M_{2}M_{3}=000$,
in ingresso si ha una sequenza di soli 1 ($\left\{ I_{k}\right\} =111\ldots$);
determinare la sequenza di uscita $\left\{ U_{k}\right\} $.

\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Innanzitutto cerchiamo il periodo della successione, analizzando la
riducibilità del polinomio $P\left(Y\right)$; esso non è divisibile
per $Y$, tuttavia può esserlo per $Y+1$; dalla divisione tra polinomi
si ottiene:\marginpar{Si ricorda che le operazioni su questo polinomio sono tutte in \uline{modulo
2}}
\[
\begin{array}{rl}
Y^{3}\quad\quad+Y+1 & \underline{\left(\div\,Y+1\right)}\\
\underline{Y^{3}+Y^{2}\quad\;\qquad} & \quad Y^{2}+Y\\
Y^{2}+Y+1 & \,\\
\underline{Y^{2}+Y\quad\,\,\,\,} & \,\\
1
\end{array}
\]
Ottenendo resto non nullo, confermiamo che il polinomio non può essere
diviso nemmeno per $Y+1$; in tal caso possiamo affermare che $P\left(Y\right)$
sia irriducibile, e quindi il periodo della sequenza pseudo-casuale
generata sarà determinato dal suo grado $M=3$ come $\pi=2^{3}-1=7$.

Lo scrambler descritto dal polinomio $P\left(Y\right)$ può essere
implementato col circuito ne \figref{scrambler-auto-sincronizzante-3};
l'andamento della sua uscita si ricava riempiendo la seguente tabella
(viene mostrato anche il descrambling della sequenza $\left\{ U_{k}\right\} $
ottenuta):\bigskip{}
\\
\begin{minipage}[c]{0.5\textwidth}%
\begin{center}
\begin{tabular}{c|cccc|c}
$k$ & $\overset{\bullet}{I}_{k}$ & $\overset{\bullet}{M}_{1,k}$ & $M_{2,k}$ & $\overset{\bullet}{M}_{3,k}$ & $U_{k}$\tabularnewline
\hline 
0 & 1 & \emph{0} & \emph{0} & \emph{0} & 1\tabularnewline
1 & 1 & 1 & 0 & 0 & 0\tabularnewline
2 & 1 & 0 & 1 & 0 & 1\tabularnewline
3 & 1 & 1 & 0 & 1 & 1\tabularnewline
4 & 1 & 1 & 1 & 0 & 0\tabularnewline
5 & 1 & 0 & 1 & 1 & 0\tabularnewline
6 & 1 & 0 & 0 & 1 & 0\tabularnewline
\hline 
\hline 
7 & 1 & 0 & 0 & 0 & 1\tabularnewline
\end{tabular}\captionof{table}{Uscita dello scrambler}
\par\end{center}%
\end{minipage}%
\begin{minipage}[c]{0.5\textwidth}%
\begin{center}
\begin{tabular}{c|cccc|c}
$k$ & $\overset{\bullet}{U}_{k}$ & $\overset{\bullet}{M}_{1,k}$ & $M_{2,k}$ & $\overset{\bullet}{M}_{3,k}$ & $I_{k}$\tabularnewline
\hline 
0 & 1 & \emph{1} & \emph{0} & \emph{0} & \textbf{0}\tabularnewline
1 & 0 & 1 & 1 & 0 & \textbf{1}\tabularnewline
2 & 1 & 0 & 1 & 1 & \textbf{0}\tabularnewline
\hline 
3 & 1 & 1 & 0 & 1 & 1\tabularnewline
4 & 0 & 1 & 1 & 0 & 1\tabularnewline
5 & 0 & 0 & 1 & 1 & 1\tabularnewline
6 & 0 & 0 & 0 & 1 & 1\tabularnewline
7 & 1 & 0 & 0 & 0 & 1\tabularnewline
\end{tabular}\captionof{table}{Uscita del descrambler}
\par\end{center}%
\end{minipage}\\
La tabella indica lo stato al passo $k$-esimo delle celle di memoria
e dell'uscita; la consegna prevede di assegnare all'ingresso 1 in
ciascun passo ($\forall k\in\left[0,\,\infty\right)\tc I_{k}=1$).
Le colonne con un cerchio pieno sopra l'etichetta di una colonna relativa
a una cella di memoria, indica che essa è collegata in retroazione;
in pratica l'uscita sarà influenzata dalla somma modulo 2 dell'ingresso
con tutte le celle $\overset{\bullet}{M}_{i,k}$.

Possiamo notare che l'uscita ha proprio periodo 7; infatti lo stato
delle celle di memoria al passo 7 è uguale a quello al passo 0.

SI noti che, nella tabella del descrambler, le tre celle di memoria
sono state inizializzate in modo arbitrario ($M_{1}M_{2}M_{3}=100$),
inoltre sono stati necessari 3 passi per avere la traduzione corretta
della sequenza \textemdash~lo scrambler auto-sincronizzante descritto
da $P\left(Y\right)$ impiega $M=3$ passi per raggiungere da solo
la configurazione corretta.\demo
\end{sol}

\section*{Cifrari a chiave pubblica}
\begin{xca}
Adottiamo\marginpar{$\blacktriangleright$ \emph{Esercizio: cifratura RSA}}
il sistema a chiave pubblica RSA, pubblicando l'intero $n=323$ e
l'esponente di cifratura $e=17$; verificare la correttezza dei dati
forniti.

Provare a decifrare il messaggio cifrato $c=55$, senza conoscere
l'esponente di decifratura. Cifrare il messaggio in chiaro $p=55$.

\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Controlliamo che l'esponente di cifratura sia primo relativo al toziente
dell'intero $n$:
\[
e\perp\varphi\left(n\right)\implies17\perp\varphi\left(323\right)=\mcd{17}{\varphi\left(323\right)}\overset{?}{=}1
\]
Per calcolare l'ultima uguaglianza è necessario ottenere il toziente
di 323, e a questo scopo sarà necessario fattorizzare l'intero $n$;
anche se in generale non sarebbe possibile, nel nostro caso abbiamo
un intero piccolo, fattorizzabile per tentativi (dividiamo 323 per
tutti i primi da 3 a $\sqrt{323}$); otteniamo che $17\backslash323$,
e vale $323=17\cdot19$.

Il suo toziente può essere calcolato come:
\[
\varphi\left(323\right)=\left(17-1\right)\cdot\left(19-1\right)=16\cdot18=\boxed{288}=2^{5}\cdot3^{2}
\]
Tra i fattori di 288 non compare $e=17$, dunque l'esponente di cifratura
sarà primo relativo rispetto al toziente dell'intero $n$.

Possiamo decifrare un messaggio cifrato qualunque, data la facilità
di fattorizzazione dell'intero $n$. In generale, in RSA si decifra
un messaggio cifrato tramite l'esponente di decifratura, secondo la
seguente congruenza:
\[
\cgm p{c^{d}}n\longrightarrow\cgm p{55^{d}}{323}
\]
Possiamo ottenere l'esponente di decifratura se conosciamo il toziente
dell'intero $n$ (che abbiamo calcolato in precedenza, fattorizzando
$n$):
\[
\cgms{\cgm d{e^{-1}}{\varphi\left(n\right)}}{e^{\varphi\left(\varphi\left(n\right)\right)-1}}{\varphi\left(n\right)}{{\scriptscriptstyle \bigstar}}\longrightarrow\cgm d{17^{\varphi\left(288\right)-1}}{288}
\]
Nella congruenza ${\scriptstyle \bigstar}$ abbiamo usato l'osservazione
(\ref{eq:Inverso-residuo-toziente}) relativa al Teorema \ref{thm:Teorema-Eulero};
a questo punto vogliamo calcolare il toziente di 288, che risulta
$\varphi\left(288\right)=\left(2^{5}-2^{4}\right)\cdot\left(3^{2}-3\right)=16\cdot6=96$
e sostituendo nelle precedenti congruenze si ha:
\[
\begin{array}{c}
d=\mod{17^{95}}{288}=17\\
p=\mod{55^{17}}{323}=\boxed{123}
\end{array}
\]
Dato che l'esponente di decifratura è l'inverso dell'esponente di
cifratura modulo $\varphi\left(323\right)$, la cifratura o la decifratura
di 55 produce sempre 123 (quindi $p=55$ viene cifrato in $c=123$).\demo
\end{sol}

\section*{Firma digitale}
\begin{xca}
Dati\marginpar{$\blacktriangleright$ \emph{Esercizio: firma di El Gamal}}
i seguenti parametri: un intero $p=43$, un segreto $a=10$, un nonce
$k_{1}=11$ e un messaggio $m_{1}=15$, calcolare la firma di El Gamal
per il messaggio $m_{1}$ e poi verificarla.

\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Controlliamo le ipotesi del sistema di firma El Gamal: $p$ è un primo
e inoltre vale $a,\,k\in\left(1,\,p-2\right)$, infine $k\perp p-1$
($\mcd{11}{42}=1$), quindi le ipotesi sono verificate.

Per calcolare la firma con El Gamal abbiamo ancora bisogno di una
radice primitiva $\alpha\in\mathbb{Z}_{p}^{*}$; proviamo con $\alpha=3$,
e controlliamo che si tratta di una radice primitiva col test (\ref{eq:Test-primitivit=0000E0}):
\[
\begin{array}{c}
\cgm{3^{6}}{41}{43}\\
\cgm{3^{14}}{36}{43}\\
\cgm{3^{21}}{42}{43}
\end{array}
\]
Abbiamo la conferma che $\alpha=3$ è una radice primitiva di $\mathbb{Z}_{43}^{*}$;
ora possiamo calcolare $\cgm{\beta}{\alpha^{a}}p\implies\cgm{10}{3^{10}}{43}$,
e infine pubblichiamo i dati $\left(p,\,\alpha,\,\beta\right)=\left(43,\,3,\,10\right)$.

Firmiamo il messaggio $m_{1}=15$ costruendo i due interi $r_{1}$
ed $s_{1}$:
\[
\begin{array}{l}
\cgm{r_{1}}{\alpha^{k_{1}}}p=\mod{3^{11}}{43}=30\\
\cgm{s_{1}}{k_{1}^{-1}\cdot\left(m_{1}-a\cdot r_{1}\right)\,}{42}=\mod{23\cdot\left(15-10\cdot30\right)}{42}=39
\end{array}
\]
Abbiamo calcolato l'inverso di $k$ modulo 42 utilizzando la relazione
(\ref{eq:Inverso-residuo-toziente}) $\cgm{k_{1}^{-1}}{k_{1}^{\varphi\left(42\right)-1}}{42}=\mod{11^{11}}{42}=23$;
la firma del messaggio $m_{1}$ corrisponde a $\left(r_{1},\,s_{1}\right)=\left(30,\,39\right)$.

Verifichiamo ora la firma tramite la congruenza:
\[
\cgm{10^{30}\cdot30^{39}}{3^{15}}{43}\implies\cgm{22}{22}{43}\,\checked
\]
\demo
\end{sol}
\begin{xca}
Dati\marginpar{$\blacktriangleright$ \emph{Esercizio: attacco del nonce ripetuto}}
i seguenti parametri: un primo $p=43$, una radice primitiva $\alpha=3\in\mathbb{Z}_{43}^{*}$,
un nonce $k_{1}=11$ e un messaggio $m_{1}=15$, otteniamo ${\scriptstyle \text{SIG}}\left(m_{1}\right)=\left(30,\,39\right)$;
se abbiamo firmato anche $m_{2}=20$ senza variare il nonce $k_{1}$,
la sue firma sarà ${\scriptstyle \text{SIG}}\left(m_{2}\right)=\left(30,\,28\right)$.
Dal punto di vista di un attaccante che osserva le firme dei messaggi,
effettuare l'attacco del nonce ripetuto per ricavare $k_{1}$.

\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Per prima cosa, possiamo verificare la validità delle firme dei due
messaggi tramite i dati pubblici; per $m_{1}$ abbiamo effettuato
la verifica nell'esercizio precedente, per $m_{2}$ si ha:
\[
\cgm{10^{30}\cdot30^{28}}{3^{20}}{43}\implies\cgm{14}{14}{43}
\]
Quindi entrambe le firme sono valide; notando che il valore di $r_{1}=r_{2}$
possiamo affermare che il nonce abbia lo stesso valore in entrambi
i casi ($k_{1}=k_{2}=k^{\prime}$) e ad essere cambiato è il messaggio
($m_{1}\neq m_{2}\implies s_{1}\neq s_{2}$).

Sapendo che $\cgm{-a\cdot r}{s\cdot k-m}{\left(p-1\right)}$, scriviamo
la formula per entrambe le firme e i messaggi associati:
\[
\begin{array}{c}
\begin{cases}
\cgm{-a\cdot r_{1}}{s_{1}\cdot k^{\prime}-m_{1}}{\left(p-1\right)}\\
\cgm{-a\cdot r_{1}}{s_{2}\cdot k^{\prime}-m_{2}}{\left(p-1\right)}
\end{cases}\\
\cgm{\left(s_{1}-s_{2}\right)k^{\prime}}{m_{1}-m_{2}}{\left(p-1\right)}\\
\cgm{k^{\prime}}{\left(15-20\right)\cdot\left(39-28\right)^{-1}\,}{42}\\
k^{\prime}=\mod{-5\cdot11^{-1}}{42}
\end{array}
\]
Calcolando $\mcd{11}{42}=1$ possiamo affermare che l'equazione in
$k^{\prime}$ abbia 1 soluzione; sapendo che vale $\cgm{11^{-1}}{23}{42}$
(come calcolato nell'esercizio precedente), proseguiamo valutando
l'ultima delle precedenti congruenze:
\[
k^{\prime}=\mod{-5\cdot23}{42}=11
\]
Abbiamo ottenuto il valore di $k_{1}$, il nonce che è stato ripetuto
nella firma dei due messaggi $m_{1}$ ed $m_{2}$.\demo
\end{sol}

\part{Comunicazione sicura}

\chapter{Instaurazione e distribuzione della chiave}

\section{Identificare la chiave}

\subsection{Introduzione}

La matematica che è stata applicata alla crittografia è abbastanza
solida da garantire l'impossibilità pratica di decifrare un messaggio
se gli algoritmi sono implementati correttamente; in particolare richiamiamo
il Teorema \ref{thm:Principio-di-Kerchoffs} che è valido sia per
chiavi simmetriche che per chiavi asimmetriche.

Infatti teoricamente è possibile ricavare la chiave privata da quella
pubblica, ma in pratica è possibile solo a patto di conoscere un'informazione
``speciale'' \textemdash~come i due fattori primi in RSA, o l'esponente
usato per l'elevamento a potenza in El Gamal.

In generale, mittente e destinatario devono scambiare un segreto,
e possono comunicare solo a distanza, tramite un canale non sicuro;
sembrerebbe che la soluzione sia essere usare un crittosistema a chiave
pubblica, tuttavia:
\begin{itemize}
\item gli algoritmi per implementare i crittosistemi a chiave asimmetrica
sono computazionalmente più onerosi delle controparti a chiave simmetrica.
\end{itemize}
Una seconda possibilità consiste, per esempio, nell'usare un crittosistema
a chiave asimmetrica per scambiare in modo sicuro una chiave simmetrica,
quest'ultima sarà utilizzata per la successiva cifratura della comunicazione;
in questo caso:
\begin{itemize}
\item non è possibile fidarsi di una chiave pubblica pubblicata sul web,
senza una certificazione adeguata.
\end{itemize}
Allora è necessario fidarsi di un \emph{certificato}, che autentica
una chiave pubblica associandola con l'identità dell'utente che l'ha
pubblicata; si tratta di un documento emesso da un ente di certificazione
di cui gli utenti si fidano (solitamente si tratta di un ente che
attribuisce valore economico alla sua credibilità, dunque la fiducia
nei suoi confronti è giustificata).

Distinguiamo e analizziamo nelle sezioni successive gli algoritmi
delle seguenti categorie:
\begin{enumerate}
\item \textbf{distribuzione} della chiave: una autorità centrale si occupa
di inviare tutte le chiavi a tutti gli utenti (nel caso di $n$ utenti
e di chiavi simmetriche, bisognerà distribuire circa $n^{2}/2$ chiavi
differenti);
\item \textbf{instaurazione} della chiave: mittente e destinatario scambiano,
attraverso un canale non sicuro, gli elementi necessari a costruire
la chiave privatamente, senza che chi ne venga a conoscenza possa
a sua volta costruirla.
\end{enumerate}

\subsection{Attacco man-in-the-middle}

Richiamiamo l'algoritmo di pattuizione della chiave Diffie-Hellman
(§\ref{sec:Pattuizione-chiave-Diffie-Hellman}); esso presenta il
seguente problema di sicurezza: un attaccante potrebbe fingersi il
mittente o il destinatario dei messaggi. In effetti, non è possibile
sapere a priori se il mittente o il destinatario sia effettivamente
chi dice di essere.

Introduciamo l'attacco \emph{man-in-the-middle} (letteralmente ``uomo
nel mezzo''), che consiste nell'impersonare uno degli interlocutori;
nel caso dell'algoritmo Diffie-Hellman, abbiamo un attaccante \textbf{E}
che agisce nel modo seguente:
\begin{itemize}
\item \textbf{E} sceglie un esponente $z\in\left[1,\,p-2\right]$ (compatibilmente
con le informazioni pubblicate da \textbf{A} e \textbf{B});
\item \textbf{E} intercetta $\alpha^{x}$ e $\alpha^{y}$ provenienti da
\textbf{A} e \textbf{B};
\item \textbf{E} invia $\alpha^{z}$ ad \textbf{A} (crede di ricevere $\alpha^{y}$)
e a \textbf{B} (crede di ricevere $\alpha^{x}$);
\item \textbf{E} calcola $\cgm{K_{\text{A}\rightleftarrows\text{E}}}{\left(\alpha^{x}\right)^{z}}p$
e $\cgm{K_{\text{E}\rightleftarrows\text{B}}}{\left(\alpha^{y}\right)^{z}}p$
\item \textbf{A} calcola $K_{\text{A}\rightleftarrows\text{E}}$ indotto
da \textbf{E}, e anche \textbf{B} calcola $K_{\text{E}\rightleftarrows\text{B}}$
indotto da \textbf{E} (invece di calcolare entrambi $K_{\text{A}\rightleftarrows\text{B}}$);
\item Quando \textbf{A} invia un messaggio a \textbf{B} cifrato tramite
$K_{\text{A}\rightleftarrows\text{E}}$ \textbf{E} lo intercetta,
lo decifra e poi lo cifra con $K_{\text{E}\rightleftarrows\text{B}}$,
infine lo inoltra a \textbf{B}.
\end{itemize}
Per ovviare a questo problema, è stata introdotta una modifica dell'algoritmo
Diffie-Hellman, formalizzata nel protocollo \emph{Station-to-station}.

\subsection{Station-to-station\label{subsec:Station-to-station}}

Si tratta di una variante dell'algoritmo di pattuizione della chiave
Diffie-Hellman, con l'aggiunta del concetto delle firme digitali,
per autenticare gli interlocutori. Supponiamo che A e B vogliano instaurare
una chiave simmetrica $K$ da usare nella funzione di cifratura $E_{K}\left(\right)$;
inoltre, ammettiamo che gli algoritmi di verifica della firma per
un dato utente $U$ siano disponibili pubblicamente, e sia \textbf{T}
un'autorità fidata che certifichi che un algoritmo di verifica $\text{\emph{ver}}_{U}$
sia adatto a verificare la firma ${\scriptstyle \text{SIG}}_{U}$
dell'utente $U$, e non dell'attaccante \textbf{E}; essi procedono
nel modo seguente:
\begin{enumerate}
\item entrambi scelgono un primo $p$ molto grande, e una radice primitiva
$\alpha\in\mathbb{Z}_{p}$ tale che il problema del logaritmo discreto
in $\mathbb{Z}_{p}$ sia intrattabile;
\item \textbf{A} sceglie un intero casuale $x\in\left[1,\,p-2\right]$,
\textbf{B} sceglie un intero casuale $y\in\left[1,\,p-2\right]$;
\item \textbf{A} calcola $\mod{\alpha^{x}}p$, \textbf{B} calcola $\mod{\alpha^{y}}p$;
\item \textbf{A} invia $\alpha^{x}$ a \textbf{B};
\item \textbf{B} calcola $\cgm K{\left(\alpha^{x}\right)^{y}}p$;
\begin{enumerate}
\item \textbf{B} invia $a^{y}$ e $E_{K}\left({\scriptstyle \text{SIG}}_{B}\left(\alpha^{y},\,\alpha^{x}\right)\right)$
ad \textbf{A};
\item \textbf{A} calcola $\cgm K{\left(\alpha^{y}\right)^{x}}p$;
\item \textbf{A} decifra $E_{K}\left({\scriptstyle \text{SIG}}_{B}\left(\alpha^{y},\,\alpha^{x}\right)\right)$
ottenendo ${\scriptstyle \text{SIG}}_{B}\left(\alpha^{y},\,\alpha^{x}\right)$;
\item \textbf{A} chiede a \textbf{T} di verificare che $\text{\emph{ver}}_{B}$
sia l'algoritmo di verifica per la firma di \textbf{B;}
\end{enumerate}
\item \textbf{A} usa $\text{\emph{ver}}_{B}$ per verificare ${\scriptstyle \text{SIG}}_{B}$;
\begin{enumerate}
\item \textbf{A} invia $E_{K}\left({\scriptstyle \text{SIG}}_{A}\left(\alpha^{x},\,\alpha^{y}\right)\right)$
a B;
\item \textbf{B} decifra $E_{K}\left({\scriptstyle \text{SIG}}_{A}\left(\alpha^{x},\,\alpha^{y}\right)\right)$
ottenendo ${\scriptstyle \text{SIG}}_{A}\left(\alpha^{x},\,\alpha^{y}\right)$;
\item \textbf{B} chiede a \textbf{T} di verificare che $\text{\emph{ver}}_{A}$
sia l'algoritmo di verifica per la firma di \textbf{A};
\end{enumerate}
\item \textbf{B} usa $\text{\emph{ver}}_{A}$ per verificare ${\scriptstyle \text{SIG}}_{A}$.
\end{enumerate}
\begin{rem}
Il ruolo dell'autorità di certificazione e la fiducia riposta in essa
sono centrali in questo algoritmo; infatti la sicurezza della comunicazione
tra gli interlocutori si fonda ampiamente sulla fiducia nella verifica
di \textbf{T}.
\end{rem}

\section{Distribuire la chiave}

Anche se siamo in possesso di un algoritmo crittografico perfettamente
implementato, la debolezza si nasconde nella password utilizzata per
la cifratura: in questo senso, la maggior parte degli attacchi prende
come bersaglio la password stessa, poiché computazionalmente fattibile.

Un'altra problematica riguarda la sicurezza della trasmissione dei
segreti condivisi (per esempio chiavi simmetriche) dalle due parti
che vogliono comunicare, quando esse sono distanti. Con la crittografia
a chiave pubblica il problema della trasmissione dei segreti è risolto,
tuttavia è impossibile fidarsi della provenienza di una chiave pubblica
senza ulteriori informazioni correlate.

Affrontiamo ora il problema della distribuzione delle chiavi pubbliche
a un gruppo di utenti, considerando che il canale di comunicazione
sia osservato da \textbf{O}, il quale può anche ripetere i messaggi
ascoltati sul canale.

\subsection{Shamir-Massey-Omura (3\--pass protocol)}

Questo protocollo permette di trasferire una chiave segreta $\bar{K}$
tra due parti $A,\,B$ tramite un canale non sicuro:
\begin{enumerate}
\item $\mathbf{A}$ sceglie e pubblica un primo $p$ tale da rendere difficile
il problema del logaritmo discreto in $\mathbb{Z}_{p}^{*}$ e abbastanza
grande da rappresentare $\bar{K}$;
\item $\mathbf{A},\,\mathbf{B}$ scelgono ciascuno un numero segreto casuale,
coprimo rispetto a $p-1$ ($\mcd a{p-1}=1\land\mcd b{p-1}=1$);
\item $\mathbf{A},\,\mathbf{B}$ calcolano rispettivamente $\mod{a^{-1}}{\left(p-1\right)}$
e $\mod{b^{-1}}{\left(p-1\right)}$;
\begin{enumerate}
\item $\mathbf{A\rightarrow B}$ invia $\cgm{K_{1}}{\bar{K}^{a}}p$;
\item $\mathbf{A\leftarrow B}$ invia $\cgm{K_{2}\equiv K_{1}^{b}}{\bar{K}^{ab}}p$;
\item $\mathbf{A\rightarrow B}$ invia $\cgm{K_{3}\equiv K_{2}^{a^{-1}}}{\bar{K}^{aba^{-1}}}p$;
\end{enumerate}
\item $\mathbf{B}$ calcola $\cgm{\bar{K}\equiv K_{3}^{b^{-1}}}{\bar{K}^{aba^{-1}b^{-1}}}p$.
\end{enumerate}
Possiamo generalizzare il protocollo usando RSA (o un'altra funzione
crittografica che goda di proprietà commutativa) invece dell'elevamento
a potenza descritto, usando l'intero $n$ prodotto di due primi invece
del primo $p$.

\subsection{Schema di Blom per pre-distribuzione}

Utilizziamo questo algoritmo quando dobbiamo distribuire a un gran
numero di utenti di una rete altrettante chiavi, tramite un'autorità
fidata \textbf{T}:
\begin{enumerate}
\item Assegniamo a ogni utente un numero pubblico $\mod{r_{U}\in\mathbb{U}}p$;
\item $\mathbf{T}$ sceglie tre numeri $a,\,b,\,c$ segreti, casuali e residui
modulo $p$;
\item $\mathbf{T}$ calcola, per ogni utente $r_{U}$, le quantità:
\[
\cgm{a_{U}}{a+b\cdot r_{U}}p,\qquad\cgm{b_{U}}{b+c\cdot r_{U}}p
\]
e li invia all'utente $r_{U}$ su un canale \uline{sicuro};
\item $\mathbf{\forall r_{U}\in\mathbb{U}}$ calcolano il polinomio $g_{U}\left(x\right)=a_{U}+b_{U}\cdot x$.
\end{enumerate}
Ora consideriamo due utenti $A$ e $B$ con i rispettivi numeri $r_{A}$
e $r_{B}$:
\begin{itemize}
\item se $A$ vuole comunicare con $B$, deve computare $g_{A}\left(r_{B}\right)=K_{A\rightarrow B}$;
\item se $B$ vuole comunicare con $A$, deve computare $g_{B}\left(r_{A}\right)=K_{A\leftarrow B}$;
\end{itemize}
inoltre si può dimostrare che $K_{A\rightarrow B}\equiv K_{A\leftarrow B}$,
per cui la chiave può essere usata per un crittosistema a chiave simmetrica.

\subsection{Cooperazione degli utenti}

Se due utenti $A$ e $B$ scambiano i propri numeri ricevuti da $T$,
entrambi vengono a conoscenza di $a_{A},\,b_{A},\,a_{B},\,b_{B}$:
in tal caso potranno computare i tre numeri segreti $a,\,b,\,c$ selezionati
da $T$, e quindi scoprire le chiavi per comunicare con tutti gli
altri utenti.

\section{Distribuzione autenticata}

Trattiamo qui il secondo problema introdotto nella sezione precedente,
ovvero la fiducia nelle chiavi ricevute dall'autorità fidata \textbf{T}:
infatti un osservatore $\mathbf{O}$ che intercetta e ripete un messaggio
inviato da $\mathbf{T}$ sarà scambiato per quest'ultimo dal destinatario
del messaggio, il quale potrebbe essere indotto a instaurare una chiave
con $\mathbf{O}$.

Per contrastare un simile attacco è opportuno autenticare gli utenti;
inoltre si im\-piegano delle \emph{key encryption key} (KEK) per
cifrare la comunicazione delle chiavi instaurate con l'autorità fidata.

Un'altro\marginpar{Un timestamp è una stringa che rappresenta l'informazione sul tempo
di sistema di un dispositivo} metodo consiste nell'identificazione dei messaggi, tramite numero
di sequenza (bisogna tenerne traccia), \emph{timestamp} (le parti
che vogliono comunicare devono essere sincronizzate) o nonce (è necessario
uno schema di \emph{challenge-response}).

\subsection{Protocollo della rana dalla bocca larga}

Si tratta di un protocollo di distribuzione autenticata della chiave
tramite un'autorità fidata \textbf{T}, che sfrutta i timestamp e si
basa sull'ipotesi che le KEK tra gli utenti e \textbf{T} siano già
state distribuite:
\begin{enumerate}
\item $\mathbf{A}$ sceglie una chiave di sessione $K_{AB}$ per comunicare
con $\mathbf{B}$, e chiede a $\mathbf{T}$ di inviargliela in modo
sicuro;
\item $\mathbf{A}$ invia a $\mathbf{T}$ un timestamp $t_{A}$, un identificativo
del destinatario $\text{ID}_{B}$ e la chiave che vuole trasferire
$K_{AB}$, cifrando il messaggio con la chiave per comunicare con
$\mathbf{T}$:
\[
E_{K_{AT}}\left[t_{A}\|\text{ID}_{B}\|K_{AB}\right]\text{;}
\]
\item $\mathbf{T}$ invia a $\mathbf{B}$ un timestamp $t_{T}$, un identificativo
del mittente $\text{ID}_{A}$ e la chiave da trasferire $K_{A\rightarrow B}$,
cifrando il messaggio con la chiave per comunicare con $\mathbf{B}$:
\[
E_{K_{BT}}\left[t_{T}\|\text{ID}_{A}\|K_{AB}\right]\text{;}
\]
\end{enumerate}
Il timestamp serve per evitare gli attacchi di replica (l'attaccante
dovrebbe conoscere le KEK per modificare il contenuto dei messaggi);
il fatto che l'autorità fidata si occupi di rinnovare il timestamp
rappresenta una potenziale minaccia.

\subsection{Man-in-the-middle al protocollo della rana dalla bocca larga}

Immaginiamo di avere sulla rete un altro utente malevolo \textbf{M},
il quale vuole estendere la validità della KEK: una chiave di sessione
come la KEK deve avere durata limitata, sia per evitare di concedere
all'attaccante il tempo per trovarla, sia perché se compromessa è
desiderabile sostituirla il prima possibile.
\begin{enumerate}
\item $\mathbf{M}$ osserva uno scambio di messaggi tra $\mathbf{A}$ e
$\mathbf{T}$ e tra $\mathbf{T}$ e $\mathbf{B}$;
\item $\mathbf{M}$ impersona $\mathbf{B}$, e chiede a $\mathbf{T}$ di
condividere una chiave $K_{AB}$ con $\mathbf{A}$:
\[
E_{K_{BT}}\left[t_{T}\|\text{ID}_{A}\|K_{AB}\right]\text{;}
\]
\item $\mathbf{T}$ riceve un messaggio valido e quindi invia la chiave
ad $\mathbf{A}$, aggiornando il timestamp del messaggio:
\[
E_{K_{AT}}\left[t_{T}^{\prime}\|\text{ID}_{B}\|K_{AB}\right]
\]
$\mathbf{A}$ crede che il messaggio ricevuto da $\mathbf{T}$ sia
valido, quindi la chiave $K_{AB}$ rimane valida per un tempo $t_{T}^{\prime}>t_{T}$,
e per un certo intervallo di tempo successivo;
\item $\mathbf{M}$ impersona $\mathbf{A}$, e riceve il messaggio contenente
la chiave $K_{AB}$ e un timestamp $t_{T}^{\prime\prime}>t_{T}^{\prime}$:
\[
E_{K_{BT}}\left[t_{T}^{\prime\prime}\|\text{ID}_{A}\|K_{AB}\right]
\]
così facendo la chiave $K_{AB}$ rimarrà valida per un intervallo
di tempo successivo a $t_{T}^{\prime\prime}$;
\item $\mathbf{M}$ ripete i passi dal $\left(2\right)$ al $\left(4\right)$.
\end{enumerate}
Con questa procedura, è possibile indurre gli utenti a usare in modo
indefinito la stessa chiave $K_{AB}$.

\subsection{Protocollo Needham-Schroeder\label{subsec:Protocollo-Needham-Schroeder}}

Poniamo il caso di avere un'autorità fidata \textbf{T}, che abbia
già distribuito agli utenti \textbf{A} e \textbf{B} le KEK:
\begin{enumerate}
\item $\mathbf{A}$ invia a $\mathbf{T}$ in chiaro il suo ID, quello dell'utente
col quale vuole comunicare ($\mathbf{B}$) e un nonce $r_{1}$:
\[
\text{ID}_{A}\|\text{ID}_{B}\|r_{1}\text{;}
\]
\item $\mathbf{T}$ risponde ad $\mathbf{A}$ cifrando con la KEK relativa,
inviando una chiave di sessione estratta $K_{S}$, lo stesso nonce
, l'ID del destinatario e il messaggio che egli riceverà (cifrato
con la KEK relativa): 
\[
E_{K_{AT}}\left[K_{S}\|\text{ID}_{B}\|r_{1}\|E_{K_{BT}}\left[K_{S}\|\text{ID}_{A}\right]\right]\text{;}
\]
\item $\mathbf{A}$ estrae l'ultima stringa $E_{K_{BT}}\left[K_{S}\|\text{ID}_{A}\right]$
(che non può decifrare), e la manda a $\mathbf{B}$, il quale possiede
la KEK per estrarre dal messaggio la chiave di sessione $K_{S}$ che
userà per comunicare con $\mathbf{A}$ (il messaggio contiene $\text{ID}_{A}$);
\item $\mathbf{B}$ invia ad $\mathbf{A}$ un nonce cifrato con la chiave
di sessione: $E_{K_{S}}\left[r_{2}\right]$;
\item $\mathbf{A}$ risponde a $\mathbf{B}$ col nonce meno 1: $E_{K_{S}}\left[r_{2}-1\right]$.
\end{enumerate}

\chapter{Autenticazione e autorizzazione}

\section{Caratteristiche dell'autenticazione}

Autenticare\marginpar{La definizione di autenticazione è enunciata nel RFC 4949 (IETF)}
vuol dir garantire l'identità di un utente, di un dispositivo o di
una sorgente di informazioni; autorizzare vuol dire determinare le
risorse e i servizi che una entità autorizzata è in grado di usare
(l'autorizzazzione implica l'autenticazione).

L'autenticazione è costituita da tre fasi principali:
\begin{enumerate}
\item \noun{registrazione}: l'utente deve essere registrato (per esempio
in una base di dati) e associato a delle ceredenziali;
\item \noun{identificazione}: il candidato si presenta al verificatore (per
esempio il server) come un certo utente, fornendogli un identificatore;
\item \noun{verifica}: il candidato deve provare di essere chi afferma,
(per esempio tramite password, rispondendo a una sfida, ecc\ldots).
\end{enumerate}
Possiamo classificare l'autenticazione in base al tipo di connessione
col servizio richiesto:
\begin{itemize}
\item locale (l'utente accede localmente alle risorse);
\item diretta (l'utente accede a un sistema remoto);
\item indiretta (l'autenticazione è delegata a una terza parte);
\item off-line (il successo dell'autenticazione viene determinato senza
contattare l'utente o una terza parte).
\end{itemize}
Inoltre, l'autenticazione può essere effettuata attraverso i seguenti
mezzi (\emph{fattori}):
\begin{itemize}
\item qualcosa che sai (PIN, password);
\item qualcosa che hai (smart card, token hardware);
\item qualcosa che sei (impronta digitale, scansione retina);
\item qualcosa che fai (timbro vocale, scrittura a mano).
\end{itemize}
Spesso per migliorare la sicurezza di questi sistemi si combinano
due o tre fattori di autenticazione.

Per garantire la sicurezza dell'autenticazioneè necessario garantire
che: le credenziali \uline{non} siano trasmesse in chiaro (un osservatore
del canale può intercettarle), e le credenziali \uline{non} siano
salvate in chiaro (se il sistema viene compromesso, l'attaccante le
ottiene).

\section{Username e password}

\subsection{Debolezze della password}

Sistema più comune di autenticazione, che incarna il Teorema~\ref{thm:Principio-di-Kerchoffs}:
il nome utente può essere pubblicato, ma la password va mantenuta
segreta. Per questo motivo viene trasmessa e memorizzata sotto forma
di \emph{digest} (prodotto di una funzione di hash).

In pratica, per ottenere la password che corrisponde al digest memorizzato
o trasmesso, dobbiamo tentare tutte le possibili stringhe come input
della funzione di hash coinvolta, fino ad ottenere una collisione
o la password corretta, e questo richiede un numero di tentativi proporzionale
al numero di bit del digest.

Pur procedendo a caso, se abbiamo un digest di $n$ bit e calcoliamo$2^{n}$
hash per altrettante stringhe in input differenti, la probabilità
di trovare la corrispondenza è comunque inferiore a 1.

Ovviamente, la probabilità di successo si innalza drasticamente quando
la password è la parola di una lingua e ci sono le condizioni per
mettere in pratica un attacco del vocabolario.

\subsection{Entropia della password}

Una password è tanto più sicura quanta più informazione segreta essa
contiene; dalla teoria dell'informazione di Shannon, sappiamo che
la misura di informazione in un messaggio è la sua entropia (misura
del ``disordine''); a grandi linee possiamo affermare che:
\begin{quotation}
\emph{L'entropia di un messaggio è l'impredicibilità del suo stato
o, in modo equivalente, del suo contenuto informativo, o del contenuto
informativo medio di una sorgente di informazioni; un messaggio contiene
tanta più informazione quanto più è impredicibile.}
\end{quotation}
\begin{defn}
Consideriamo una sorgente $X$ (priva di memoria, la probabilità di
ottenere un determinato messaggio è indipendente dai messaggi già
estratti) del messaggio $\overline{x}$, definito su un alfabeto finito
di $N$ simboli:
\[
\overline{x}\in\left\{ x_{1},\,\ldots,\,x_{N}\right\} 
\]
La probabilità che il messaggio assuma valore $\overline{x}=x_{i}$
per $i\in\left[1,\,\ldots,\,N\right]$ sarà definita come:
\[
p_{i}=P\left(\overline{x}=x_{i}\right)
\]
la relativa distribuzione di probabilità quasi sempre non è uniforme
e dipende soprattutto dal linguaggio che usa l'alfabeto.

Chiamiamo quantità di \emph{informazione}, e la misuriamo in bit,
la seguente funzione relativa a un messaggio $\overline{x}=x_{i}$:
\begin{equation}
\mathbb{I}\left(\overline{x}\right)\coloneqq-\log_{2}\left(p_{i}\right)\geq0\label{eq:Quantit=0000E0-informazione}
\end{equation}

L'informazione media di una sorgente, per carattere sull'alfabeto,
è chiamata \emph{entropia di sorgente} e si indica come:
\begin{equation}
\mathbb{H}\left(X\right)\coloneqq-\serie{i=1}N{p_{i}\cdot\log_{2}\left(p_{i}\right)}\geq0\label{eq:Entropia-sorgente}
\end{equation}
\end{defn}
\begin{example}
\emph{Consideriamo}\marginpar{\emph{American Standard Code for Information Interchange, si pronuncia
/$^{\prime}$\ae ski:/}}\emph{ una password alfabetica, che usi caratteri definiti tramite
7 bit; dei $2^{7}=128$ caratteri ASCII, 32 sono di controllo (non
stampabili e non usati nelle password) e i restanti 95 simboli saranno
l'alfabeto $\vec{a}$ che useremo; ottenere l'entropia di una password
così formata.}

Applicando la formula (\ref{eq:Entropia-sorgente}) su una sorgente
di informazione $A$ con tale alfabeto, in cui i simboli in uscita
abbiano distribuzione di probabilità uniforme, otteniamo:
\[
\mathbb{H}\left(A\right)=\log_{2}\left(95\right)\simeq6.57\,\text{bit}/\text{carattere}
\]
Segue che una password di 10 caratteri ricavata dalla sorgente $A$
avrà circa 65.7~bit di informazione; inoltre possiamo verificare
che, usando un alfabeto latino di 26 lettere più lo spazio, la quantità
d'informazione relativa sarà di circa 4.75~bit$/$carattere.

Infine, osservando che i simboli non hanno tutti la stessa probabilità
di apparire all'interno di una determinata lingua (si può determinare
la distribuzione di probabilità di una certa lingua, da usare nella
formula per l'entropia della sorgente), possiamo ottenere un'entropia
media per carattere ancora più bassa. \demo

È ragionevole aspettarsi che caratteri successivi estratti da una
sorgente siano correlati (digrammi, trigrammi): questo abbassa ancora
di più l'entropia finale di un determinato messaggio; prendendo un
testo in lingua italiana sufficientemente lungo come ``I promessi
sposi'' (A. Manzoni) ed estraendo cinque simboli dalla sorgente $P$
(che usa alfabeto di 21 lettere) otteniamo:
\[
\mathbb{H}_{5}\left(P\right)\simeq1.87\,\text{bit}/\text{carattere}
\]
Shannon dimostrò che, preso un testo in lingua inglese come sorgente
$E$, l'entropia media che ne risulta è:
\[
0.6<\mathbb{H}\left(E\right)<1.3\,\text{bit}/\text{carattere}
\]
\end{example}
L'entropia di una passphrase o password ad oggi è in media circa 2~bit$/$carattere.

\subsection{Attacchi alle password}

Possiamo ottenere una password attaccando la sua memorizzazione o
trasmissione, nei seguenti modi:
\begin{itemize}
\item \emph{sniffing} (intercettazione del traffico sul canale dove avviene
l'autenticazione);
\item on-line \emph{guessing} (generazione e invio di molte password al
server per l'autenticazione);
\item off-line \emph{guessing} (generazione di password per attaccare la
memorizzazione non sicura, teoricamente senza limiti di tempo e spazio);
\item altro (social engineering, shoulder surfing, \emph{phishing}, \emph{keylogging},
ecc\ldots).
\end{itemize}

\section{Sfida e risposta}

\subsection{Motivazioni e implementazione}

Risolve il problema della trasmissione sicura delle credenziali, che
in questo protocollo non viene effettuata: un segre\-to viene condiviso
in qualche maniera tra client e server, e il client deve dimostrare
di conoscerlo, rispondendo in maniera adeguata a una sfida.

La sfida viene risolta nel modo seguente:
\begin{enumerate}
\item client e server condividono lo stesso segreto $K$;
\item Il server invia al client un numero pseudo-casuale $S$;
\item il client invia indietro una risposta costruita come
\begin{enumerate}
\item cifratura simmetrica della sfida $E_{K}\left(S\right)$, tramite segreto
$K$;
\item il digest della sfida concatenata al segreto $h\left(S\|K\right)$;
\item cifratura della sfida tramite chiave privata $K_{p}$, $E_{K_{p}}\left(S\right)$
(il server deve possedere la chiave pubblica associata $K_{\ell}$).
\end{enumerate}
\end{enumerate}
Oltre\marginpar{Chiamiamo OTP (One Time Password) una password mono-uso}
alla procedura che usa un segreto condiviso, un protocollo di sfida
e risposta (challenge-response) può essere implementato tramite chiavi
di sessione mono-uso; si pone tuttavia il problema della generazione
e del trasferimento sicuro di queste chiavi da server a client.

\subsection{Schema di Lamport per la catena di hash}

Consideriamo un client \textbf{A} e un server \textbf{B}, quest'ultimo
vuole autenticare \textbf{A}; il client conosce il proprio nome sul
server e la password $p_{A}$, mentre il server conosce il digest
della funzione di hash calcolata $n$ volte ricorsivamente su $p_{A}$
(dove $n$ è un numero grande, e che indichiamo con $h_{n}\left(p_{A}\right)$);
è evidentemente necessaria una fase di instaurazione delle chiavi
nella quale al server viene inviato il nome dell'utente $A$ accoppiato
col digest $h_{n}\left(p_{A}\right)$.

L'autenticazione si svolge nel modo seguente:
\begin{enumerate}
\item \textbf{A} invia il proprio nome utente in chiaro a \textbf{B};
\item \textbf{B} risponde ad \textbf{A} inviando $n$ in chiaro;
\item \textbf{A} invia $h_{n-1}\left(p_{A}\right)$ a \textbf{B};
\item \textbf{B} computa $h_{n}\left(p_{A}\right)=h\left(h_{n-1}\left(p_{A}\right)\right)$,
e lo confronta col valore abbinato al nome utente $A$;
\item in caso di successo, \textbf{B} aggiorna il valore associato al nome
utente $A$, rimpiazzandolo con $h_{n-1}\left(p_{A}\right)$, e alla
prossima richiesta di autenticazione da \textbf{A} invierà l'intero
$n-1$.
\end{enumerate}
La sicurezza dell'algoritmo si basa sull'unidirezionalità della funzione
di hash $h\left(\circ\right)$ e sulla grandezza di $n$.

\subsection*{Schema di Lamport con due server di autenticazione}

In un contesto con due server \textbf{B} e \textbf{C} a cui l'utente
\textbf{A} si vuole autenticare, è possibile che ciascuno di essi
invii al client un intero $n$ differente; in tal caso, un osservatore
sul canale vedrà le coppie $n_{B},\,h_{n_{B}-1}\left(p_{A}\right)$
e $n_{C},\,h_{n_{C}-1}\left(p_{A}\right)$; se effettivamente i due
interi sono diversi e inoltre siamo nel caso $n_{B}=n_{C}+1$, allora
l'osservatore potrà presentarsi al server \textbf{C} inviando il nome
utente $A$ e il digest $h_{n_{C}-1}\left(p_{A}\right)$.

Per far fronte a questa debolezza basta usare un sale unico per ciascun
server, per salvare le password $p$ degli utenti; in questo modo
i digest destinati a un server saranno rifiutati dagli altri.

\subsection*{Attacco del piccolo \emph{n}}

Quando il server sceglie l'intero $n$, determina il tempo di vita
dell'algoritmo; supponiamo che un osservatore \textbf{O} sul canale
riesca a impersonare il server \textbf{B}: egli attende la richiesta
di autenticazione da parte di \textbf{A}, e risponde con un intero
piccolo (per esempio $n=50$).

L'osservatore otterrà l'informazione $h_{49}\left(p_{A}\right)$ e,
se il server vero sta usando $n=1000$, allora \textbf{O} potrà usarla
per generare tutti i digest fino a $h_{1000}\left(p_{A}\right)$,
per autenticarsi le prossime $1000-50=950$ volte col server vero
al posto di \textbf{A}.

\subsection{Token di sicurezza}

Si tratta di un dispositivo fisico o di un software che genera una
password mono-uso basandosi sul tempo (OTP valida entro una fine\-stra
di tempo, usata per sincronizzare il tempo del token col server) o
su un contatore (generato in modo incrementale secondo una sequenza,
permette di sincronizzarla col server).

Per aumentarne la sicurezza, i token sono spesso abbinati al fattore
di autenticazione della conoscenza (PIN o password da abbinare alla
OTP); questa procedura viene chiamata autenticazione a due fattori
e si indica con la sigla 2FA.

\subsection{Biometrica}

Si utilizza per evitare all'utente di ricordare una passphrase lunga,
tuttavia si tratta di sistemi ancora deboli e non in grado costituire
il singolo fattore di autenticazione di un sistema.

Le applicazioni di questo fattore sono le seguenti:
\begin{itemize}
\item autenticazione (confermare la dichiarata identità di un utente);
\item identificazione (associare un campione dato con un utente o un piccolo
gruppo dalle caratteristiche simili);
\item unicità (dato un campione, possiamo determinare se l'utente sia già
registrato).
\end{itemize}
Il fattore biometrico viene a sua volta suddiviso in base alle modalità
di acquisizione del campione:
\begin{itemize}
\item statico (qualcosa che sei, caratteristiche fisiche):
\item dinamico (qualcosa che fai, pattern di comportamento).
\end{itemize}
La ricerca dei campioni nella base di dati degli utenti registrati
viene effettuata per corrispondenza migliore: dal momento che l'informazione
biometrica digitalizzata è molto ingombrante, su di essa viene calcolato
un modello semplificato basato su caratteristiche comuni a tutti i
campioni, e poi confrontato coi dati registrati.

Il confronto viene effettuato calcolando la distanza tra campione
e dato registrato, e il campione viene accettato solo se questa distanza
è inferiore a una certa soglia di accettazione.

Le caratteristiche fisiche che vengono campionate come fattore biometrico
possono essere: impronte digitali, forma della mano, iride o retina,
volto, immagine termica, analisi dell'odore, DNA, (fattori statici)
oppure riconoscimento vocale, dinamica e pattern di scrittura (fattori
dinamici), ecc\ldots

\subsection*{Accuratezza e prestazioni del fattore biometrico}
\begin{defn}
Chiamiamo tasso di falsa accettazione (fase acceptance rate) e lo
indichiamo con la sigla FAR, la misura della probabilità che il sistema
permetta l'accesso a un utente non autorizzato (falso positivo); il
suo valore si ottiene come:
\[
{\scriptstyle \text{FAR}}\coloneqq\frac{\text{falsi positivi accettati}}{\text{tentativi di identificazione}}
\]
\end{defn}
%
\begin{defn}
Chiamiamo tasso di falso rifiuto (false rejection rate) e lo indichiamo
con la sigla FRR, la misura della probabilità che il sistema neghi
l'accesso a un utente autorizzato e registrato (falso negativo); il
suo valore si ottiene come:
\[
{\scriptstyle \text{FRR}}\coloneqq\frac{\text{falsi negativi rifiutati}}{\text{tentativi di identificazione}}
\]
\end{defn}
Fissato un metodo per acquisire campioni biometrici, e una metrica
per modellizzarli ed effettuare confronti tra loro calcolandone la
distanza, possiamo regolare la soglia di decisione basandoci sui parametri
${\scriptstyle \text{FAR}}$ e ${\scriptstyle \text{FRR}}$: il minimo
della somma o del prodotto delle due probabilità (punto di incontro
delle relative curve in $\mathbb{R}^{2}$) viene scelto come soglia
di accettazione per il sistema.

I sistemi biometrici attuali non ammettono valori ${\scriptstyle \text{FAR}}$
e ${\scriptstyle \text{FRR}}$ tali da permettere di usare questo
fattore di autenticazione da solo; i problemi di accuratezza di cui
soffre sono classificati come segue:
\begin{itemize}
\item rumore nella misurazione e inconsistenza dei dati acquisiti (sensore
per impronte digitali sporco o polpastrello ferito);
\item variazioni intra-classe (la foto del volto cambia a seconda della
luce ambientale);
\item similitudine inter-classe (persone con volti molto simili);
\item non-universalità (non tutti gli individui presentano qualità adeguata
per le caratteristiche fisiche misurate, come l'assenza di impronte
digitali per una persona priva di mani);
\item \emph{spoofing} (ingannare il sensore inducendo un falso positivo).
\end{itemize}

\section{Kerberos}

Questo protocollo fornisce un servizio centralizzato per la distribuzione
delle chiavi e l'autenticazione indiretta in un ambiente distribuito
e non fidato (si dà per scontata la presenza di osservatori sul canale
e il tentativo di impersonare gli utenti legittimi).

I suoi requisiti di implementazione sono:
\begin{itemize}
\item gli utenti accedono ai servizi tramite la rete;
\item i server limitano l'accesso agli utenti autorizzati e autenticano
le richieste per i singoli servizi;
\item basato sul protocollo Needham-Schroeder (§~\ref{subsec:Protocollo-Needham-Schroeder}),
con l'impiego di un server fidato per l'autenticazione;
\item usa solo crittografia simmetrica (nessuna chiave pubblica);
\item richiede la sincronizzazione del tempo su tutte le macchine coinvolte.
\end{itemize}
L'idea alla sua base è avere un server per autenticare gli utenti
e un server per autenticare l'accesso al servizio richiesto.

\subsection{Richiesta di autenticazione}

Consideriamo un utente \textbf{C} che vuole autenticarsi tramite il
server di autenticazione \textbf{A} (quest'ultimo deve essere stato
inizializzato correttamente con le chiavi simmetriche):
\begin{enumerate}
\item \textbf{C} invia ad \textbf{A} il proprio ID, la propria password
e l'ID del server al quale vuole accedere ($\text{ID}_{C}\|p_{C}\|\text{ID}_{S}$);
\item \textbf{A} risponde a \textbf{C} con un \emph{ticket} $\bar{t}$ (messaggio
che solo il server di autenticazione può creare ed è valido per uno
specifico utente $\text{ID}_{C}$ su uno specifico server $\text{ID}_{S}$);
\item \textbf{C} invia ad \textbf{S} (server identificato da $\text{ID}_{S}$)
il ticket e il proprio nome ($\text{ID}_{C}\|\bar{t}$).
\end{enumerate}
Il primo problema di questa implementazione è rappresentato dall'invio
della password dell'utente in chiaro; inoltre con questa implementazione
ogni volta che si vuole richiedere il servizio è necessario usare
un ticket (sarebbe più comodo per l'utente avere a disposizione una
sessione al cui interno usare liberamente il servizio).

\subsection{Ticket granting server}

Introduciamo i seguenti cambiamenti all'algoritmo mostrato nella precedente
sezione:
\begin{itemize}
\item non trasmettiamo la password dell'utente in chiaro;
\item usiamo un ticket granting server (\textbf{T}), che distribuisce a
un utente autorizzato un ticket per ottenere un altro servizio richiesto;
\begin{itemize}
\item ticket granting ticket ($\bar{t}_{G}$) permette di richiedere il
ticket di un servizio;
\item ticket di servizio ($\bar{t}_{S}$) permette di richiedere uno specifico
servizio.
\end{itemize}
\end{itemize}
Implementiamo il protocollo con i nuovi elementi introdotti:
\begin{enumerate}
\item l'utente \textbf{C}, che si vuole autenticare, chiede un ticket al
server \textbf{A}, inviandogli $\text{ID}_{C}\|\text{ID}_{T}$;
\item il server di autenticazione \textbf{A} risponde con un ticket $\bar{t}_{G}$
cifrato con la chiave simmetrica condivisa con \textbf{C} ($E_{K_{C,A}}\left(\bar{t}_{G}\right)$);
\item \textbf{C} chiede a \textbf{T} un ticket per usare un servizio sul
server \textbf{S}, inviandogli $\text{ID}_{C}\|\text{ID}_{S}\|\bar{t}_{G}$
(il ticket ricevuto da \textbf{T} può essere estratto solo dal vero
\textbf{C}, poiché è necessario decifrare usando la chiave simmetrica
$K_{C,A}$ condivisa tra utente e server di autenticazione);
\item il server \textbf{T} risponde con il ticket $\bar{t}_{S}$ se ha ricevuto
un $\bar{t}_{G}$ coretto;
\item l'utente \textbf{C} si rivolge al server \textbf{S} che fornisce il
servizio desiderato, inviandogli il ticket e il proprio nome ($\text{ID}_{C}\|\bar{t}_{S}$).
\end{enumerate}
Ogni volta che un utente inizia una nuova sessione di autenticazione,
dovrà ripetere i passi 1-2; ogni volta che l'utente vuole accedere
a un servizio differente, ripeterà i passi 3-4; per ogni sessione
di servizio avviata dall'utente, esso dovrà ripetere il passo 5.

I due ticket sono costruiti come segue:
\begin{itemize}
\item $\bar{t}_{G}=E_{K_{T,A}}\left(\text{ID}_{C}\|\text{ID}_{A}\|\text{ID}_{T}\|t_{s1}\|\ell_{1}\right)$;
\item $\bar{t}_{S}=E_{K_{S,T}}\left(\text{ID}_{C}\|\text{ID}_{A}\|\text{ID}_{S}\|t_{s2}\|\ell_{2}\right)$.
\end{itemize}
Nella struttura dei ticket abbiamo $t_{si}$ che rappresenta il timestamp
$i$-esimo (data di rilascio del ticket), e $\ell_{i}$ che rappresenta
il tempo di vita $i$-esimo di un ticket. Se i tempi di vita dei ticket
sono troppo corti o troppo lunghi, l'utente dovrà fornire spesso la
password oppure ci si espone ad attacchi di replica:
\begin{itemize}
\item il ticket $\bar{t}_{G}$ può essere osservato sul canale e replicato
per richiedere il ticket $\bar{t}_{S}$, impersonando l'utente;
\item il ticket $\bar{t}_{S}$ può essere osservato sul canale e replicato
per richiedere un servizio, impersonando l'utente;
\item basta usare l'indirizzo IP dell'utente \textbf{C} per impersonarlo.
\end{itemize}
Per evitare questo tipo di attacchi bisogna autenticare client con
server e vice versa.

\subsection{Mutua autenticazione (Kerberos v4)}

Introduciamo i seguenti cambiamenti all'algoritmo mostrato nella precedente
sezione:
\begin{itemize}
\item utilizziamo i timestamp anche in fase di autenticazione;
\item inviamo i ticket assieme a un timestamp e cifriamo il tutto;
\item usiamo delle stringhe contenenti la cifratura di di ID del client
e del server di autenticazione assieme a un timestamp, e chiamiamole
\emph{authenticator}.
\end{itemize}
Implementiamo il protocollo con i nuovi elementi introdotti:
\begin{enumerate}
\item \textbf{C} invia ad \textbf{A} il messaggio $\text{ID}_{C}\|\text{ID}_{T}\|t_{s1}$;
\item \textbf{A} risponde a \textbf{C} con $E_{K_{C,A}}\left(K_{C,T}\|\text{ID}_{T}\|t_{s2}\|\ell_{2}\|\bar{t}_{G}\right)$;
\item \textbf{C} invia a \textbf{T} il messaggio $\text{ID}_{S}\|\bar{t}_{G}\|\mathbb{A}_{C1}$;
\item \textbf{T} risponde con $E_{K_{C,T}}\left(K_{C,S}\|\text{ID}_{S}\|t_{s4}\|\bar{t}_{S}\right)$;
\item \textbf{C} invia ad \textbf{S} il messaggio $\bar{t}_{S}\|\mathbb{A}_{C2}$;
\item \textbf{S} risponde con $E_{K_{C,S}}\left(t_{s5}+1\right)$.
\end{enumerate}
I due authenticator sono costruiti come:
\begin{itemize}
\item $\mathbb{A}_{C1}=E_{K_{C,T}}\left(\text{ID}_{C}\|\text{ID}_{A}\|t_{s3}\right)$;
\item $\mathbb{A}_{C2}=E_{K_{C,S}}\left(\text{ID}_{C}\|\text{ID}_{A}\|t_{s5}\right)$.
\end{itemize}

\subsection{Reami}

Un reame Kerberos consiste in un server di autenticazione, un TGS,
uno o più server che espongono servizi e infine un gruppo di utenti
che li richiedono; possiamo configurare la rete per contenere più
di un reame e per effettuare l'autenticazione inter-reame, permettendo
a utenti di un reame di usare servizi situati in un'altro reame.

\subsection{Miglioramenti e limitazioni di Kerberos v5}

Al contrario della versione 4 che usa la cifratura simmetrica DES,
la versione successiva permette di adottare qualunque sistema di cifratura;
inoltre Kerberos v5 non dipende dal protocollo IP, usa uno stile fisso
per l'ordinamento dei Byte nel messaggio, specifica esplicitamente
inizio e fine validità per i token e infine permette l'inoltro dell'autenticazione
(un server a cui è autenticato un client può autenticarsi a sua volta
a un'altro server).

\chapter{Certificati e protocolli di rete}

\section{Infrastruttura a chiave pubblica (PKI)}

\subsection{PKI e certificati}

Nella cifratura a chiave pubblica, la chiave usata per cifrare è pubblica
e disponibile a tutti; la chiave per decifrare è privata (non viene
condivisa) e anche se ricavabile dalla pubblica, il costo computazionale
rende il problema irrisolvibile in pratica. Il punto debole di questo
meccanismo è la fiducia nella chiave pubblica: proprio perché si tratta
di una informazione pubblica, è necessario che sia autenticata.

Questo problema viene risolto dall'infrastruttura a chiave pubblica
(public key inrastructure, PKI), un insieme di procedure e regole
per generare, pubblicare e certificare le chiavi pubbliche; essa si
basa su \emph{certificati} (documenti elettronici) che legano la chiave
pubblica all'entità che l'ha generata; un certificato garantisce quindi
l'autenticità di una chiave.

Il processo che determina la validità di un certificato si chiama
\emph{validazione}; questo implica che sarà necessario fidarsi di
un'autorità di certificazione (certification authority, CA) che emette
certificati firmati da lei stessa.

Possiamo classificare i certificati nel modo seguente:
\begin{itemize}
\item i \emph{certificati d'identità} forniscono e garantiscono le informazioni
sull'identità di un'entità (indirizzo, chiave pubblica, ecc\ldots);
\item i \emph{certificati credenziali} forniscono e garantiscono le informazioni
sui diritti di accesso e di autorizzazione per un servizio o risorsa.
\end{itemize}

\subsection{Fidarsi di un certificato}

Tra le informazioni contenute in un certificato, quelle principali
sono il nome del soggetto del certificato, la sua chiave pubblica
e una firma (digest) delle due informazioni appena enunciate, firmata
con la chiave privata della CA (tutti hanno la sua chiave pubblica
e possono verificare che sia stata la CA a firmare):
\[
{\scriptstyle \text{CERT}}\left(A\right)\coloneqq E_{CA}\left(A,\,K_{A},\,E_{K_{CA}^{-1}}\left(h\left(A,\,K_{A}\right)\right)\right)
\]
La chiave pubblica delle CA di livello più alto viene inserita nel
browser o nel sistema operativo, dunque bisognerà riporre fiducia
in questi software per fidarsi delle chiavi con le quali sono distribuiti;
in ogni caso, fidarsi della CA implica soltanto il riporre fiducia
nelle informazioni che essa ha firmato, non vuol dire fidarsi della
CA in quanto praticamente affidabile.

Dal momento che le CA di alto livello sono poche e le entità che vogliono
essere certificate sono numerose, spesso le CA firmano certificati
per delle autorità di registrazione (registration authority, RA),
le quali a loro volta possono firmare i certificati di RA di livello
più basso; si viene così a formare una struttura ad albero, che racchiude
catene di fiducia (catene di certificati), e permette di fidarsi del
certificato foglia se si ripone fiducia nel certificato radice.

\subsection{Certificati X.509}

Si tratta di uno standard raccomandato dall'Unione Internazionale
per le Telecomunicazioni (ITU); al contrario degli standard, non si
incorre in sanzioni se non si seguono (è illegale vendere un prodotto
non conforme agli standard approvati dall'ente nazionale di competenza).

La serie di raccomandazioni dell'ITU X.500 specifica il servizio di
rubrica per gli utenti, e X.509 definisce i metodi di autenticazione
per tali utenti, tramite certificati.

I certificati X.509 hanno una struttura costituita dai seguenti campi:
\begin{itemize}
\item versione
\item numero di serie (ogni certificato ha uno univoco, rispetto alla sua
CA emittente);
\item nome della CA;
\item periodo di validità;
\item nome del soggetto (entità di cui si certifica la chiave pubblica);
\item chiave pubblica del soggetto;
\item firma (specifica l'algoritmo di firma).
\end{itemize}
Tramite il numero di serie è possibile revocare un certificato che
non sia ancora scaduto, ponendolo in una lista di revoca; questo pone
il problema di dover controllare le revoche effettuate, attraverso
la lista di revoca che viene salvata periodicamente in una \emph{cache}.
\begin{example}
\emph{Sia dato il certificato dell'utente $A$, costruito secondo
le raccomandazioni X.509:}
\[
{\scriptstyle \text{CERT}}\left(A\right)=\left(A,\,K_{A},\,h_{K_{CA}^{-1}}\left(A,\,K_{A}\right)\right)
\]
\emph{Sappiamo che cifratura e firma usano l'algoritmo RSA con parametri
$n=221$, $K_{CA}=35$, $K_{A}=25$, $A=200$; inoltre la funzione
di hash $h\left(\circ\right)$ è definita come:}
\[
\forall x,\,y\in\mathbb{Z}_{n}\,:\,h\left(x,\,y\right)=\mod{\left(x\oplus\left(y\ll3\right)\oplus\left(y\ll4\right)\right)}n
\]

\emph{Verificare la correttezza dei dati nel contesto dell'algoritmo
RSA.}
\end{example}
$\checked$Controlliamo che $n$ sia valido, controllando che sia
costituito da due fattori primi $p$ e $q$:
\[
n=221=13\cdot17
\]
Calcoliamo ora il suo toziente e il toziente del toziente:
\[
\varphi\left(221\right)=12\cdot16=2^{6}\cdot3=192;\qquad\varphi\left(\varphi\left(221\right)\right)=\varphi\left(192\right)=\left(2^{6}-2^{5}\right)\cdot\left(3-1\right)=64
\]
Verifichiamo che le chiavi pubbliche $K_{CA},\,K_{A}$ siano invertibili
in modulo $\varphi\left(n\right)$:
\[
\begin{array}{c}
\overset{35}{\overbrace{7\cdot5}}\perp\overset{192}{\overbrace{2^{6}\cdot3}}\implies\cgm{35^{-1}}{11}{192}\\
\overset{25}{\overbrace{5^{2}}}\perp\overset{192}{\overbrace{2^{6}\cdot3}}\implies\cgm{25^{-1}}{169}{192}
\end{array}
\]

\emph{Calcolare la firma digitale associata al certificato.}

$\checked$Per prima cosa dobbiamo calcolare il digest della funzione
$h\left(A,\,K_{A}\right)$ esprimendo nome utente e chiave pubblica
associata su 8~bit, applicando la funzione di hash proposta dal quesito:
\[
\begin{array}{ll}
11001000_{2}=200_{10} & \left(A\right)\\
00011001_{2}=25_{10} & \left(K_{A}\right)\\
11001000 & K_{A}\ll3\\
10010001 & K_{A}\ll4
\end{array}
\]
Calcoliamo ora il digest applicando la somma bit a bit:
\[
\begin{array}{rl}
\cancel{11001000} & \oplus\\
\cancel{11001000} & \oplus\\
\underline{10010001} & =\\
10010001 & \left(145\right)
\end{array}
\]
Infine possiamo ottenere la firma di $h\left(200,\,25\right)=145$
usando la chiave $\cgm{K_{CA}^{-1}\equiv25^{-1}}{11}{192}$:
\[
\cgm{145^{11}}{202}{221}
\]

Concludiamo che i valori che costituiscono il certificato sono $C_{A}=\left(200,\,25,\,202\right)$;
possiamo verificare la chiave pubblica tramite la firma contenuta
nel certificato:
\[
\cgm{\left[h_{K_{CA}^{-1}}\left(A,\,K_{A}\right)\right]^{K_{CA}}}{h\left(A,\,K_{A}\right)}n\rightarrow\cgm{202^{35}}{145}{221}
\]
Abbiamo ottenuto nuovamente il digest, verificando la congruenza e
la validità della firma (solo la CA poteva calcolare la firma poiché
solo essa conosce l'inverso di $\mod{K_{CA}}n$). \demo

\section{Protocolli di rete sicuri}

I protocolli di rete sono organizzati a strati, per questo motivo
abbiamo le seguenti alternative nel localizzare i protocolli di sicurezza
sullo \emph{stack di rete}:
\begin{itemize}
\item livello di rete (IPSec);
\begin{itemize}
\item trasparente alle applicazioni e agli utenti;
\item soluzione generale che garantisce la cifratura di tutto il traffico;
\item cifra solamente il traffico selezionato, evitando overhead non necessario.
\end{itemize}
\item livello di trasporto (TLS);
\begin{itemize}
\item usa connessioni TCP per inviare i dati cifrati;
\item deve essere integrato nelle applicazioni specifiche che usano TCP.
\end{itemize}
\item livello applicativo.
\end{itemize}

\subsection{Transport Level Security (TLS)}

Usa TCP per trasportare i dati cifrati, sfruttando le garanzie di
integrità che esso offre; esso è implementato come un insieme di protocolli
basati su TCP, di cui il principale è chiamato \emph{Record Protocol}
(fornisce servizi di trasporto sicuro ai livelli superiori). È documentato
nell'RFC 5246.

Gli altri servizi che si basano sul Record Protocol e costituiscono
TLS sono:
\begin{itemize}
\item Handshake Protocol (negozia le chiavi di sessione);
\item Change Cipher Spec Protocol (cambia o seleziona algoritmo di cifratura
per una connessione);
\item Alert Protocol (distribuisce avvisi sulla connessione TLS agli altri
peer);
\item Heartbit Protocol (mantiene attiva la connessione, ritardando il timeout).
\end{itemize}
Il TLS implementa, oltre al concetto di connessione (già presente
in TCP) anche il concetto di \emph{sessione}: con l'Handshake Protocol
si inizia una sessione, la quale può avere più connessioni al proprio
interno; inoltre la sessione mantiene un set di chiavi che possono
essere usate dalle connessioni instaurate nel suo contesto. Queste
chiavi saranno rinnovate all'apertura di una nuova sessione; il concetto
di sessione evita la negoziazione costosa dei parametri di sicurezza
ad ogni nuova connessione.

Lo stato della sessione è costituito da:
\begin{itemize}
\item identificatore della sessione;
\item certificato X.509 del peer (opzionale);
\item algoritmo di compressione (usato sui dati prima della cifratura);
\item specifica del cifrario (algoritmo per la cifratura);
\item master secret (segreto da 48~Byte condiviso tra client e server);
\end{itemize}
Le singole connessioni possiedono uno stato definito dai seguenti
parametri:
\begin{itemize}
\item numero casuale per server/client (generato per ogni connessione);
\item segreto MAC per il server (usato per autenticare i messaggi del server);
\item segreto MAC per il client (usato per autenticare i messaggi del client);
\item chiave simmetrica del server (chiave simmetrica per cifrare sul server
e decifrare sul client);
\item chiave simmetrica del client (chiave simmetrica per cifrare sul client
e decifrare sul server);
\item vettori di inizializzazione;
\item numeri di sequenza.
\end{itemize}
I servizi che il TLS Record Protocol sono i seguenti:
\begin{lyxlist}{00.00.0000}
\item [{\textbf{Confidenzialità}}] lo Handshake Protocol definisce una
chiave segreta condivisa usa\-ta per la crittografia del \emph{payload}
TLS;
\item [{\textbf{Integrità}}] lo Handshake Protocol inoltre definisce una
chiave segreta usata come codice per autenticare i messaggi (MAC).
\end{lyxlist}
In ordine le operazioni che il Record Protocol effettua sono:
\begin{enumerate}
\item segmentazione dei dati applicativi da inviare sul canale sicuro (c'è
una finestra massima per i pacchetti TLS);
\item i segmenti vengono compressi con l'algoritmo di compressione negoziato
tramite Handshake Protocol;
\item al segmento compresso viene concatenato un HMAC calcolato a partire
dal messaggio da inviare, usando il segreto pattuito con Handshake
Protocol;
\item il frammento compresso con HMAC viene cifrato con l'algoritmo pattuito
tramite Handshake Protocol;
\item al segmento cifrato viene anteposto un \emph{header} TLS per Record
Protocol: esso sarà a sua volta il payload di un pacchetto TCP.
\end{enumerate}
L'header TLS contiene il campo \texttt{Content type} (tipo di contenuto),
che può indicare HTTPS o uno dei quattro protocolli su cui si basa
Record Protocol.

\subsection{Handshake TLS}

L'instaurazione di una sessione TLS è preceduta dal seguente procedimento,
chiamato \emph{handshake}:
\begin{enumerate}
\item client e server stabiliscono i protocolli per l'instaurazione della
chiave, per la cifratura e per l'autenticazione dei messaggi;
\item il server si autentica (eventualmente inviando il proprio certificato)
e invia le chiavi per la cifratura al client;
\item il client si autentica (eventualmente inviando il proprio certificato)
e invia le chiavi per la cifratura al server;
\item client e server scelgono l'algoritmo di cifratura con cui usare le
chiavi instaurate, e l'inizializzazione viene finalizzata.
\end{enumerate}
In generale, considerati un client \textbf{C} e un server \textbf{S},
le chiavi crittografiche vengono generate con la seguente procedura:
\begin{itemize}
\item \textbf{C} invia ad \textbf{S} in chiaro un numero casuale $r_{C}$
di 32~Byte, di cui i primi 4 siano un timestamp;
\item \textbf{S} invia a \textbf{C} in chiaro un numero casuale $r_{S}$
di 32~Byte, di cui i primi 4 siano un timestamp;
\item \textbf{C} invia ad \textbf{S} un numero casuale $S_{{\scriptscriptstyle \text{PM}}}$
di 48~Byte cifrato con RSA e chiamato \emph{pre-master secret};
\item \textbf{C} e \textbf{S} calcolano il numero $S_{{\scriptscriptstyle \text{M}}}$
che dipende dai tre numeri scambiati e si ottiene concatenando i 3
blocchi seguenti:
\[
S_{{\scriptscriptstyle \text{M}}}=\begin{cases}
{\scriptstyle \text{MD5}}\left(S_{{\scriptscriptstyle \text{PM}}}\|{\scriptstyle \text{SHA1}}\left(A\|S_{{\scriptscriptstyle \text{PM}}}\|r_{C}\|r_{S}\right)\right)\\
{\scriptstyle \text{MD5}}\left(S_{{\scriptscriptstyle \text{PM}}}\|{\scriptstyle \text{SHA1}}\left(BB\|S_{{\scriptscriptstyle \text{PM}}}\|r_{C}\|r_{S}\right)\right)\\
{\scriptstyle \text{MD5}}\left(S_{{\scriptscriptstyle \text{PM}}}\|{\scriptstyle \text{SHA1}}\left(CCC\|S_{{\scriptscriptstyle \text{PM}}}\|r_{C}\|r_{S}\right)\right)
\end{cases}
\]
dove ciascuno dei blocchi è costituito da 128~bit (16~Byte);
\item \textbf{C} e \textbf{S} calcolano il proprio blocco di chiavi di sessione
a partire dal segreto $S_{{\scriptscriptstyle \text{M}}}$ (6 chiavi
segrete, la metà per cifrare da client a server e vice-versa);
\begin{itemize}
\item chiave di cifratura;
\item chiave per MAC;
\item vettore di inizializzazione se il cifrario è usato in modo concatenato
(CBC).
\end{itemize}
\end{itemize}

\subsection{HTTPS}

Si tratta di un protocollo applicativo che combina HTTP con TLS per
garantire una comunicazione sicura tra client e server; è documentato
nell'RFC 2818. Quando viene richiesta una risorsa tramite HTTPS, vengono
cifrati i seguenti elementi:
\begin{itemize}
\item l'URL del documento richiesto;
\item il contenuto del documento;
\item i contenuti dei moduli del browser;
\item i \emph{cookie} inviati dal client al server e vice-versa;
\item l'header HTTP.
\end{itemize}
L'agente che ha il ruolo di client HTTP agisce anche come client TLS,
prima avviando un handshake TLS e poi effettuando la richiesta HTTP
tramite il canale sicuro; una connessione HTTP ha tre ``strati'':
\begin{itemize}
\item HTTP
\begin{itemize}
\item un client richiede una connessione HTTP a un server, e tale richiesta
è inviata allo strato inferiore;
\end{itemize}
\item TLS
\begin{itemize}
\item una sessione TLS è stabilita tra client e server;
\item la richiesta per stabilire la connessione comincia con una connessione
allo strato inferiore;
\end{itemize}
\item TCP
\begin{itemize}
\item una connessione è stabilita tra le entità TCP di client e server.
\end{itemize}
\end{itemize}
Infine, possiamo chiudere una connessione HTTPS partendo dallo ``strato''
superiore e terminando ciascuna connessione in cascata verso gli strati
inferiori; a livello di HTTP, la connessione si chiude tramite l'header
\texttt{Connection: close}, mentre a livello di TLS si usa l'Alert
Protocol per inviare l'avviso di chiusura.

Se la connessione HTTPS si interrompe in modo inaspettato sullo strato
TCP, questo può indicare un errore di implementazione o un possibile
attacco: in ogni caso è opportuno mostrare un errore.

\section{Posta elettronica sicura}

\subsection{Simple Mail Transfer Protocol (SMTP)}

All'interno dell'RFC 5598 vi è la specifica dell'architettura per
l'\emph{Internet Email}, fondata su agenti chiamati MTA (Mail Transfer
Agent), che trasferiscono i messaggi tra loro fino a consegnarli alla
destinazione corretta. I messaggi di posta elettronica scambiati usando
questa architettura vengono inviati in chiaro, attraverso una connessione
TCP, tramite il protocollo SMTP (Simple Mail Transfer Protocol).

In pratica, il protocollo si basa su una conversazione tra client
e server, basata su comandi testuali (in codifica ASCII); la porta
predefinita per le connessioni in ingresso a un server SMTP è la numero
25.

\subsection{STARTTLS}

La prima strategia che è stata usata per rendere SMTP sicuro si basava
sull'uso di TLS per cifrare la comunicazione col server: l'RFC 3207
definisce l'estensione dell'SMTP sicuro sopra TLS.

Questa estensione si basa sull'implementazione del comando \texttt{STARTTLS},
utilizzato nel modo seguente:
\begin{itemize}
\item il server risponde all'handshake del client con un codice \texttt{250
STARTTLS}, suggerendo al client l'uso dell'estensione sicura;
\item il client invia al server il comando STARTTLS per avviare la connessione
sicura tramite TLS; il server assegnerà la porta 587 alla connessione
\\\texttt{SMTP~+~TLS};
\item se il server risponde col codice \texttt{220}, viene instaurata una
connessione TLS tra le due parti.
\end{itemize}
Esiste un approccio differente (deprecato) implementato sotto forma
di SMTPS, che utilizza una connessione TLS sulla porta 465 del server
e all'interno di essa viene effettuata la comunicazione SMTP. 

\subsection{Post Office Protocol (POP3)}

Se vogliamo interrogare il server con la nostra casella email (MTA)
per scaricare i messaggi di posta e cancellarli dal server, possiamo
usare il protocollo per la ricezione POP3; esso sfrutta una connessione
sulla porta standard 110, trasferendo in chiaro ciascuna informazione
(anche la password!); per questo motivo è stata introdotta l'estensione
con l'implementazione del comando STARTTLS, la quale permette di instaurare
una connessione cifrata dopo l'handshake iniziale.

Esiste anche la variante POP3S, che permette di collegarsi al server
tramite una connessione TLS sulla porta 995.

\subsection{Internet Mail Access Protocol (IMAP)}

Se \marginpar{In generale, IMAP offre più funzioni e autenticazione più forte rispetto
a POP3}vogliamo controllare i messaggi di posta presenti nella casella email
senza rimuoverli dal server (MTA), allora possiamo usare il protocollo
IMAP, connettendoci con TCP alla porta 143 del server e inviandogli
i comandi adatti; è opportuno utilizzare l'estensione sicura di IMAP,
che sfrutta l'implementazione del comando STARTTLS.

Possiamo inoltre usare la variante IMAPS, che permette di collegarci
al server tramite una connessione TLS sulla porta 993.

\subsection{Struttura dei messaggi}

L'RFC 5322 definisce gli standard per i messaggi testuali di posta
elettronica, caratterizzati dalla suddivisione del contenuto (solo
testuale, ASCII a 7bit) in \emph{envelope} (comprende i metadati come
data di invio, mittente, destinatario, ecc\ldots) e \emph{content}
(comprende il testo del mesaggio vero e proprio).

Successivamente, per risolvere il problema dell'invio di file binari
che avessero biso\-gno di una codifica a 8bit rispetto ai 7bit concessi
da ASCII, è stata aggiunta l'estensione \textbf{MIME} (Multipurpose
Internet Mail Extension) al protocollo SMTP: essa permette di convertire
una codifica in 8bit in un'altra solo testuale a 7bit, permettendo
il trasferimento di file binari e digitali attraverso il protocollo
SMTP.

\subsection{Minacce alla sicurezza della posta elettronica}

Possiamo riassumere le minacce alla sicurezza dell'Internet Email
nelle seguenti categorie:
\begin{enumerate}
\item \noun{Autenticità}: il mittente potrebbe non essere quello rappresentato
dal metadato nell'header del messaggio;
\item \noun{Integrità}: il messaggio che è arrivato al destinatario potrebbe
essere stato modificato durante l'inoltro tra i Mail Transfer Agent;
\item \noun{Confidenzialità}: il contenuto del messaggio potrebbe essere
stato letto da un soggetto differente da quello associato all'account
del destinatario;
\item \noun{Disponibilità}: potrebbe essere possibile negare agli utenti
la disponibilità del servizio di inoltro e consegna dei messaggi.
\end{enumerate}
Per risolvere o mitigare questi problemi, sono state introdotte le
seguenti estensioni o varianti dei protocolli mostrati in precedenza:
\begin{itemize}
\item usare STARTTLS sia per l'SMTP sia per la ricezione dei messaggi (POP
/ IMAP), garantendo autenticità, integrità, confidenzialità e non-ripudio;
\item usare S/MIME per trasmettere file binari garantendo l'integrità del
contenuto del messaggio;
\item usare DNSSEC per garantire autenticità e integrità della comunicazione
col servizio DNS per determinare il Mail Transfer Agent col quale
comunicare;
\item usare DANE per autenticare le chiavi pubbliche associate ai nomi dei
domini;
\item usare SPF per autorizzare solo a un determinato intervallo di indirizzi
IP per essere mittenti verso un server mail specifico;
\item usare DKIM per permettere a un MTA di firmare campi specifici dell'header
e il contenuto di un messaggio, e di verificare la sua integrità;
\item usare DMARC per segnalare ai mittenti l'efficacia delle loro politiche
SPF e DKIM, e segnalare ai destinatari quali azioni è opportuno intraprendere
nel caso di vari scenari di attacchi.
\end{itemize}

\subsection{Pretty Good Privacy (PGP)}

Sistema alternativo all'S/MIME, che offre delle funzionalità simili
ma le implementa diversamente; in particolare S/MIME si basa su certificati
per autenticare gli utenti, mentre PGP usa il principio del ``\emph{web
of trust}'' (si si fida della chiave pubblica firmata da qualcuno
di cui ci si fida).

PGP permette di autenticare e cifrare i messaggi, combinando anche
queste funzionalità; esse sono realizzate come segue.

\subsection*{Autenticazione del messaggio}
\begin{enumerate}
\item \textbf{A} calcola il digest $\overline{m}$ del messaggio $m$ da
autenticare (per esempio) usando l'hash SHA-1;
\item \textbf{A} firma il digest, usando (di solito) RSA, elevando $\overline{m}$
all'esponente segreto $\mod dn$;
\item \textbf{A} invia a \textbf{B} in chiaro la firma del digest $\mod{\overline{m}^{d}}n$;
\item \textbf{B} si fida della chiave pubblica di \textbf{A}, e verifica
la firma ricevuta elevandola all'esponente pubblico $\mod en$ e poi
confrontando il risultato col digest del messaggio;
\item Se $\mod{\left(\overline{m}^{d}\right)^{e}}n$ corrisponde al digest
del messaggio $m$ e \textbf{B} si fida della chiave pubblica di \textbf{A},
il messaggio è considerato autenticato e viene accettato.
\end{enumerate}

\subsection*{Cifratura del messaggio}
\begin{enumerate}
\item \textbf{A} genera la chiave di sessione simmetrica $k_{s}$ come un
numero casuale di 128 bit (essa sarà usata una volta sola);
\item \textbf{A} cifra il messaggio $m$ con la chiave di sessione con 3DES,
poi cifra la chiave di sessione $k_{s}$ con RSA;
\item \textbf{A} invia $m$ e $k_{s}$ cifrati a \textbf{B};
\item \textbf{B} decifra la chiave di sessione $k_{s}$ e a sua volta usa
la chiave di sessione per decifrare il messaggio $m$.
\end{enumerate}
In questo algoritmo di cifratura viene usata una chiave simmetrica
per cifrare il messaggio, per velocizzare la decifratura (la sicurezza
dell'algoritmo non viene compromessa da questa scelta, poiché la chiave
simmetrica è comunque inviata dopo essere stata cifrata con RSA).
Si osserva che non è richiesta la fiducia nel mittente del messaggio.

\subsection*{Autenticazione e cifratura}
\begin{enumerate}
\item \textbf{A} \marginpar{Scegliamo di firmare prima e cifrare poi per mitigare alcuni tipi
di attacchi; per maggiori informazioni fare riferimento al seguente
articolo: \emph{\protect\href{http://world.std.com/~dtd/sign_encrypt/sign_encrypt7.html}{Defective Signs \& Encryption}}\footnotemark}calcola il digest $\overline{m}$ del suo messaggio $m$, e firma
il digest con RSA, ottenendo $\text{sig}\left(\overline{m}\right)\coloneqq\mod{\overline{m}^{d}}n$;
\item \textbf{A} genera una chiave di sessione simmetrica $k_{s}$ con 128
bit casuali;
\item \textbf{A} cifra $\text{sig}\left(\overline{m}\right)\|m$ tramite
chiave di sessione $k_{s}$ usando (per esempio) 3DES, poi cifra $k_{s}$
tramite RSA;
\item \textbf{A} invia messaggio con firma e chiave di sessione cifrati
a \textbf{B};
\item \textbf{B} decifra la chiave di sessione $k_{s}$ (tramite la propria
chiave privata), e a sua volta la usa per decifrare il messaggio con
firma;
\item \textbf{B} verifica che la firma RSA $\text{sig}\left(\overline{m}\right)$
corrisponda a quella del messaggio $m$ (usando la chiave pubblica
di \textbf{A}).
\end{enumerate}
\footnotetext{\url{http://world.std.com/~dtd/sign_encrypt/sign_encrypt7.html}}

\section{IPSec}

Protocollo di sicurezza per il livello di rete, che fornisce il servizio
di trasporto dei pacchetti IP in maniera sicura; risulta trasparente
ai livelli superiori dello stack di rete. Questo protocollo ricopre
tre aree funzionali:
\begin{itemize}
\item \emph{autenticazione}: verifica del mittente e dell'integrità dei
pacchetti;
\item \emph{confidenzialità}: il contenuto dei pacchetti è cifrato;
\item \emph{gestione delle chiavi}: scambio sicuro delle chiavi affidabili.
\end{itemize}
IPSec prevede varie applicazioni e tipi di trasporto differenti; noi
siamo interessati al tunneling.

\subsection{Tunneling}

Consiste nel prendere un pacchetto IP, cifrarlo, au\-tenticarlo,
e usarlo come payload di un'altro pacchetto IP; questo nuovo pacchetto
ha la struttura di un pacchetto IP, dunque può viaggiare in una rete
di dispositivi che non conoscono necessariamente IPSec.

La comunicazione in \emph{tunnel mode} viene realizzata da una funzione
combinata di au\-tenticazione e cifratura chiamata \emph{ESP} (Encapsulating
Security Payload, il pacchetto ESP diventa payload del pacchetto autenticato),
assieme allo scambio delle chiavi.

In pratica la tunnel mode realizza una \emph{VPN} sicura (Virtual
Private Network, rete privata virtuale) attraverso Internet.

Oltre a poter mettere in sicurezza tutto il traffico perimetrale di
una rete se implementato su un \emph{firewall} ed essere trasparente
a utenti e applicazioni, IPSec viene applicato per mettere in sicurezza
il traffico dei protocolli di routing (come OSPF).

\subsection*{Transport mode}

In questa modalità di funzionamento, IPSec fornisce protezione ai
protocolli di livello superiore, ovvero il payload dei pacchetti IP
viene estratto e cifrato. Al contrario, la tunnel mode protegge l'intero
pacchetto IP, compreso l'header e altri metadati.

\subsection*{Tunnel mode}

Per realizzare questa modalità di funzionamento la specifica prevede
di:
\begin{itemize}
\item aggiungere al pacchetto IP campi addizionali per il protocollo ESP;
\item l'intero pacchetto IP insieme ai campi addizionali sono cifrati e
considerati il payload di un nuovo pacchetto IP;
\item nessun dispositivo intermedio è in grado di osservare il payload di
questo pacchetto;
\item ESP cifra e (opzionalmente) autentica il pacchetto IP interno (payload).
\end{itemize}
Se i due nodi che comunicano via IPSec sono parte di una SA (Security
Association, per esempio due \emph{gateway}, router o firewall che
implementano IPSec), i nodi ad essi connessi sulla rete locale non
hanno necessità di implementare IPSec.

\subsection{Security policy}

La cifratura e l'autenticazione in IPSec viene determinata pacchetto
per pacchetto, in base a un'insieme di regole chiamato \emph{security
policy}; queste regole sono determinate dall'interazione tra due database:
\begin{itemize}
\item SAD (Security Association Database): memorizza le SA registrate e
i parametri SPI corrispondenti;
\item SPD (Security Policy Database): memorizza le regole relative a ciascuna
SA, sotto forma di sottoinsiemi di traffico IP e relazioni uno-a-molti.
\end{itemize}
In ciascun pacchetto IP, la SA corrispondente è identificata da indirizzo
di destinazione e i parametri SPI (Security Parameters Index) nell'header
dell'estensione ESP; 

\subsection{Internet Key Exchange (IKE)}

Insieme di protocolli per generare e trasferire le chiavi necessarie
alla comunicazione sicura con IPSec; in particolare, vengono usati
certificati X.509 e lo scambio Diffie-Hellman per instaurare un segreto
di sessione condiviso, derivando due paia di chiavi per ciascuna comunicazione
(una chiave per trasmissione e una per ricezione, due paia per ridondanza).

Per configurare una SA si usano:
\begin{itemize}
\item il protocollo di instaurazione della chiave di Oakley (generico, simile
a Diffie-Hellman);
\item il protocollo di instaurazione delle SA chiamato ISAKMP (RFC 2408),
che fornisce un \emph{framework} per lo scambio delle chiavi e per
l'autenticazione.
\end{itemize}

\appendix

\chapter{Introduzione alla crittografia}

\subsection*{Cenni storici}

Il termine crittografia deriva dal greco $\kappa\rho\nu\pi\tau\acute{o}\zeta$
(krypt$\acute{\text{o}}$s - segreto) e $\gamma\rho\alpha\varphi\acute{\eta}$
(grafi - scrittura); tra gli esempi di crittografia dal passato il
più famoso è il cifrario di Cesare: si tratta di un cifrario a scorrimento
ciclico, che consisteva nello scrivere le lettere dell'alfabeto su
due anelli per poi ruotarne uno rispetto all'altro di $k=+3$ posizioni;
in questo modo si ottiene $A\rightarrow D,\,B\rightarrow E,\,\ldots Z\rightarrow C$.

Non si trattava di un cifrario robusto, ma veniva usato quando gli
avversari dell'Impero Romano erano i Galli: si rivelò un metodo più
che sufficiente.

\subsection*{Comunicazione sicura}

In generale una comunicazione sicura tra due parti si svolge nel modo
seguente: sia $A$ il mittente del messaggio, $B$ il destinatario,
ed $E$ un intruso che abbia accesso al canale di comunicazione. L'intruso
può essere \emph{passivo} (intercetta i messaggi senza modificarne
il flusso) oppure \emph{attivo} (modifica il contenuto dei messaggi).

\begin{figure}[!h]
\begin{centering}
\includegraphics[scale=1.3]{\string"Illustrazioni/A_1 Scenario fondamentale di comunicazione\string".pdf}
\par\end{centering}
\caption{Scenario fondamentale di comunicazione}
\label{fig:Scenario-fondamentale- comunicazione}
\end{figure}

$\boldsymbol{A}$ invia un \emph{plaintext} $m$ (testo in chiaro),
lo codifica usando una funzione di cifratura (un algoritmo crittografico)
che prende in ingresso anche la sua chiave $k_{{\scriptscriptstyle \text{A}}}$
e ottiene un \emph{ciphertext $c$} (messaggio cifrato); il messaggio
$c$ giunge a $\boldsymbol{B}$, il quale usa una funzione di de-cifratura
\textemdash~tramite la sua chiave $k_{{\scriptscriptstyle \text{B}}}$,
che è associata in qualche modo alla chiave $k_{{\scriptscriptstyle \text{A}}}$
\textemdash~per ottenere nuovamente il \emph{plaintext} $m$ inviato
da \textbf{$\boldsymbol{A}$}.

$\boldsymbol{E}$ potrebbe avere le seguenti intenzioni malevole rispetto
alla comunicazione tra $\boldsymbol{A}$ e $\boldsymbol{B}$:
\begin{itemize}
\item leggere il messaggio e comprenderne il contenuto;
\item ottenere la chiave;
\item corrompere il contenuto del messaggio;
\item impersonare $A$ senza che $B$ se ne accorga.
\end{itemize}
L'intruso può mettere in atto i seguenti tipi di attacchi sull'algoritmo
di cifratura usato nella comunicazione:
\begin{itemize}
\item \noun{ciphertext-only}: avendo a disposizione il testo cifrato, si
cerca di ricavarne delle informazioni (attacco più comune);
\item \noun{known plaintext}: avendo a disposizione una coppia di testo
cifrato e testo in chiaro corrispondente, si confrontano i due cercando
di ottenere informazioni sulla chiave;
\item \noun{chosen plaintext}: avendo a disposizione la stessa implementazione
dell'algoritmo utilizzato per cifrare il messaggio, si scelgono dei
testi in chiaro da cifrare e si osservano i testi cifrati in uscita,
per cercare di ricavare informazioni sull'implementazione;
\item \noun{chosen ciphertext}: avendo a disposizione la stessa implementazione
dell'algoritmo utilizzato per decifrare il messaggio, si scelgono
dei testi cifrati da decifrare e si osservano i testi in chiaro in
uscita, per cercare di ricavare informazioni sull'implementazione.
\end{itemize}

\subsection*{Sicurezza e segretezza}

Giulio Cesare basava la sicurezza del proprio algoritmo di cifratura
sul fatto che i possibili avversari non ne conoscessero il funzionamento;
il crittografo olandese Auguste Kerckhoffs, enunciò ne \emph{`La cryptographie
militaire'} (1883) il principio di Kerchoffs:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Principio di Kerchoffs}{\footnotesize{}\index{Kerchoffs, principio di@{\footnotesize{}Kerchoffs, principio di}}\label{thm:Principio-di-Kerchoffs}}}[0.7cm]
\begin{center}
\begin{minipage}[t]{0.8\textwidth}%
\begin{center}
\emph{La sicurezza di un sistema di cifratura è basata sulla segretezza
della chiave (assumere sempre che il nemico conosca l'algoritmo di
cifratura)}
\par\end{center}%
\end{minipage}
\par\end{center}

Da questa considerazione segue che la chiave utilizzata deve essere
lunga, complessa, e in generale essere costruita per evitare che sia
possibile indovinarla.

Claude Elwood Shannon, che scrisse cinque articoli che cambiarono
la storia della comunicazione dell'informazione, tra cui un articolo
sulla crittografia\footnote{\emph{``Communication Theory of Secrecy Systems'' }(1949), Bell
System Technical Journal}, espresse lo stesso principio in maniera molto incisiva con le parole
``Il nemico conosce il sistema'' (frase nota come massima di Shannon).

È interessante notare come si è passati dal fondare la sicurezza del
sistema sulla segretezza dell'algoritmo alla segretezza della chiave;
il passo successivo fu il sistema a \emph{chiave pubblica}: gli algoritmi
usati sono noti e accessibili a tutti, e una chiave del mittente (quella
pubblica) è resa nota a tutti; tramite la chiave pubblica è possibile
cifrare i messaggi, tuttavia la chiave per decifrare, associata alla
chiave pubblica, è mantenuta riservata (si parla di\emph{ chiave privata}).

Fondamentale è il fatto che, non ostante esista una regola (formula
o algoritmo) che permetta di associare la chiave pubblica a quella
privata, per un intruso qualunque è impossibile, dal punto di vista
computazionale, risalire alla chiave privata attraverso quella pubblica.
Solo il mittente che possiede la chiave privata è in grado di computare
questa associazione, poiché egli deve aver ricavato la chiave pubblica
a partire da quella privata (l'operazione inversa risulta molto più
difficile).

\subsection*{Algoritmi noti}

Gli algoritmi a chiave simmetrica hanno una coppia di chiavi, per
cifratura e de-cifratura, che sono entrambe segrete: DES, AES; si
pone il problema di scambiare col destinatario la chiave di de-cifratura,
utilizzando un canale sicuro.

Con i sistemi di cifratura a chiave pubblica questo problema non si
pone, tuttavia si pone il nuovo problema dell'autenticità delle chiavi
pubbliche in circolazione; è stato introdotto il meccanismo dei certificati,
da associare alle chiavi pubbliche, per garantire la loro provenienza
e affidabilità.

\subsection*{Numeri interi grandi}

Lavoreremo prevalentemente con numeri interi (positivi e negativi)
di elevato ordine di grandezza; ecco un esempio per effettuare un
calcolo approssimato.
\begin{example}
\emph{\label{ex:grandi-interi-approssimati}Calcolare in modo approssimato
il valore di $2^{35}$.}

\emph{$\checked$}Sfruttando le proprietà delle potenze e la costante
informatica $2^{10}\sim1000=10^{3}$, possiamo ragionare nel modo
seguente:
\[
2^{35}=2^{30}\cdot2^{5}=\left(2^{10}\right)^{3}\cdot32\simeq\left(10^{3}\right)^{3}\cdot32=\boxed{32\times10^{9}}
\]
\demo
\end{example}
Trattare interi grandi è importante nell'ambito degli algoritmi di
cifratura: prendendo l'algoritmo a chiave simmetrica DES come esempio,
è ragionevole pensare che una chiave di 56 bit non sia sufficientemente
sicura; usando le considerazioni fatte nell'Esempio \ref{ex:grandi-interi-approssimati}
otteniamo che $2^{56}\simeq10^{16}$, ed essendo in possesso di una
macchina in grado di ottenere una chiave in 1$ns$, allora sarebbero
necessari 27 mesi per ottenere questa chiave; ovviamente si può ridurre
questo tempo aumentando il numero di macchine impiegate.

Al giorno d'oggi sono considerate sicure chiavi a 265 bit ($\sim10^{77}$):
per analizzare in modo esaustivo un simile spazio delle chiavi sarebbero
necessari $10^{60}$ anni, nelle condizioni descritte in precedenza!

\chapter{Campi di Galois}

\section{Costruzione con polinomi}

Per comprendere la struttura e le proprietà dei campi di Galois, analizziamo
il seguente esempio: sia dato l'insieme $\mathcal{GF}\left(4\right)=\left\{ 0,\,1,\,\omega,\,\omega^{2}\right\} ,$che
chiamiamo ``campo di Galois 4''; su questo insieme siano definite
le seguenti proprietà, posto $\forall x\in\mathcal{GF}\left(4\right)$:
\begin{enumerate}
\item Ogni elemento del campo ha un inverso additivo: $x+0=x$;
\item $x+x=0$;
\item Ogni elemento del campo ha un inverso moltiplicativo: $1\cdot x=x$;
\item $\omega+1=\omega^{2}$;
\item somma e prodotto godono delle proprietà commutativa, associativa e
distributiva.
\end{enumerate}
Usando queste proprietà possiamo calcolare $\omega^{2}+1\overset{{\scriptscriptstyle 4}}{\rightarrow}\omega+1+1\overset{{\scriptscriptstyle 2}}{\rightarrow}\omega$.
Notiamo dalle proprietà enunciate, che con 0 indichiamo l'elemento
neutro rispetto alla somma e con 1 l'elemento neutro rispetto al prodotto;
rispetto alla somma inoltre, ogni elemento è l'inverso di sé stesso.
L'inverso moltiplicativo invece, non è definito per 0, e vale 1 per
l'elemento 1; negli altri casi, ($\omega$ e $\omega^{2}$) si ha
che l'inverso è $\omega^{2}$; infatti si ricava che 
\[
\omega\cdot\omega^{2}=\omega\cdot\left(\omega+1\right)=\omega+\omega^{2}=\omega+\omega+1=1\implies\omega\cdot\omega^{2}=1\implies\boxed{\omega^{-1}=\omega^{2}}
\]
Vale alche l'opposto, ovvero l'inverso di $\omega^{2}$ è $\omega$.

Possiamo enunciare la definizione di \emph{campo}:
\begin{defn}
\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Campo}{\footnotesize{}\index{Campo@{\footnotesize{}Campo}}\label{def:Campo}}}[-0.2cm]Un campo è un insieme che abbia almeno una operazione di
somma e una di prodotto, includa come minimo gli elementi 0 e 1, dove
0 è l'elemento neutro rispetto alla somma e 1 l'elemento neutro rispetto
al prodotto; l'insieme deve soddisfare inoltre le proprietà ${\scriptstyle \left(1\right)}$,
${\scriptstyle \left(3\right)}$ e ${\scriptstyle \left(5\right)}$
tra quelle elencate in precedenza.
\end{defn}
Questo implica che un insieme che soddisfa la definizione di campo
sarà chiuso rispetto alle operazioni di somma e prodotto.
\begin{example}
L'insieme dei numeri reali forma un campo, infatti in esso sono contenuti
0 e 1, e per ciascun numero reale esiste un inverso definito all'interno
dell'insieme.

L'insieme degli interi non è un campo, poiché l'inverso degli elementi
non appartiene all'insieme.

Consideriamo l'insieme $\mathbb{Z}_{p}$ con $p$ un primo, e l'insieme
$\mathbb{Z}_{n}$ con $n$ composto: il primo è un campo, mentre il
secondo no, dato che i suoi elementi hanno inverso moltiplicativo
solo se primi relativi rispetto a $n$.

Infine, l'insieme delle matrici $2\times2$ non forma un campo, perché
non gode della proprietà commutativa e non tutti i suoi elementi sono
invertibili.\demo
\end{example}
Vale in generale la seguente proprietà, che lega i campi di Galois
alla cardinalità degli insiemi di interi:
\begin{defn}
Per ogni intero, esprimibile come potenza di un primo, esiste esattamente
un solo campo finito di $p^{n}$ elementi, chiamato campo di Galois
$p^{n}$:
\begin{equation}
\forall p^{n}\exists!\,\mathcal{GF}\left(p^{n}\right)\tc\left|\mathcal{GF}\left(p^{n}\right)\right|=p^{n}\label{eq:GF-p^n-cardinalit=0000E0}
\end{equation}
\end{defn}
Possiamo domandarci se l'insieme dei residui modulo $p^{n}$ ($\mathbb{Z}_{p^{n}}$)
sia un campo di Galois: esso non lo è, perché solo i suoi elementi
primi relativi rispetto a $p^{n}$ ammettono inverso. Usiamo la seguente
procedura, che permette di costruire in generale un insieme che sia
un campo $\mathcal{GF}\left(p^{n}\right)$ tramite l'impiego dei polinomi
(avremmo potuto rappresentare il campo di Galois tramite qualsiasi
simbolo di qualunque alfabeto).

Usiamo l'insieme dei residui modulo $p$, e l'insieme di tutti i polinomi
nella variabile $x$, di qualunque grado, con coefficienti modulo
$p$: 
\[
\mathbb{Z}_{p},\quad\mathbb{Z}_{p}\left[x\right]=\serie{i=0}n{a_{i}x^{i}}\,\forall a_{i}\in\mathbb{Z}_{p}
\]
prendiamo un polinomio $P\left(x\right)$ di grado $n$, con coefficienti
$a_{i}$ in $\mathbb{Z}_{p}$, che sia irriducibile (impossibile da
scomporre nel prodotto di polinomi di grado inferiore).
\begin{example}
Prendiamo $p=2$, $n=2$. Scriviamo allora $P\left(x\right)=\mod{x^{2}+1}2$

Notiamo che $P\left(x\right)$ è riducibile, infatti $\cgm{x^{2}+1}{\left(x+1\right)\cdot\left(x+1\right)}2$.

Invece, possiamo usare il polinomio irriducibile $x^{2}+x+1$ per
definire $\mathcal{GF}\left(4\right)$. Per provare che un polinomio
sia riducibile o meno è necessario provare la divisione tra polinomi,
tenendo presente che le operazioni sono modulo $p$, provando tutti
i possibili divisori fino al grado $n/2$.\demo
\end{example}
\begin{rem}
\label{oss:Analogia-GF-insieme-residui}Adesso definiamo il campo
di Galois $p^{n}$ nel modo seguente:
\begin{equation}
\mathcal{GF}\left(p^{n}\right)=\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}\label{eq:GF-p^n-definizione}
\end{equation}
Possiamo osservare un'analogia con l'insieme dei resti interi modulo
$p$:
\end{rem}
\begin{flushleft}
\begin{table}[!h]
\begin{tabular}{>{\centering}p{0.4\textwidth}>{\centering}p{0.4\textwidth}}
primo $p$ & irriducibile $P\left(x\right)$\tabularnewline
\hline 
$\mathbb{Z}_{p}$ & $\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}$\tabularnewline
residui della divisione per un \uline{primo} $p$ & residui della divisione per un polinomio \uline{irriducibile} $P\left(x\right)$
di grado $n$\tabularnewline
\hline 
cardinalità $p$ & cardinalità $p^{n}$\tabularnewline
\end{tabular}
\end{table}
Un generico polinomio ottenuto secondo questa costruzione è al massimo
di grado $n-1$, essendo il resto di una divisione per un polinomio
di grado $n$; possiamo scrivere il polinomio $P\left(x\right)$ nella
seguente forma:
\[
P\left(x\right)=a_{n-1}\cdot x^{n-1}+a_{n-2}\cdot x^{n-2}+\ldots+a_{1}\cdot x+a_{0}
\]
I possibili polinomi di questa forma sono $p^{n}$, dato che ogni
singolo coefficiente è in modulo $p$, e si hanno in totale $n$ coefficienti.
\par\end{flushleft}

\begin{rem}
Qualunque polinomio appartenente a un campo di Galois ammette inverso.
Prendiamo dunque $a\left(x\right)\in\mathcal{GF}\left(p^{n}\right)$,
definito come descritto in questa sezione, l'inverso di $a\left(x\right)$
è l'elemento $a^{-1}\left(x\right)\in\mathcal{GF}\left(p^{n}\right)$
tale che
\[
\cgm{a^{-1}\left(x\right)\cdot a\left(x\right)}1{P\left(x\right)}
\]
Questo vale se $\mcd{a\left(x\right)}{P\left(x\right)}=1$, ma ciò
è sicuramente vero perché $P\left(x\right)$ è definito irriducibile;
se avessimo un polinomio composto (riducibile) al posto di $P\left(x\right)$,
avremmo un'analogia con l'insieme $\mathbb{Z}_{n}$ ($n$ composto),
nel quale solo gli elementi primi relativi rispetto a $n$ hanno l'inverso.
\end{rem}
%
\begin{rem}
Per definire un campo di Galois $p^{n}$ abbiamo bisogno di un polinomio
irriducibile di grado $n$; tuttavia vi è più di un solo polinomio
irriducibile, fissato il grado. Si verifica che, usando polinomi irriducibili
diversi dello stesso grado, si ottiene lo stesso campo di Galois da
entrambi: esso è uno e uno solo, da (\ref{eq:GF-p^n-cardinalit=0000E0}).

Dal punto di vista algebrico, si ottengono due campi \emph{isomorfi},
ovvero le relazioni biunivoche tra elementi di uno stesso insieme
coincidono con quelle dell'altro insieme.
\end{rem}
\begin{defn}
Un campo di Galois può essere definito tramite i resti $R\left(x\right)$
che derivano dalla divisione dei polinomi di qualunque grado $\mathbb{Z}_{p}\left[x\right]$
per il polinomio irriducibile $P\left(x\right)$:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Campo di Galois}{\footnotesize{}\index{Galois, campo di@{\footnotesize{}Galois, campo di}}}}[0.2cm]
\begin{equation}
\mathcal{GF}\left(p^{n}\right)\doteq\cgm{R\left(x\right)}{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}\label{eq:GF-p^n-residui}
\end{equation}
\end{defn}

\section{Polinomi come elementi generatori}

Come visto nell'Osservazione \ref{oss:Analogia-GF-insieme-residui},
il grado massimo di $R\left(x\right)$ sarà $n-1$, mentre i possibili
polinomi di grado fino a $n-1$ sono in totale $p^{n}$. Nella stessa
Osservazione, abbiamo mostrato un'analogia tra l'insieme dei residui
modulo $p$ e i campi di Galois definiti come residui della divisione
dei polinomi con coefficienti modulo $p$, per $P\left(x\right)$.

Possiamo estendere questa analogia al concetto di radice primitiva
(\ref{def:Radice-primitiva}), ovvero anche in $\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}$
ci saranno dei polinomi $g\left(x\right)$, chiamati elementi generatori,
tali che
\[
\cgm{g\left(x\right)^{n}}1{P\left(x\right)}
\]
Il minimo $n$ per il quale si verifica la precedente condizione è
chiamato ordine (\ref{eq:Ordine-di-intero}) del campo, e vale:
\begin{equation}
\ord{g\left(x\right)}=p^{n}-1\label{eq:Ordine-polinomio-irriducibile}
\end{equation}
Questo polinomio $g\left(x\right)$ sarà una radice primitiva del
campo; il numero di radici primitive di un campo sarà determinato
dal toziente dell'ordine, come $\varphi\left(p^{n}-1\right)$

\begin{table}[!h]
\begin{tabular}{>{\centering}p{0.4\textwidth}>{\centering}p{0.4\textwidth}}
$\mathbb{Z}_{p}$ & $\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}$\tabularnewline
\hline 
$\ord{\alpha}=p-1$ & $\ord{g\left(x\right)}=p^{n}-1$\tabularnewline
\hline 
$\varphi\left(p-1\right)$ & $\varphi\left(p^{n}-1\right)$\tabularnewline
\end{tabular}
\end{table}

\begin{rem}
Chiediamoci se esiste un caso in cui tutti gli elementi di un insieme
$\mathbb{Z}_{p}$ sono anche elementi generatori; dovrebbe valere
$\varphi\left(p-1\right)=p-1$, ma questo è impossibile, poiché $q$
è primo e $q-1$ risulta pari.

Nel campo $\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}$ invece
deve valere $\varphi\left(p^{n}-1\right)=p^{n}-1$, e ciò è possibile
poiché $p^{n}-1$ è primo per alcuni $n$, a patto che valga $p=2$
(per esempio, con $p=2$ e $n=5$, vale $p^{n}-1=31$ e il campo $\mathcal{GF}\left(2^{5}\right)$
avrà tutti gli elementi che sono anche generatori del campo).
\end{rem}
\begin{example}
Consideriamo\marginpar{Il polinomio di $\mathcal{GF}\left(256\right)$ mostrato in questo
esempio è quello utilizzato nel cifrario AES} il campo $\mathcal{GF}\left(256\right)$, ovvero $p=2$ e $n=8$;
possiamo definire questo campo a partire da qualunque polinomio irriducibile
$P\left(x\right)$ di grado 8, con i coefficienti modulo 2: prendiamo
\[
P\left(x\right)=x^{8}+x^{4}+x^{3}+x^{2}+x+1
\]
Gli elementi del campo, resti della divisione con $P\left(x\right)$,
avranno grado massimo 7; possiamo scriverli come
\[
R\left(x\right)=b_{7}\cdot x^{7}+b_{7}\cdot x^{7}+\ldots+b_{1}\cdot x+b_{0}
\]
I coefficienti di un polinomio $R\left(x\right)\in\mathcal{GF}\left(256\right)$
sono 8 e sono tutti in modulo 2 (valgono 0 o 1): essi possono essere
rappresentati da un Byte, e l'algoritmo dell'AES usa questa rappresentazione
per effettuare operazioni tra polinomi, all'interno di $\mathcal{GF}\left(256\right)$.
\end{example}

\section{Cardinalità dei polinomi irriducibili}

Abbiamo già concluso che il numero di elementi di un campo di Galois
$p^{n}$ è proprio $p^{n}$ ($\left|\mathcal{GF}\left(p^{n}\right)\right|=p^{n}$);
per definire il campo è necessario un polinomio irriducibile $P\left(x\right)$
di grado $n$ coi coefficienti modulo $p$. Ci chiediamo il numero
di tali polinomi; indichiamo allora il numero di polinomi irriducibili
con coefficienti modulo $p$ e grado $n$ come:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Numero di polinomi irriducibili}{\footnotesize{}\index{Polinomi irriducibili, numero@{\footnotesize{}Polinomi irriducibili, numero}}}}[0.3cm]
\begin{equation}
\nirr pn=\frac{1}{n}\serie{i=1,\,i\backslash n}n{\mu\left(\frac{n}{i}\right)\cdot p^{i}}\label{eq:Numero-polinomi-irriducibili}
\end{equation}
La funzione $\mu\left(\right)$ si chiama funzione di Möbius ed è
definita nel modo seguente:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Funzione di Möbius}{\footnotesize{}\index{Möbius, funzione di@{\footnotesize{}Möbius, funzione di}}}}[0.7cm]
\begin{equation}
\mu\left(n\right)=\begin{cases}
0 & n=\text{ prodotto di primi, almeno uno ripetuto}\\
1 & n=1\\
\left(-1\right)^{k} & n=\text{ prodotto di \ensuremath{k} primi distinti}
\end{cases}\label{eq:Funzione-Mobius}
\end{equation}

\begin{example}
\emph{Prendiamo i polinomi con coefficienti in modulo 2 e grado 6:
determinare il numero di polinomi irriducibili tra di essi.}
\end{example}
$\checked$Sappiamo che il numero totale di polinomi con queste caratteristiche
è $p^{n}=2^{6}=64$; usiamo la formula (\ref{eq:Numero-polinomi-irriducibili}):
\begin{align*}
\nirr 26 & =\frac{1}{6}\left(\mu\left(6\right)\cdot2^{1}+\mu\left(3\right)\cdot2^{2}+\mu\left(2\right)\cdot2^{3}+\mu\left(1\right)\cdot2^{6}\right)\\
 & =\frac{1}{6}\left(2-2^{2}-2^{3}+2^{6}\right)=\frac{54}{6}=\boxed{9}
\end{align*}
Abbiamo usato nella sommatoria i valori da 0 a 6 che dividono 6, ovvero
$i\in\left\{ 1,\,2,\,3,\,6\right\} $.\demo

\renewcommand{\chaptername}{}\printindex
\end{document}
