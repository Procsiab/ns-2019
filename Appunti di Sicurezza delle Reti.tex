%% LyX 2.3.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\RequirePackage{fix-cm}
\documentclass[12pt,italian]{amsbook}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=2cm,bmargin=2.2cm,lmargin=2cm,rmargin=4cm,headheight=2cm,headsep=1cm,footskip=1cm}
\setlength{\parskip}{\smallskipamount}
\setlength{\parindent}{0pt}
\usepackage{babel}
\usepackage{array}
\usepackage{varioref}
\usepackage{refstyle}
\usepackage{units}
\usepackage{textcomp}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{amsbsy}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{cancel}
\makeindex
\usepackage{graphicx}
\usepackage{wasysym}
\PassOptionsToPackage{normalem}{ulem}
\usepackage{ulem}
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=1,
 breaklinks=false,pdfborder={0 0 0},pdfborderstyle={},backref=page,colorlinks=false]
 {hyperref}
\hypersetup{pdftitle={Appunti di Fondamenti di fondamenti di Automatica},
 pdfauthor={Lorenzo Prosseda},
 pdfsubject={Corso di fondamenti di Automatica del prof. Fagiano, Politecnico di Milano 2017-2018},
 pdfkeywords={automatica}}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.

\AtBeginDocument{\providecommand\propref[1]{\ref{prop:#1}}}
\AtBeginDocument{\providecommand\subsecref[1]{\ref{subsec:#1}}}
\AtBeginDocument{\providecommand\secref[1]{\ref{sec:#1}}}
\AtBeginDocument{\providecommand\figref[1]{\ref{fig:#1}}}
\newcommand{\noun}[1]{\textsc{#1}}
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}
\RS@ifundefined{subsecref}
  {\newref{subsec}{name = \RSsectxt}}
  {}
\RS@ifundefined{thmref}
  {\def\RSthmtxt{theorem~}\newref{thm}{name = \RSthmtxt}}
  {}
\RS@ifundefined{lemref}
  {\def\RSlemtxt{lemma~}\newref{lem}{name = \RSlemtxt}}
  {}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{section}{chapter}
\numberwithin{equation}{section}
\numberwithin{figure}{section}
\numberwithin{table}{section}
\theoremstyle{plain}
    \ifx\thechapter\undefined
	    \newtheorem{thm}{\protect\theoremname}
	  \else
      \newtheorem{thm}{\protect\theoremname}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{example}{\protect\examplename}
    \else
      \newtheorem{example}{\protect\examplename}[chapter]
    \fi
\theoremstyle{plain}
    \ifx\thechapter\undefined
      \newtheorem{prop}{\protect\propositionname}
    \else
      \newtheorem{prop}{\protect\propositionname}[chapter]
    \fi
\theoremstyle{remark}
    \ifx\thechapter\undefined
      \newtheorem{rem}{\protect\remarkname}
    \else
      \newtheorem{rem}{\protect\remarkname}[chapter]
    \fi
\theoremstyle{plain}
    \ifx\thechapter\undefined
  \newtheorem{cor}{\protect\corollaryname}
\else
      \newtheorem{cor}{\protect\corollaryname}[chapter]
    \fi
\theoremstyle{plain}
    \ifx\thechapter\undefined
      \newtheorem{fact}{\protect\factname}
    \else
      \newtheorem{fact}{\protect\factname}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{defn}{\protect\definitionname}
    \else
      \newtheorem{defn}{\protect\definitionname}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{problem}{\protect\problemname}
    \else
      \newtheorem{problem}{\protect\problemname}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{xca}{\protect\exercisename}
    \else
      \newtheorem{xca}{\protect\exercisename}[chapter]
    \fi
\theoremstyle{definition}
    \ifx\thechapter\undefined
      \newtheorem{sol}{\protect\solutionname}
    \else
      \newtheorem{sol}{\protect\solutionname}[chapter]
    \fi

\@ifundefined{date}{}{\date{}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{pgfplots}
\usepackage{caption}
\captionsetup{font=scriptsize,labelfont=scriptsize}
\usepackage{geometry}
\usepackage{marginnote}
\usepackage{imakeidx}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{hyphenat}

\renewcommand{\marginpar}[1]{\marginnote{\footnotesize #1}}
\setlength\marginparsep{0.3cm}
\setlength\marginparwidth{3cm}
\newcommand\xqed[1]{%
  \leavevmode\unskip\penalty9999 \hbox{}\nobreak\hfill
  \quad\hbox{#1}}
\newcommand\demo{\xqed{$\square$}}
\newcommand\sln[1]{\xqed{$\scriptstyle Sol.\,#1$}}
\makeindex

\makeatother

\providecommand{\corollaryname}{Corollario}
\providecommand{\definitionname}{Definizione}
\providecommand{\examplename}{Esempio}
\providecommand{\exercisename}{Esercizio}
\providecommand{\factname}{Fatto}
\providecommand{\problemname}{Problema}
\providecommand{\propositionname}{Proposizione}
\providecommand{\remarkname}{Osservazione}
\providecommand{\solutionname}{Soluzione}
\providecommand{\theoremname}{Teorema}

\begin{document}
\newgeometry{margin=1cm}
\title{Appunti di Sicurezza delle reti}
\author{Lorenzo Prosseda, a.a. 2018-2019}
\dedicatory{
\begin{figure}[!h]
\vspace{20cm}
\includegraphics{/home/l3r0/Documenti/Polimi/Automatica/Illustrazioni/gfdl-logo}
\end{figure}
Copyright \textcopyright 2019 Lorenzo Prosseda. Permission is granted
to copy, distribute and/or modify this document under the terms of
the GNU Free Documentation License, Version 1.3 or any later version
published by the Free Software Foundation; with no Invariant Sections,
no Front-Cover Texts, and no Back-Cover Texts. A copy of the license
is included in the file called \textquotedbl LICENSE\textquotedbl .}

\maketitle
\restoregeometry

\tableofcontents{}

\global\long\def\lm#1#2#3{\underset{{\scriptstyle #1\rightarrow#2}}{\lim}#3}%

\global\long\def\serie#1#2#3{\overset{{\scriptstyle #2}}{\underset{{\scriptstyle #1}}{\sum}}#3}%

\global\long\def\somme#1#2#3#4{\underset{{\scriptstyle #1}}{\overset{{\scriptstyle #2}}{\int}}#3d#4}%

\global\long\def\mcd#1#2{\mathrm{{\scriptstyle MCD}}\left(#1,\,#2\right)}%

\global\long\def\mcm#1#2{\mathrm{{\scriptstyle mcm}}\left(#1,\,#2\right)}%

\global\long\def\cgm#1#2#3{#1\equiv#2\left(\text{mod}\,#3\right)}%

\global\long\def\ncgm#1#2#3{#1\not\equiv#2\left(\text{mod}\,#3\right)}%

\global\long\def\cgms#1#2#3#4{#1\overset{#4}{\equiv}#2\left(\text{mod}\,#3\right)}%

\global\long\def\mod#1#2{#1\,\text{mod}\,#2}%

\global\long\def\ord#1{\mathrm{{\scriptstyle ORD}}\left(#1\right)}%

\global\long\def\nirr#1#2{N_{{\scriptscriptstyle irr}}\left(#1,\,#2\right)}%

\global\long\def\logd#1#2{\mathrm{\mathcal{L}_{#1}}\left(#2\right)}%

\global\long\def\tc{\,:\,}%


\part{Crittografia}

\chapter{Teoria dei numeri}

\section{Proprietà degli interi}

Da ora in avanti parleremo di numeri interi, positivi o negativi,
operando all'interno dell'insieme $\mathbb{Z}$; enunciamo la proprietà
di divisione nel modo seguente: presi due interi $a,\,b\in\mathbb{Z}$
non uguali ($a\neq b$) si dice che $a$ divide $b$ quando $a$ è
un divisore di $b$, ovvero
\[
a\backslash b\implies\exists k\tc b=k\cdot a
\]

Dalla precedente deduciamo che $b$ dovrà essere un multiplo di $a$.
Inoltre, otteniamo anche che:
\[
\forall a\in\mathbb{Z}\,:\,a\backslash0;\;\nexists a\in\mathbb{Z}\tc0\backslash a;\;\forall a\in\mathbb{Z}\,:\,a\backslash a
\]

La relazione di divisione introdotta ammette la proprietà transitiva:
\[
\forall a,b,c\in\mathbb{Z}\,\land\,a\neq b\neq c\tc a\backslash b\,\land\,b\backslash c\implies a\backslash c
\]


\section{Numeri primi}

\subsection{Definizione e proprietà}

Un numero $a$ si dice primo quando è divisibile solo per 1 e per
sé stesso (ovvero se vale $\forall b\in\mathbb{Z}\tc b\backslash a\iff b=1\,\lor\,b=a$);
un numero composto è scomponibile in un numero finito di fattori,
e questa scomposizione è unica. Determinare la primalità di un numero
tuttavia non è cosa facile; introduciamo il seguente teorema:
\begin{thm}
Sia $\pi\left(n\right)\coloneqq$``numero di numeri primi fino a
$n$'', allora vale\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema dei numeri primi}{\footnotesize{}\index{Numeri primi, teorema@{\footnotesize{}Numeri primi, teorema}}\label{thm:Numeri-primi}}}[0.1cm]
\[
\pi\left(n\right)\sim\dfrac{n}{\ln\left(n\right)}
\]
\end{thm}
Alcuni algoritmi crittografici usano i numeri primi come ``ingredienti''
per creare le chiavi: in questi casi il teorema introdotto si dimostra
molto utile per determinare la quantità di numeri primi che è possibile
ottenere con una data quantità di cifre.
\begin{example}
Determinare una stima della quantità di numeri primi che è possibile
ottenere a partire da 100 cifre.

$\checked$Usando il Teorema \ref{thm:Numeri-primi} possiamo scrivere
la quantità di numeri primi con 100 cifre come
\[
\pi\left(10^{100}\right)-\pi\left(10^{99}\right)=\frac{10^{100}}{100\ln\left(10\right)}-\frac{10^{99}}{99\ln\left(10\right)}\simeq\boxed{10^{97}}
\]
\demo
\end{example}
Se fossimo nel contesto di un algoritmo di cifratura, pur sapendo
che la chiave sia un numero primo di 100 cifre, dovremmo analizzare
in ogni caso $10^{97}$ possibili candidati.

Prendiamo\marginpar{La funzione $\protect\mcd ab$ indica il massimo comune divisore tra
$a$ e $b$} ora $a,\,b\in\mathbb{Z}$ tali che $\mcd ab=1$: in tal caso diremo
che $a$ e $b$ sono \emph{coprimi} o \emph{primi relativi}, indicando
la loro relazione come $a\perp b$; da questa relazione segue che
due numeri coprimi non hanno fattori in comune.

Escluso il numero 2, tutti i primi sono dispari, e sono divisi in
due classi: preso un numero primo $p$, esso appartiene a una delle
seguenti classi:
\begin{itemize}
\item $\cgm p14$
\item $\cgm p34$
\end{itemize}
L'operatore $\equiv$ indica la congruenza in modulo: si dice che
un numero $a\in\mathbb{Z}$ è \emph{congruente a 1 modulo $n$} (e
si scrive $\cgm a1n$) se il resto della divisione di $a$ per $n$
è 1.

Componendo le due classi osserviamo che tutti i numeri primi $p$
possono essere indicati come 
\begin{equation}
p=6k\pm1\implies\cgm p{\pm1}6,\,k\in\mathbb{Z}\label{eq:Successione-primi-classi}
\end{equation}
Troveremo per esempio $p_{k=1}=6\pm1=\left\{ 5,\,7\right\} ,\,p_{k=2}=12\pm1=\left\{ 11,\,13\right\} ,\,p_{k=3}=18\pm1=\left\{ 17,\,19\right\} ,\,\ldots\,$;
osserviamo che tutti i numeri della successione appena definita sono
primi, tuttavia non tutti i primi appartengono a questa successione.

\subsection{Test di primalità con classi}

Possiamo usare la successione (\ref{eq:Successione-primi-classi})
per testare la primalità di un numero intero: sia $n>0$ un numero
del quale si vuole conoscere la primalità; allora definiamo un algoritmo
iterativo che costruisce la successione (\ref{eq:Successione-primi-classi})
incrementando $k$, e per ogni primo $p_{k}$ ottenuto, se non vale
$p_{k}\backslash n$ fino a che $6k+1\leq\sqrt{n}$, allora $n$ è
primo.

\section{Algoritmo di Euclide}

\subsection{Definizione della successione}

La funzione principale di questo algoritmo, è calcolare il massimo
comune divisore di due numeri; presi due interi $m$ e $n$ tali che
$m<n$, vogliamo calcolare $\mcd mn$. Tramite questo algoritmo otteniamo
il risultato desiderato, senza passare per la scomposizione in fattori
primi di $m$ e $n$; definendo la seguente successione:
\begin{align}
\mcd mn & =\mcd{\mod nm}n\label{eq:Successione-Euclide}\\
 & =\mcd{\mod{\left(\mod nm\right)}n}n\nonumber \\
 & =\mcd 0n=n\nonumber 
\end{align}

Osserviamo come calcolare questa successione con un esempio.
\begin{example}
\emph{Calcolare il massimo comune divisore tra 482 e 1180}

$\checked$Procediamo applicando la definizione (\ref{eq:Successione-Euclide}):
per farlo dovremo scomporre il numero maggiore ($n$ dalla definizione)
usando il suo modulo rispetto al minore ($m$); in pratica prendiamo
1180 e lo dividiamo per 482, conservando il residuo dell'operazione
da usare nel termine successivo della successione
\[
\mcd{482}{1180}\rightarrow1180=2\cdot482+216
\]
proseguiamo lavorando col resto del passo precedente (216) e col valore
precedentemente usato per calcolare il modulo (482)
\begin{align*}
\mcd{216}{482} & \rightarrow482=2\cdot216+50\\
\mcd{50}{216} & \rightarrow216=4\cdot50+16\\
\mcd{16}{50} & \rightarrow3\cdot16+\boldsymbol{2}=\boldsymbol{d}\\
\mcd 2{16} & \rightarrow8\cdot2+\boxed{0}
\end{align*}
La successione termina quando si ottiene resto zero; il resto chiamato
$d$, ottenuto alla penultima riga (sopra a quella con resto 0, vale
2 in questo caso) è effettivamente il risultato della richiesta: $\mcd{482}{1180}=2$\demo
\end{example}

\subsection{Algoritmo in forma simbolica}

Presi $a,\,b\in\mathbb{Z}$ tali che $a<b$, otteniamo $\mcd ab=d$
applicando (\ref{eq:Successione-Euclide}) nel seguente modo:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Algoritmo di Euclide}{\footnotesize{}\index{Euclide, algoritmo di@{\footnotesize{}Euclide, algoritmo di}}}}[1.8cm]
\begin{equation}
\begin{array}{c}
b=q_{1}\cdot a+r_{1}\\
a=q_{2}\cdot r_{1}+r_{2}\\
r_{1}=q_{3}\cdot r_{2}+r_{3}\\
\vdots\\
r_{k-2}=q_{k}\cdot r_{k-1}+r_{k}\\
r_{k-1}=q_{k+1}\cdot r_{k}+0\\
\boxed{r_{k}=d}
\end{array}\label{eq:Algoritmo-Euclide}
\end{equation}
dove $q_{i}$ è l'$i$-esimo quoziente e $r_{i}$ è l'$i$-esimo resto;
dall'algoritmo si può dedurre che, presi $a,\,b\neq0$ e sia $d=\mcd ab$,
allora è vero che $\exists x,\,y\in\mathbb{Z}\tc a\cdot x+b\cdot y=d$.
Questo risulta chiaro se immaginiamo che i due interi cercati siano
anche negativi; per trovare tali interi è necessario utilizzare una
estensione del (\ref{eq:Algoritmo-Euclide}).

\subsection{Algoritmo esteso}

L'algoritmo di Euclide presentato nella sottosezione precedente può
essere esteso, impiegando nel suo svolgimento due successioni $\left\{ x_{k}\right\} $
e $\left\{ y_{k}\right\} $: esse avranno i primi due valori ben definiti,
come
\begin{equation}
x_{0}=,\,x_{1}=1;\;y_{0}=1,\,y_{1}=0\label{eq:Premessa-successioni-Euclide-esteso}
\end{equation}

Facendo corrispondere ai passi (\ref{eq:Algoritmo-Euclide}) gli elementi
delle successioni $\left\{ x_{k}\right\} $ e $\left\{ y_{k}\right\} $,
possiamo ottenere gli elementi dal secondo in poi come:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Algoritmo di Euclide esteso}{\footnotesize{}\index{Euclide, algoritmo esteso di@{\footnotesize{}Euclide, algoritmo esteso di}}}}[1.2cm]
\begin{equation}
\begin{array}{cc}
x_{2}=-q_{1}\cdot x_{1}+x_{0} & y_{2}=-q_{1}\cdot y_{1}+y_{0}\\
x_{3}=-q_{2}\cdot x_{2}+x_{1} & y_{3}=-q_{2}\cdot y_{2}+y_{1}\\
x_{4}=-q_{3}\cdot x_{3}+x_{2} & y_{4}=-q_{3}\cdot y_{3}+y_{2}\\
\vdots & \vdots\\
\boxed{x_{k+1}}=-q_{k}\cdot x_{k}+x_{k-1} & \boxed{y_{k+1}}=-q_{k}\cdot y_{k}+y_{k-1}
\end{array}\label{eq:Algoritmo-Euclide-esteso}
\end{equation}
Osserviamo che gli elementi delle successioni in $x$ e $y$ si ottengono
in modo analogo, tuttavia le due successioni sono inizializzate in
modo differente (\ref{eq:Premessa-successioni-Euclide-esteso}). Euclide
Esteso ci permette di affermare che
\[
\mcd ab=d=a\cdot x_{k+1}+b\cdot y_{k+1}
\]
dove gli interi $x_{k+1}$ e $y_{k+1}$ sono ottenuti dalle successioni
(\ref{eq:Algoritmo-Euclide-esteso}); normalmente uno dei due è positivo
e l'altro è negativo.

\section{Congruenza in modulo}

\subsection{Definizione e proprietà}

Nelle sezioni precedenti abbiamo introdotto il simbolo di congruenza
`$\equiv$', che usato nel modo seguente implica che
\[
\cgm abn\implies\mod an=\mod bn\implies a-b=k\cdot n
\]
ovvero il fatto che $a$ sia congruente in modulo $n$ a $b$ implica
il fatto che $a$ e $b$ siano multipli; possiamo infatti dedurlo
osservando l'ultima implicazione, riscritta come
\[
a=b+k\cdot n
\]

Per la congruenza in modulo valgono alcune proprietà simili a quelle
dell'uguaglianza:
\begin{itemize}
\item $\cgm a0n\iff n\backslash a$
\item $\forall a\in\mathbb{Z}\tc\cgm aan$
\item $\cgm abn\iff\cgm ban$
\item $\cgm abn\land\cgm bcn\implies\cgm acn$
\end{itemize}

\subsection{Insieme dei residui}

Fin'ora abbiamo lavorato all'interno dell'insieme dei numeri interi
$\mathbb{Z}$; introduciamo l'insieme dei residui modulo $n$, indicato
come $\mathbb{Z}_{n}$, che contiene l'insieme dei valori da 0 a $n-1$
e al suo interno sono definite ciclicamente le operazioni di addizione,
sottrazione e moltiplicazione; osserviamo un esempio sull'addizione.
\begin{example}
\emph{\label{ex:Operazioni-insieme-residui}Determinare i risultati
delle seguenti operazioni, all'interno dell'insieme $\mathbb{Z}_{10}$:
$4+5,\,5+5,\,2-3,\,3\cdot4$.}

$\checked$Dalla definizione sappiamo che $\mathbb{Z}_{10}=\left\{ 0,1,2,3,4,5,6,7,8,9\right\} $,
allora le operazioni richieste valgono:
\[
4+5=9,\;5+5=0,\;2-3=9,\;3\cdot4=2
\]
\demo
\end{example}
La divisione in un insieme dei residui non è definita in modo banale
come le altre tre operazioni; introdurremo in seguito questa operazione.

\subsection{Insieme ridotto dei residui}

Dato un insieme dei residui $\mathbb{Z}_{n}$, possiamo definire il
suo insieme ridotto $\mathbb{Z}_{n}^{*}$, che contiene gli elementi
di $\mathbb{Z}_{n}$ che sono coprimi rispetto a $n$, ovvero
\[
\forall z\in\mathbb{Z}_{n}^{*}\tc z\in\mathbb{Z}_{n}\land z\perp n
\]
Procedendo con l'Esempio \ref{ex:Operazioni-insieme-residui}, l'insieme
ridotto dei residui modulo 10 avrà i seguenti elementi al suo interno:
\[
\mathbb{Z}_{10}^{*}=\left\{ 1,3,7,9\right\} 
\]
Notiamo che lo zero è sempre escluso dall'insieme ridotto, perché
non è coprimo rispetto ad alcun intero; la cardinalità di $\mathbb{Z}_{n}^{*}$
è determinata da una funzione di $n$ chiamata \emph{toziente} o \emph{$\varphi$
di Eulero}; in particolare vale $\varphi\left(10\right)=4$ (vedremo
in seguito come calcolare questa funzione).

\subsection{Equazioni congruenziali}

Una equazione congruenziale è una relazione definita su un'insieme
di residui; nel seguito vedremo delle proprietà che ci permetteranno
di operare con queste relazioni.
\begin{prop}
Prendiamo un intero $n\neq0$ e quattro interi $a,b,c,d$ tali che
\emph{$\cgm abn$ }e\emph{ $\cgm cdn$}; allora si verifica che\emph{
\[
\cgm{a+c}{b+d}n,\;\cgm{a-c}{b-d}n,\;\cgm{a\cdot c}{b\cdot d}n
\]
}
\end{prop}
Possiamo usare queste proprietà per risolvere la seguente equazione
congruenziale.
\begin{example}
\emph{Risolvere rispetto a $x$ l'equazione }$\cgm{x+7}3{17}$\emph{.}

$\checked$Dato che 7 è congruente a 3 in modulo 17, possiamo sfruttare
la seconda proprietà, per cui
\[
\begin{array}{c}
\cgm{x+7\boldsymbol{-7}}{3\boldsymbol{-7}}{17}\\
\cgm x{-4}{17}
\end{array}
\]
Osservando che $17-4=13$, otteniamo infine (è equivalente a scrivere
la congruenza con $-4$)
\[
\cgm x{13}{17}
\]
\demo
\end{example}
Ora introduciamo il concetto di divisione nell'insieme dei residui,
con una seconda proposizione.
\begin{prop}
Prendiamo un intero $n\neq0$ e tre interi $a,b,c$ con $a\perp n$
e vale \emph{$\cgm{a\cdot b}{a\cdot c}n$}; allora possiamo dire che
\emph{$\cgm{a\cdot b}{a\cdot c}n\implies\cgm bcn$}, tramite la moltiplicazione
da ambo i lati per l'inverso $a^{-1}$
\end{prop}
Possiamo risolvere una forma di equazione congruenziale più elaborata.
\begin{example}
\emph{Risolvere rispetto a $x$ l'equazione }$\cgm{2x+7}3{17}$\emph{.}

$\checked$Come nel caso precedente, possiamo sottrarre 7 da entrambi
i lati, dato che $\cgm 73{17}$, ottenendo
\[
\cgm{2x}{-4}{17}
\]
Ora sfruttando il fatto che $2\perp17$ la precedente diventa
\[
\cgm x{-2}{17}=\cgm x{15}{17}
\]
\demo
\end{example}
%
\begin{example}
\emph{Risolvere rispetto a $x$ l'equazione }$\cgm{5x+6}{13}{11}$\emph{.}

$\checked$Osservando che $\cgm 6{13}{11}$, applichiamo la proprietà
della divisione e otteniamo
\[
\cgm{5x}7{11}
\]
Se ora usiamo la proprietà della divisione (vale $5\perp11$) dovremo
scrivere
\[
\cgm x{\hat{\frac{7}{5}}}{11}
\]
dove la frazione $\hat{\nicefrac{7}{5}}$ in realtà non esiste nell'insieme
$\mathbb{Z}_{11}$; tuttavia sappiamo che $5x$ è congruente modulo
11 a 7, ma anche a (per la ciclicità dell'insieme dei residui) $7+11,\,7+22,\,\ldots\,,7+k\cdot11$;
il primo numero che sia un multiplo di 5 si ha per 3; abbiamo ottenuto
che $\left[7=40\right]\ni\mathbb{Z}_{11}$, quindi possiamo scrivere
\[
\begin{array}{c}
\cgm{5x}{40}{11}\\
\cgm x8{11}
\end{array}
\]
Possiamo in un certo senso affermare che 8 si comporta come $\nicefrac{7}{5}$
in $\mathbb{Z}_{11}$.

Esiste una seconda strada per risolvere questo esercizio; sapendo
che 5 e 11 sono primi relativi, usiamo il prodotto invece della divisione:
\[
\cgm{5x\cdot\boldsymbol{5^{-1}}}{7\cdot\boldsymbol{5^{-1}}}{11}
\]
L'inverso di un numero $n$ è quel numero $m$ tale che $n\cdot m=1$;
dunque cerchiamo l'elemento di $\mathbb{Z}_{11}$ che moltiplicato
per 5 risulta 1; troviamo $m\cdot5=1\parallel_{\mathbb{Z}_{11}}\implies m=9$,
da cui segue che
\[
\cgm x{7\cdot9}{11}
\]
e dato che $7\cdot9=63=5\cdot11+8$ la precedente si scrive come
\[
\cgm x8{11}
\]
Abbiamo ottenuto il medesimo risultato a cui siamo arrivati attraverso
il primo procedimento.\demo
\end{example}
\begin{rem}
Presi $a\in\mathbb{Z}_{n}$ e $b\notin\mathbb{Z}_{n}^{*}$, non è
definita la divisione $a\div b$ (deve infatti valere $b\perp n\implies b\in\mathbb{Z}_{n}^{*}$).
\end{rem}
%
\begin{rem}
Se prendiamo l'equazione $\cgm{a\cdot x}bn$, essa ammetterà soluzione
se vale $a\perp n$; in tal caso $\exists a^{-1}\in\mathbb{Z}_{n}^{*}$
e la soluzione sarà $\cgm x{b\cdot a^{-1}}n$.
\end{rem}
Cosa possiamo concludere nel caso in cui, data l'equazione $E:\,\cgm{a\cdot x}bn$,
non sia vero che $a\perp n$, cioè nel caso in cui $\mcd an=d>1$?
In tal caso, l'equazione può non ammettere soluzione o ammetterne
$d$.

Se $d\backslash b$ allora dividiamo per $d$ tutte le quantità costanti,
ottenendo
\[
\overline{E}:\,\cgm{\frac{a}{d}x}{\frac{b}{d}}{\frac{n}{d}}
\]
questa equazione ha ora una soluzione, perché $\mcd an=d\implies\mcd{\frac{a}{d}}{\frac{n}{d}}=\frac{d}{d}=1$
e ricadiamo nel caso dell'osservazione precedente.

Otteniamo la soluzione dell'equazione $\overline{E}$ e la chiamiamo
$x_{0}$, la quale sarà in modulo $\nicefrac{n}{d}$ ($x_{0}\in\mathbb{Z}_{n/d}$);
dato che l'equazione di partenza $E$ ha soluzioni in $\mathbb{Z}_{n}$,
esse saranno i termini della successione
\[
\left\{ x\right\} =x_{0},\,x_{0}+\frac{n}{d},\,x_{0}+2\frac{n}{d},\,\ldots\,,\,x_{0}+\left(d-1\right)\frac{n}{d}
\]
Osserviamo l'esempio di un'equazione con queste caratteristiche.
\begin{example}
\emph{Risolvere rispetto a $x$ l'equazione }$\cgm{12x}{21}{39}$\emph{.}

$\checked$Osserviamo subito che $\mcd{12}{39}=3$, dunque l'equazione
avrà 0 o 3 soluzioni; dividiamo le costanti per 3 e otteniamo
\[
\cgm{4x}7{13}
\]
da cui otteniamo $\cgm x{\hat{\frac{7}{4}}}{13}$ e trovando $4\backslash\left(7+1\cdot13\right)=20$
la precedente equazione fornisce una soluzione $\cgm{x_{0}}5n$; adesso
usiamo la successione delle soluzioni $\left\{ x\right\} $ per ottenere
tutte le soluzioni dell'equazione di partenza:
\[
x=\left\{ x_{0}=\boxed{5},\,x_{0}+\frac{39}{3}=\boxed{18},\,x_{0}+\frac{2\cdot39}{3}=\boxed{31}\right\} 
\]
Possiamo immaginare le radici di $E$ come dei punti su una circonferenza,
a distanza $d/n$ da $x_{0}$.\demo

Posto che valga $a\perp n$ (ovvero $\mcd an=1$), come possiamo calcolare
l'inverso $a^{-1}$? Potremmo tentare tutti i numeri da $1$ a $n-1$
conducendo un'analisi esaustiva, tuttavia per $n$ molto grande questo
non è pratico; usiamo allora l'algoritmo di Euclide esteso (\ref{eq:Algoritmo-Euclide-esteso}):
esso ci garantisce che
\[
\mcd an=1\implies\exists s,t\in\mathbb{Z}_{n}\tc a\cdot s+n\cdot t=1
\]
segue dalla precedente relazione che $a\cdot s=1-n\cdot t$, allora
abbiamo $\cgm{a\cdot s}1n$ e risolvendo l'equazione si ottiene
\[
\cgm s{a^{-1}}n
\]
ovvero il numero $s$ è proprio l'elemento finale $x_{k+1}$ della
sequenza di $x$ dell'algoritmo; esso risulta essere anche il valore
cercato dell'inverso $a^{-1}$.
\end{example}

\section{Teorema cinese del resto}

\subsection{Applicazione ed enunciato}

Mostriamo direttamente l'applicazione del teorema a un caso specifico:
prendiamo $\cgm x{25}{42}$; possiamo esprimere $x=25+6\cdot\left(7\cdot k\right)\rightleftarrows25+7\cdot\left(6\cdot k\right)$,
da cui ricaviamo
\begin{itemize}
\item per $x=25+6\cdot\left(7\cdot k\right)$: $\mod{25}6=1\implies\cgm x16$
\item per $x=25+7\cdot\left(6\cdot k\right)$: $\mod{25}7=3\implies\cgm x37$
\end{itemize}
Dalle due congruenze più semplici ottenute possiamo scrivere il sistema
\[
\cgm x{25}{42}\implies\begin{cases}
\cgm x16\\
\cgm x37
\end{cases}
\]
Il teorema cinese del resto afferma che:
\begin{thm}
Dati\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema cinese del resto}{\footnotesize{}\index{Cinese, teorema del resto@{\footnotesize{}Cinese, teorema del resto}}\label{thm:Teorema-cinese-del-resto}}}[0.0cm] due interi $n,\,m$ che siano \uline{primi relativi} (deve
valere $n\perp m$), e presi due interi $a,\,b$, allora il sistema
delle congruenze\emph{
\[
\begin{cases}
\cgm xan\\
\cgm xbm
\end{cases}
\]
}è equivalente alla singola congruenza\emph{
\[
\cgm xc{n\cdot m}
\]
}
\end{thm}
Il teorema afferma che, quanto introdotto all'inizio della sezione,
può valere nel senso opposto in alcune condizioni specifiche.Osserviamo
l'applicazione del teorema in un esempio.
\begin{example}
\emph{Sia dato il seguente insieme di congruenze:}
\[
\begin{cases}
\cgm x37\\
\cgm x5{15}
\end{cases}
\]
\emph{Scrivere una forma equivalente, con una singola congruenza.}

$\checked$Dato che $7\perp15$, per il Teorema \ref{thm:Teorema-cinese-del-resto}
possiamo affermare che esisterà una singola congruenza equivalente
alle due della consegna; essa sarà scritta nella forma $\cgm xc{105}$.
Per ottenere $c$ possiamo provare i numeri multipli di 5, i quali
in modulo 7 diano 3 come risultato; si ottiene facilmente $c=80$
(possiamo scomporlo come $80=11\cdot7+3$).

Nel caso di numeri molto grandi, non è possibile scegliere di procedere
per tentativi, ed è necessario usare gli strumenti della teoria dei
numeri: se sappiamo che $\cgm xan$ e anche $\cgm xbm$, allora possiamo
scrivere
\[
\cgm{x=b+\overline{k}\cdot m}an
\]
risolvendo questa relazione si ottiene $\cgm{a-b}{\overline{k}\cdot m}n$
da cui, rispetto a $\overline{k}$ otteniamo
\[
\cgm{\overline{k}}{\left(a-b\right)\cdot m^{-1}}n
\]
Il valore $\overline{k}$ corrisponde al $c$ del Teorema \ref{thm:Teorema-cinese-del-resto},
esso infatti è congruente sia ad $a$ in modulo $n$, sia a $b$ in
modulo $m$.\demo
\end{example}

\subsection{Estensione}

Il Teorema \ref{thm:Teorema-cinese-del-resto} ammette un'estensione
a un caso generale, con $N$ congruenze.
\begin{cor}
Prendiamo\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema cinese del resto esteso}{\footnotesize{}\index{Cinese, teorema del resto esteso@{\footnotesize{}Cinese, teorema del resto esteso}}\label{thm:Teorema-cinese-del-resto-esteso}}}[0.0cm] $N$ numeri interi, indicati come $m_{i}\tc i\in\left[1,\,N\right]$,
tali che a coppie siano tutti coprimi ($\forall i,j\in\left[1,\,N\right]\land i\neq j\tc m_{i}\perp m_{j}$).
Se abbiamo il seguente sistema di congruenze
\[
\begin{cases}
\cgm x{a_{1}}{m_{1}}\\
\cgm x{a_{2}}{m_{2}}\\
\\
\cgm x{a_{N}}{m_{N}}
\end{cases}
\]
è equivalente alla singola congruenza
\[
\cgm xC{\prod_{i=1}^{N}m_{i}}
\]
\end{cor}
Tale congruenza si costruisce a partire dalle seguenti serie:
\[
M=\prod_{i=1}^{N}m_{i};\quad Z_{i}=\frac{M}{m_{i}};\quad Y_{i}=\mod{Z_{i}^{-1}}{m_{i}}
\]
Otteniamo infine la seguente soluzione, equivalente a una singola
congruenza:
\begin{equation}
X=\mod{\serie{i=1}N{a_{i}Y_{i}Z_{i}}}M\label{eq:Congruenza-equivalente-sistema}
\end{equation}


\section{Square \& multiply\label{sec:Square-=000026-multiply}}

Tramite l'algoritmo chiamato square and multiply, è possibile calcolare
il modulo di un numero che abbia molte cifre; mostriamo un esempio
per illustrare l'idea dietro a questo algoritmo, usando numeri ``piccoli''.
\begin{example}
\emph{Si calcoli il risultato dell'operazione} $\mod{7^{11}}{26}$.

$\checked$Eseguiamo i seguenti passi per cercare il valore desiderato:\marginpar{LSB indica il least significant bit (bit meno significativo) e si
riferisce al primo bit da destra}[0.8cm]
\end{example}
\begin{enumerate}
\item Esprimiamo 11 (l'esponente) in forma binaria: $11_{10}=1011_{2}=1\cdot2^{3}+0\cdot2^{2}+1\cdot2^{1}+1\cdot2^{0}$;
\item Sostituire 11 con la sua rappresentazione binaria: $7^{11}=7^{\left(8+2+1\right)}=7^{8}\cdot7^{2}\cdot7$;
\item Scriviamo i bit di 11 in colonna, al contrario (a partire dal LSB):
$\begin{bmatrix}1 & 1 & 0 & 1\end{bmatrix}$;
\item Scriviamo accanto a ciascun bit la potenza di 7 corrispondente, ottenuta
dalla scomposizione al punto ${\scriptstyle \left(1\right)}$;
\item Scriviamo accanto alle potenze $7^{i}$ il risultato dell'operazione
$\mod{7^{i}}{26}$;
\item Componiamo il risultato prendendo il prodotto dei valori scritti al
punto ${\scriptstyle \left(5\right)}$ in corrispondenza di un 1,
scritto al punto ${\scriptstyle \left(3\right)}$
\end{enumerate}
Otterremo infine:
\[
\begin{array}{ccc}
\boldsymbol{1} & 7^{1} & \boxed{7}\\
\boldsymbol{1} & 7^{2} & \boxed{23}\\
0 & 7^{4} & 9\\
\boldsymbol{1} & 7^{8} & \boxed{3}
\end{array}\implies\mod{\left(7\cdot23\cdot3\right)}{26}=15
\]
Il vantaggio di questo metodo è il fatto che si basa solo sull'operazione
di elevamento al quadrato di numeri piccoli (relativamente al modulo,
nell'esercizio siamo in $\mathbb{Z}_{26}$). In totale, saranno necessari
(per questo caso dell'esercizio) $2\cdot\log_{2}\left(11\right)\simeq4$.\demo

\section{Teorema piccolo di Fermat}
\begin{thm}
Sia\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema piccolo di Fermat}{\footnotesize{}\index{Fermat, teorema piccolo di@{\footnotesize{}Fermat, teorema piccolo di}}\label{thm:Teorema-piccolo-Fermat}}}[0.0cm] $p$ un intero primo, e $a$ un intero tale che $p$ \uline{non}
divida $a$, allora è vero che\emph{
\begin{equation}
\cgm{a^{p-1}}1p\label{eq:Teorema-piccolo-Fermat}
\end{equation}
}
\end{thm}
Non vale l'implicazione inversa, infatti prendendo $a$ ed $n$ due
interi qualsiasi, e osservando che $\cgm{a^{n-1}}1n$, non possiamo
dedurre che $n$ sia primo.

Piuttosto possiamo usare il Teorema \ref{thm:Teorema-piccolo-Fermat}
per provare che un numero sia composto (non primo); tuttavia i numeri
composti che danno resto 1 non ostante non siano primi sono pochi,
e sono definiti \emph{pseudo-primi}. Questi numeri sono sempre più
rarefatti all'aumentare dell'ordine di grandezza.

Non ostante la scelta di una base $a$ differente possa ``smascherare''
un numero pseudo-primo, esiste una categoria di interi chiamati \emph{pseudo-primi
assoluti}, i quali forniscono resto 1 con qualunque base scelta nel
test del teorema piccolo di Fermat.
\begin{rem}
Abbiamo concluso dal Teorema \ref{thm:Teorema-piccolo-Fermat} che,
se non è vero $p\backslash a$, allora vale $\cgm{a^{p-1}}1p$; possiamo
scrivere questa congruenza in modo equivalente come $\cgm{a\cdot a^{p-2}}1p$,
che può essere risolta con la regola della divisione nel modo seguente:
\begin{equation}
\cgm{a^{p-2}}{a^{-1}}p\label{eq:Osservazione-inverso-p-2}
\end{equation}
Abbiamo appena ottenuto un nuovo metodo per calcolare l'inverso di
un intero $a$.
\end{rem}
Poniamoci nel caso generale, in cui abbiamo un intero qualunque $a$
e un intero composto $n$: la condizione del teorema diventa che $a\perp n$;
in queste condizioni possiamo enunciare il seguente Teorema \ref{thm:Teorema-Eulero}.
\begin{thm}
Sia\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Teorema di Eulero}{\footnotesize{}\index{Eulero, teorema di@{\footnotesize{}Eulero, teorema di}}\label{thm:Teorema-Eulero}}}[0.0cm] $a$ un intero qualunque e $n$ un intero composto, tali
che $a\perp n$, allora è vero che\emph{
\begin{equation}
\cgm{a^{\varphi\left(n\right)}}1n\label{eq:Teorema-Eulero}
\end{equation}
}
\end{thm}
La funzione \emph{toziente} $\varphi\left(p\right)$ con $p$ numero
primo, è il numero di primi relativi rispetto a $p$, in questo caso
$p-1$ numeri, tutti i predecessori di $p$, il quale essendo primo
ha come fattore comune con essi solo 1; vale dunque $\varphi\left(p\right)=p-1$
per $p$ numero primo.

In generale il toziente di un intero $n$ qualunque si può calcolare
in uno dei seguenti modi:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Toziente}{\footnotesize{}\index{Toziente@{\footnotesize{}Toziente}}\label{eqn:Toziente}}}[1.2cm]
\begin{itemize}
\item $\varphi\left(n\right)=n\cdot\prod_{i\in\left[1,n-1\right],\,p_{i}\backslash n}\left(1-\dfrac{1}{p_{i}}\right)$
\item $n=\prod_{i=1}^{m}p_{i}^{r_{i}}\implies\varphi\left(n\right)=\prod_{i=1}^{m}\left(p_{i}^{r_{i}}-p_{i}^{r_{i}-1}\right)$
\end{itemize}
Vediamo un esempio in cui calcoliamo il toziente di due numeri adoperando
entrambi i procedimenti:
\begin{example}
\emph{Calcolare il toziente di 1000.}

$\checked$Adoperando il primo metodo, scriviamo la scomposizione
di 1000 nei suoi fattori primi: $1000=2^{3}\cdot5^{3}$; scriviamo
dunque la produttoria usando i due fattori $p_{i}=\left\{ 2,\,5\right\} $
senza esponente
\[
1000\cdot\left(1-\frac{1}{2}\right)\cdot\left(1-\frac{1}{5}\right)=\boxed{400}=\varphi\left(1000\right)
\]
Se adoperiamo il secondo metodo, scriviamo direttamente la produttoria
a partire dai fattori primi $2^{3}$ e $5^{3}$:
\[
\left(2^{3}-2^{2}\right)\cdot\left(5^{3}-5^{2}\right)=\boxed{400}=\varphi\left(1000\right)
\]
Abbiamo ottenuto lo stesso toziente, mostrando che entrambi i procedimenti
si equivalgono.\demo
\end{example}
\begin{rem}
Se vogliamo calcolare l'inverso di un intero $a$ modulo $n$ non
primo, posto che $a\perp n$ possiamo scrivere la congruenza
\begin{equation}
\cgm{a^{-1}}{a^{\varphi\left(n\right)-1}}n\label{eq:Inverso-residuo-toziente}
\end{equation}
Questa relazione ci permette di calcolare un inverso utilizzando il
modulo di un elevamento a potenza (evitando la strada di Euclide esteso
(\ref{eq:Algoritmo-Euclide-esteso})), per esempio tramite square
and multiply eseguito su un calcolatore.
\end{rem}
Mettendo assieme quanto illustrato in questa sezione, possiamo rispondere
alla richiesta mostrata nel seguente esempio.
\begin{example}
\emph{Calcolare le ultime tre cifre di} $7^{803}$.\label{ex:Ultime-3-cifre-7}

$\checked$Le ultime tre cifre di un numero possono essere ottenute
usando il resto della sua divisione per $10^{3}$; allora dobbiamo
trovare il risultato di $\mod{7^{803}}{1000}$.

Per il teorema di Eulero (\ref{eq:Teorema-Eulero}) sappiamo che $\cgm{7^{\varphi\left(1000\right)}}1{1000}$
e dal precedente esempio abbiamo già calcolato $\varphi\left(1000\right)=400$,
per cui possiamo scomporre $7^{803}$ nel modo seguente:
\[
\mod{\left(7^{400}\cdot7^{400}\cdot7^{3}\right)}{1000}=\mod{\left(1\cdot1\cdot343\right)}{1000}=\boxed{343}
\]
\demo
\end{example}

\section{Principio fondamentale}

Se abbiamo gli interi $a,\,b,\,n,\,x,\,y$ e $n>0$, tali che $a\perp n$,
allora se $\cgm xy{\varphi\left(n\right)}$ vale
\begin{equation}
\cgm{a^{x}}{b^{y}}n\label{eq:Principio-fondamentale}
\end{equation}
tuttavia non vale l'implicazione inversa.

Concludiamo che, in una congruenza modulo $n$, in presenza di elevamenti
a potenza gli esponenti della stessa base lavorano in modulo di $\varphi\left(n\right)$.

Questo principio permette di risolvere rapidamente la richiesta dell'Esercizio
\ref{ex:Ultime-3-cifre-7}: dato che $\cgm{803}3{\varphi\left(1000\right)=400}$
otteniamo direttamente $\cgm{7^{803}}{7^{3}}{1000}$; abbiamo usato
(\ref{eq:Principio-fondamentale}) in cui $x=803$ e $y=3$.

\section{Radici in aritmetica modulare}

\subsection{Radici primitive}

Introduciamo il concetto di gruppo algebrico:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Gruppo algebrico}{\footnotesize{}\index{Gruppo algebrico@{\footnotesize{}Gruppo algebrico}}\label{def:Gruppo-algebrico}}}[0.3cm]

\begin{minipage}[t]{0.9\textwidth}%
\begin{center}
\emph{Chiamiamo }gruppo\emph{ una struttura formata da un insieme
e da un'operazione binaria definita su di esso, la quale soddisfi
gli assiomi di associatività, esistenza dell'elemento neutro ed esistenza
dell'elemento inverso}
\par\end{center}%
\end{minipage}

Ad esempio, se prendiamo l'insieme dei numeri interi $\mathbb{Z}$
e l'operazione di somma $+$, possiamo formare il gruppo $\left(\mathbb{Z},\,+\right)$
poiché la somma è associativa, l'elemento neutro è lo zero e l'inverso
di qualunque elemento è sempre definito; anche prendendo $\mathbb{Z}_{p}^{*}$
(insieme dei residui interi modulo $p$, escluso lo 0) e l'operazione
di prodotto, otteniamo di nuovo un gruppo $\left(\mathbb{Z}_{p}^{*},\,\cdot\right)$.
Non si ottiene un gruppo rispetto al prodotto per $\mathbb{Z}_{p}$
(residui modulo $p$, da 0 a $p-1$), poiché lo 0 non ha un inverso
definito.\bigskip{}

Se prendiamo un elemento $a\in\mathbb{Z}_{p}^{*}$ allora vale $\cgm{a^{p-1}}1p$
per il Teorema \ref{thm:Teorema-piccolo-Fermat}; chiamiamo inoltre
ordine dell'elemento $a$ (e lo indichiamo tramite $\ord a$) l'intero
$n>0$ più piccolo tale che
\begin{equation}
\cgm{a^{n}}1p\label{eq:Ordine-di-intero}
\end{equation}
Il teorema piccolo di Fermat (\ref{eq:Teorema-piccolo-Fermat}) ci
assicura che vale sempre $n\leq p-1$, ma non è detto che sia proprio
$n=p-1$. Chiamiamo quindi $\alpha$ l'elemento primitivo $a\in\mathbb{Z}_{p}^{*}$
se e solo se l'ordine di $a$ è 1, ovvero non esiste nessun altro
intero $n$ per cui $\cgm{a^{n}}1p$; in altri termini vale
\begin{equation}
\cgm{a^{n}}1p\iff n=1\label{eq:Condizione-elemento-primitivo}
\end{equation}
Se l'ordine di $a$ fosse proprio $p-1$, allora preso $\alpha^{i}$
l'elemento primitivo, presi tutti gli interi $i\in\left[1,\,p-1\right]$,
otteniamo dalla successione degli $\alpha^{i}$ tutti e soli gli elementi
dell'insieme $\mathbb{Z}_{p}^{*}$ (in ordine anche differente); chiameremo
l'elemento $\alpha$ la \emph{radice primitiva}.

\begin{minipage}[t]{0.9\columnwidth}%
\begin{center}
\emph{Chiamiamo $\alpha$ una radice primitiva per $p$ se vale (\ref{eq:Condizione-elemento-primitivo})
e inoltre l'ordine di $\alpha$ è pari a $n=p-1$.}
\par\end{center}%
\end{minipage}\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Radice primitiva}{\footnotesize{}\index{Radice primitiva@{\footnotesize{}Radice primitiva}}\label{def:Radice-primitiva}}}[-0.2cm]
\begin{example}
\emph{Trovare se $\alpha=3$ sia una radice primitiva di $p=7$.}
\end{example}
$\checked$Per trovare se $\alpha$ sia effettivamente una radice
primitiva di $p$, calcoliamo gli elementi:
\[
\left\{ \forall i\in\left[0,\,p-1\right]\,:\,\cgm{\beta}{\alpha^{i}}p\right\} 
\]
Otteniamo quindi:
\[
\begin{array}{c}
\cgm{3^{0}}17\\
\cgm{3^{1}}37\\
\cgm{3^{2}}27\\
\cgm{3^{3}}67\\
\cgm{3^{4}}47\\
\cgm{3^{5}}57\\
\vdots
\end{array}
\]
Abbiamo riottenuto tutti e soli gli elementi da $1$ a $p-1=6$ (i
membri di $\mathbb{Z}_{7}^{*}$), con periodo $p-1=6$. Si verifica
dunque la condizione che rende un elemento primitivo $\alpha$ una
radice per $p$; la radice primitiva è anche detta elemento generatore:
infatti, tramite essa è possibile ottenere tutti i residui in modulo
$p$ di un certo insieme $\mathbb{Z}_{p}^{*}$.\demo
\begin{example}
\emph{Trovare se $\alpha=2$ sia una radice primitiva di $p=7$.}
\end{example}
$\checked$Calcolando di nuovo gli $\alpha^{i}$ con $i\in\left[0,\,p-1\right]$
otteniamo
\[
\begin{array}{c}
\cgm{2^{0}}17\\
\cgm{2^{1}}27\\
\cgm{2^{2}}47\\
\cgm{2^{3}}17\\
\vdots
\end{array}
\]
In questo caso abbiamo ottenuto periodo 3; inoltre l'ordine di $\alpha$
è $n=3\neq p-1=6$, quindi $\alpha=2$ non è radice primitiva di $p=7$.\demo
\begin{rem}
Se prendiamo l'elemento primitivo $a\in\mathbb{Z}_{p}^{*}$, esso
avrà al massimo ordine $p-1$; tuttavia potrà presentare anche ordini
pari ai sottomultipli di $p-1$, ma non ordini differenti da essi.
\end{rem}
%
\begin{rem}
Se $\alpha$ è un elemento primitivo di $\mathbb{Z}_{p}^{*}$ e vale
$\cgm{\beta}{\alpha^{i}}p$ con $1\leq i\leq p-1$, questi $\beta$
sono tutti e soli gli elementi di $\mathbb{Z}_{p}^{*}$. Se ora prendiamo
un elemento primitivo di $\mathbb{Z}_{p}^{*}$ espresso come $\beta$
(tramite la precedente congruenza), il suo ordine sarà dipendente
dall'esponente $i$ usato per ottenerlo a partire da $\alpha,$e dovrà
valere
\begin{equation}
\ord{\beta}=\frac{p-1}{\mcd{p-1}i}\label{eq:Elemento-primitivo-MCD}
\end{equation}
dove $i$ è l'esponente a cui elevare $\alpha$ per ottenere $\beta$.
Questo si verifica perché i $\beta$sono potenze di $\alpha$, ed
essendo $\ord{\alpha}=p-1$ ($\alpha$ è radice primitiva) necessariamente
l'ordine di $\beta$ sarà un sottomultiplo di $p-1$, determinato
da (\ref{eq:Elemento-primitivo-MCD})

Gli elementi primitivi di $\mathbb{Z}_{p}^{*}$ sono in numero $\varphi\left(p-1\right)$;
infatti saranno tutti gli elementi di $\mathbb{Z}_{p}^{*}$. coprimi
rispetto a $p-1$, per cui si verifica la condizione (\ref{eq:Elemento-primitivo-MCD}).
Notiamo infatti che $\beta$ è una radice primitiva di $p$ (vale
$\ord{\beta}=p-1$) quando si ha$\mcd{p-1}i=1$; concludiamo che il
numero di elementi primitivi $\beta$ di un insieme $\mathbb{Z}_{p}^{*}$
è il numero di elementi coprimi rispetto a $p-1$ (valore ottenuto
dalla funzione toziente di $p-1$).
\end{rem}

\subsection{Test di primitività}

Prendiamo un $\alpha\in\mathbb{Z}_{p}^{*}$ con $p$ qualunque, e
cerchiamo se $\alpha$ sia primitivo o meno rispetto a $p$; usiamo
il seguente test di primitività: scomporre $p-1$ nei suoi fattori
primi, in modo da avere una produttoria di quozienti elevati a un
certo esponente $p-1=\prod_{i}q_{i}^{r_{i}}$; diremo che $\alpha$
è primitivo rispetto a $p$ se e solo se vale\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Test primitività}{\footnotesize{}\index{Test primitività@{\footnotesize{}Test primitività}}}}[0.4cm]
\begin{equation}
\forall i\,:\,\ncgm{\alpha^{\left(p-1\right)/q_{i}}}1p\label{eq:Test-primitivit=0000E0}
\end{equation}
Si noti che $p$ è primo (per definizione), di conseguenza $p-1$
è sempre pari.
\begin{example}
\emph{Ottenere se $\alpha=2$ sia radice primitiva per $p=19$.}
\end{example}
$\checked$Usando il test (\ref{eq:Test-primitivit=0000E0}), scomponiamo
$19-1=18$ nei suoi fattori primi:
\[
18=2\cdot3^{2}
\]
Ora testiamo la congruenza per tutti i fattori primi (presi senza
esponente):
\[
\begin{array}{c}
\cgm{2^{18/3}=2^{6}=64}7{19}\\
\cgm{2^{18/2}=2^{9}=512}{18}{19}
\end{array}
\]
Per nessun fattore primo si ha congruenza a 1 modulo 19, dunque $\alpha=2$
è davvero una radice primitiva per $p=19$.

Osserviamo infine che gli elementi primitivi di $\mathbb{Z}_{19}$
sono $\varphi\left(18\right)=6$, distribuiti all'interno dell'insieme
in modo non predicibile.\demo

\subsection{Radici quadrate}

Poniamoci nel caso di radici quadrate in modulo a un intero $p$ primo;
inoltre, consideriamo per tale intero solamente la metà dei numeri
primi (si ricordi la separazione dei primi in classi di congruenza
(\ref{eq:Successione-primi-classi})):
\begin{equation}
\cgm p34\label{eq:Condizione-radici-quadrate-modulo-primo}
\end{equation}
Risolviamo, sotto queste condizioni, l'equazione $\cgm{x^{2}}ap$,
ovvero cerchiamo $\sqrt{a}\in\mathbb{Z}_{p}$; si dimostra che, se
esiste $\sqrt{a}$, allora vale:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Radice quadrata}{\footnotesize{}\index{Radice quadrata@{\footnotesize{}Radice quadrata}}}}[0.4cm]
\begin{equation}
\pm a^{\left(p+1\right)/4}=\sqrt{a}\,\lor\,\pm a^{\left(p+1\right)/4}=\sqrt{-a}\label{eq:Radice-quadrata-modulo-primo}
\end{equation}
dove abbiamo l'unione di due condizioni che sono esclusive (se non
esiste la radice di $a$ allora esisterà quella di $-a$, e vale quanto
indicato in (\ref{eq:Radice-quadrata-modulo-primo}), e vice versa).
\begin{rem}
\label{oss:Condizioni-esistenza-radici}Se avessimo $\ncgm p34$ ma
$\cgm p14$ ($p$ appartenente all'altra classe di congruenze), allora
nel caso in cui non esista una delle due radici ($\sqrt{a}$ o $\sqrt{-a}$)
non esiste nemmeno l'altra.
\end{rem}
\begin{example}
\emph{Si calcoli, se esiste, la radice di 5 in modulo 11.}
\end{example}
$\checked$Cercare $\mod{\sqrt{5}}{11}$ equivale a risolvere l'equazione
\[
\cgm{x^{2}}5{11}
\]
Dato che per 11 vale (\ref{eq:Condizione-radici-quadrate-modulo-primo}),
possiamo usare la formula (\ref{eq:Radice-quadrata-modulo-primo}):
\[
\pm5^{\left(11+1\right)/4}=\mod{\pm125}{11}=\pm4
\]
Per determinare se in modulo 11 i numeri $\pm4$ siano la radice di
$5$ o di $-5$, effettuiamo l'elevamento a potenza della radice cercata:
\[
\mod{4^{2}}{11=5},\quad-4^{2}=\mod{7^{2}}{11}=5
\]
Abbiamo ottenuto che la radice quadrata di 5 modulo 11 è $\pm4$.\demo
\begin{example}
\emph{Si calcoli, se esiste, la radice di 2 in modulo 11.}
\end{example}
$\checked$Come prima, impostiamo così l'equazione da risolvere:
\[
\cgm{x^{2}}2{11}
\]
Possiamo usare (\ref{eq:Radice-quadrata-modulo-primo}), dato che
per 2 vale (\ref{eq:Condizione-radici-quadrate-modulo-primo}):
\[
\pm2^{\left(11+1\right)/4}=\mod{\pm8}{11}=\pm8
\]
Infine effettuiamo l'elevamento a potenza della radice per ottenere
il segno:
\[
\mod{8^{2}}{11}=\mod 9{11}=-2
\]
Abbiamo ottenuto che in modulo 11 non esiste la radice quadrata di
2; la radice di $-2$ però esiste, e vale $\pm8$.\demo

\subsection{Test per segno della radice}

Prendiamo un primo $p$ dispari, un $a\neq0$ in modulo $p$, allora
\begin{equation}
\cgm{a^{\left(p-1\right)/2}}{\pm1}p\label{eq:Test-segno-radice-prima}
\end{equation}
Distinguiamo i due casi:
\begin{itemize}
\item se il segno in (\ref{eq:Test-segno-radice-prima}) è $+$, allora
esiste $\sqrt{a}$ in modulo $p$;
\item se il segno in (\ref{eq:Test-segno-radice-prima}) è $-$, allora
esiste $\sqrt{-a}$ in modulo $p$.
\end{itemize}
Ricordando l'Osservazione \ref{oss:Condizioni-esistenza-radici},
si nota che il test appena mostrato permette di affermare se la radice
non sia definita, nel caso in cui $\cgm p14$ e in cui il segno in
(\ref{eq:Test-segno-radice-prima}) sia $-$.

\subsection{Radice quadrata modulo composto}

Esaminiamo il problema $\cgm{x^{2}}an$ dove $n$ sia un numero composto;
dato che $n$ sarà scomponibile in fattori primi, possiamo scomporre
la congruenza esaminata in due congruenze più semplici in modulo $p$
e $q$, sapendo che $n=p\cdot q$. Le due soluzioni ottenute si combinano
infine tramite il Teorema \ref{thm:Teorema-cinese-del-resto}.

Questo problema ha la sua difficoltà nella fattorizzazione di $n$,
al punto che la complessità computazionale del calcolo della radice
modulo $n$ equivale a quella della sua scomposizione in fattori primi.
\begin{example}
\emph{Si calcoli, se esiste, la radice di 71 in modulo 77.}
\end{example}
$\checked$Notiamo subito che $77=7\cdot11$; per il Teorema \ref{thm:Teorema-cinese-del-resto}
possiamo scomporre la congruenza in esame nelle due più semplici:
\[
\cgm{x^{2}}{71}{77}\implies\begin{cases}
\cgm{x^{2}}17\\
\cgm{x^{2}}5{11}
\end{cases}
\]
Nella precedente abbiamo già sostituito $\mod{71}7=1$ e $\mod{71}{11}=5$;
possiamo risolvere le due congruenze in modo indipendente:
\begin{enumerate}
\item la radice quadrata di 1 è comunque $\pm1$, modulo 7;
\item la radice quadrata di 5 modulo 11 si può ottenere da (\ref{eq:Radice-quadrata-modulo-primo})
e risulta $\cgm x{\pm5^{\left(11+1\right)/4}}{11}\implies\cgm x{\pm4}{11}$.
\end{enumerate}
Abbiamo ottenuto due radici da ciascuna congruenza, che possono essere
combinate in $2^{2}=4$ modi possibili, per costruire la soluzione
tramite il Teorema \ref{thm:Teorema-cinese-del-resto}.
\begin{itemize}
\item $\left\{ \cgm x17;\;\cgm x4{11}\right\} $\\
Risolviamo la combinazione delle due congruenze analizzate:
\[
\begin{array}{c}
x=\cgm{1+k\cdot7}4{11}\\
\cgm{7\cdot k}3{11}\\
\cgm k{3\cdot7^{-1}}{11}
\end{array}
\]
Per trovare l'inverso utilizziamo (\ref{eq:Osservazione-inverso-p-2}),
da cui $\mod{7^{-1}}{11}=\mod{7^{9}}{11}=8$, da cui segue che $k=\mod{24}{11}=2$;
sostituendo nella prima si ottiene
\[
x=\cgm{14+1}4{11}\implies\boxed{\cgm x{15}{77}}
\]
dal Teorema \ref{thm:Teorema-cinese-del-resto}.\bigskip{}
\item $\left\{ \cgm x17;\;\cgm x{-4}{11}\right\} $
\[
\cgm x{-15}{77}
\]
\smallskip{}
\item $\left\{ \cgm x{-1}7;\;\cgm x4{11}\right\} $
\[
\cgm x{29}{77}
\]
\smallskip{}
\item $\left\{ \cgm x{-1}7;\;\cgm x{-4}{11}\right\} $
\[
\cgm x{-29}{77}
\]
\end{itemize}
Non è detto che le radici siano sempre 4, in questo caso esistevano
tutte le radici per ciascuna congruenza in cui è stata scomposta quella
iniziale.\demo

\subsection{Residui quadratici}

Abbiamo chiamato gli elementi di $\mathbb{Z}_{p}^{*}$ residui modulo
$p$; i residui quadratici sono residui che corrispondono anche al
quadrato di qualche elemento dello stesso insieme $\mathbb{Z}_{p}^{*}$.

Chiamiamo $a_{q}\in\mathbb{Z}_{p}^{*}$i residui quadratici per cui
valga
\[
\cgm{a_{q}}{\left(\pm b\right)^{2}}p
\]
con $b\in\mathbb{Z}_{p}^{*}$ un elemento dell'insieme a cui appartiene
anche $a_{q}$.

Osserviamo che $p\in\left\{ 1,\,2,\,\ldots,\,\frac{p-1}{2}\right\} $,
poiché i residui a partire da $\frac{p-1}{2}+1$ sono i residui negativi
dei precedenti dal minore al maggiore ($-1=p-1$).
\begin{example}
\emph{\label{exa:Trovare-i-residui}Trovare i residui quadratici dell'insieme
$\mathbb{Z}_{11}^{*}$.}
\end{example}
$\checked$Otteniamo subito che nell'insieme analizzato ci sono $\frac{p-1}{2}=\frac{11-1}{2}=5$
residui quadratici; possiamo ottenerli tramite il test (\ref{eq:Test-segno-radice-prima}):
\[
\ncgm{a^{\left(p-1\right)/2}}{+1}p\implies a\text{ \textbf{non} è residuo quadratico!}
\]
Effettuiamo questo test per ciascun elemento di $\mathbb{Z}_{11}^{*}$:
\[
\begin{array}{ll}
\cgm{1^{5}}{\boxed{1}}{11} & \cgm{6^{5}}{-1}{11}\\
\cgm{2^{5}}{-1}{11} & \cgm{7^{5}}{-1}{11}\\
\cgm{3^{5}}{\boxed{1}}{11} & \cgm{8^{5}}{-1}{11}\\
\cgm{4^{5}}{\boxed{1}}{11} & \cgm{9^{5}}{\boxed{1}}{11}\\
\cgm{5^{5}}{\boxed{1}}{11} & \cgm{10^{5}}{-1}{11}
\end{array}
\]
Raccogliendo i risultati dei test con la congruenza a $+1$, possiamo
scrivere l'insieme dei residui quadratici di $\mathbb{Z}_{11}^{*}$:
\[
a_{q}=\left\{ 1,\,3,\,4,\,5,\,9\right\} 
\]
\demo
\begin{rem}
Un modo più rapido per ottenere i residui quadratici consiste nel
sfruttare il fatto che essi saranno i quadrati dei primi $\frac{p-1}{2}$
elementi dell'insieme dei residui: 
\[
a_{q}=\left\{ 1^{2},\,\ldots,\,\left(\frac{p-1}{2}\right)^{2}\right\} 
\]
Riprendendo la consegna dell'Esempio \ref{exa:Trovare-i-residui},
i residui quadratici di $\mathbb{Z}_{11}^{*}$ si ottengono come:
\[
\begin{array}{lll}
\mod{1^{2}}{11}=1 & \mod{3^{2}}{11}=9 & \mod{5^{2}}{11}=3\\
\mod{2^{2}}{11}=4 & \mod{4^{2}}{11}=5
\end{array}\implies a_{q}=\left\{ 1,\,4,\,9,\,5,\,3\right\} 
\]
Otteniamo gli stessi residui quadratici trovati con i test, in ordine
diverso.
\end{rem}

\chapter{Cifrari elementari}

\section{Introduzione}

Facendo riferimento alla figura \ref{fig:Scenario-fondamentale- comunicazione},
possiamo individuare la caratteristica del sistema di cifratura modellizzato:
esso usa la stessa chiave $k$ per la cifratura e la decifratura del
messaggio; ammettiamo che essa sia consegnata al destinatario tramite
un canale sicuro.

Il testo in chiaro è definito all'interno di tutti i possibili messaggi
in chiaro componibili con l'alfabeto a disposizione ($p\in\mathscr{P}$),
il messaggio cifrato è anch'esso definito all'interno di un insieme
di ogni possibile messaggio cifrato componibile ($c\in\mathscr{C}$),
infine la chiave appartiene all'insieme di tutte le possibili chiavi
componibili ($k\in\mathscr{K}$).

Ogni chiave, all'interno dello spazio delle chiavi, è definita una
regola di cifratura ($\forall k\in\mathscr{K}\tc E_{k}\in\mathscr{E}$)
e anche una regola di decifratura ($\forall k\in\mathscr{K}\tc D_{k}\in\mathscr{D}$),
entrambe dipendenti da $k$.

Deve valere che la cifratura sia invertibile con la decifratura, ovvero
$\forall k\in\mathscr{K},\,p\in\mathscr{P},\,c\in\mathscr{C}\tc c=E_{k}\left(p\right)\land p=D_{k}\left(c\right)$;
in caso contrario la decifratura non sarebbe più possibile (collisioni
durante la cifratura di messaggi differenti).

\section{Cifrari a scorrimento e sostituzione}

\subsection{Cifrario di Cesare}

Il cifrario di Cesare utilizza uno scorrimento dell'alfabeto, la chiave
stessa è un simbolo dell'alfabeto:
\[
\mathscr{P}=\mathscr{C}=\mathscr{K}=\mathbb{Z}_{n}
\]
Si verifica nel caso dell'alfabeto inglese vale $n=26$; la funzione
di cifratura e di decifratura si indicano come:
\[
\begin{array}{c}
c=E_{k}\left(p\right)=\mod{\left(p+k\right)}n\\
p=D_{k}\left(c\right)=\mod{\left(c-k\right)}n
\end{array}
\]
Possiamo attaccare questo cifrario con una ricerca esaustiva dello
spazio delle chiavi, sapendo che $\left|\mathscr{K}\right|=n$, oppure
possiamo confrontare un testo in chiaro noto con un testo cifrato
per ottenere la chiave ($k=p-c$).

Chiamiamo questo tipo di cifrario \emph{mono-alfabetico}, ovvero ad
ogni carattere corrisponde un carattere.

\subsection{Cifrario affine\label{subsec:Cifrario-affine}}

Utilizza una combinazione lineare applicata al testo in chiaro; per
questo cifrario vale:
\[
\mathscr{P}=\mathscr{C}=\mathbb{Z}_{n},\,\mathscr{K}=k\left(a,\,b\right)
\]
La funzione di cifratura e di decifratura si indicano come:
\[
\begin{array}{c}
c=E_{k}\left(p\right)=\mod{\left(ap+b\right)}n\\
p=D_{k}\left(c\right)=\mod{\left(c-b\right)a^{-1}}n
\end{array}
\]
Bisogna prendere $a,\,b\in\mathbb{Z}_{n}$ e per la presenza dell'inversione
di $a$, è necessario che esso sia primo relativo a $n$ ($a\perp n$);
se così non fosse, si verificherebbero delle collisioni nella cifratura.

\subsection{Cifrario a sostituzione}

Ogni carattere è sostituito da un'altro, secondo una tabella arbitraria;
esso è la generalizzazione dei due precedenti cifrari (la chiave è
una permutazione dell'alfabeto), e vale
\[
\mathscr{P}=\mathscr{C}=\mathbb{Z}_{n},\,\left|\mathscr{K}\right|=n!
\]
La chiave è la tabella di sostituzione, e le funzioni di cifratura
e decifratura sono determinate dalle sostituzioni indicate nella tabella.

Possiamo attaccare questo cifrario (e tutti gli altri cifrari mono-alfabetici)
analizzando l'entropia dei singoli simboli dell'alfabeto: nel caso
di messaggi cifrati in linguaggio naturale, l'analisi delle frequenze
dei simboli può rivelare lettere molto usate.

Altri attacchi di questo tipo includono l'analisi della frequenza
dei digrammi e trigrammi (coppie e triple di lettere).

\subsection{Cifrario di Vigenère}

Questo cifrario lavora su blocchi di $h$ caratteri alla volta, e
per questo viene detto poli-alfabetico. In questo caso abbiamo:
\[
\mathscr{P}=\mathscr{C}=\mathscr{K}=\left(\mathbb{Z}_{n}\right)^{h}
\]
La chiave, il testo in chiaro e il testo cifrato saranno vettori di
$h$ elementi:
\[
k=\left(k_{1},\,\ldots,\,k_{h}\right),\,p=\left(p_{1},\,\ldots,\,p_{h}\right),\,c=\left(c_{1},\,\ldots,\,c_{h}\right)
\]
Le regole di cifratura e decifratura sono le stesse del cifrario di
Cesare, applicate su ciascun elemento del vettore $p$ o $c$:
\[
\begin{array}{c}
c=E_{k}\left(p\right)=\left(\mod{p_{1}+k_{1}}n,\,\ldots,\,\mod{p_{h}+k_{h}}n\right)\\
p=D_{k}\left(c\right)=\left(\mod{c_{1}-k_{1}}n,\,\ldots,\,\mod{c_{h}-k_{h}}n\right)
\end{array}
\]
In questo cifrario gli scorrimenti per ciascun elemento del blocco
dipendono dalla posizione al suo interno; la stessa lettera verrà
cifrata in modo diverso a seconda della sua posizione nel blocco;
l'analisi di frequenza si applica, suddividendo la frequenza di un
simbolo su $h$ possibili modi di cifrarlo (la difficoltà cresce all'aumentare
di $h$).

\section{Cifrario a permutazione}

Si tratta di un cifrario a blocco (lavora su $h$ simboli alla volta),
che permuta le posizioni dei caratteri in ogni blocco. Al contrario
del cifrario a sostituzione, la permutazione in ogni blocco è indipendente.
La chiave adottata è una permutazione delle posizioni all'interno
del blocco.
\begin{example}
\emph{Dato il cifrario a permutazione con blocchi di dimensione $n=6$
e permutazione $k=\left(3,\,5,\,1,\,6,\,4,\,2\right)$, cifrare il
messaggio $p=``\text{she sells sea shells}"$ (gli spazi tra le parole
non sono caratteri dell'alfabeto).}
\end{example}
$\checked$Identifichiamo i blocchi di $n=6$ caratteri; il primo
blocco da sinistra è $\mathbb{B}_{1}=``\text{shesel}"$, che possiamo
indicare come:
\[
p=\Bigl(\begin{array}{cccccc}
{\scriptscriptstyle 1} & {\scriptscriptstyle 2} & {\scriptscriptstyle 3} & {\scriptscriptstyle 4} & {\scriptscriptstyle 5} & {\scriptscriptstyle 6}\\
\text{s,} & \text{h}, & \text{e}, & \text{s}, & \text{e}, & \text{l}
\end{array}\Bigr)
\]
A questo punto applichiamo la permutazione $k$, che sposta i simboli
del blocco nella seguente configurazione:
\[
c=\Bigl(\begin{array}{cccccc}
{\scriptscriptstyle 3} & {\scriptscriptstyle 5} & {\scriptscriptstyle 1} & {\scriptscriptstyle 6} & {\scriptscriptstyle 4} & {\scriptscriptstyle 2}\\
\text{e,} & \text{e}, & \text{s}, & \text{l}, & \text{s}, & \text{h}
\end{array}\Bigr)
\]
\demo

Questo cifrario risulta poli-alfabetico, e ogni blocco di lunghezza
$n$ può essere cifrato in $n!$ modi differenti.

\section{Proprietà fondamentali dei cifrari a blocchi}

In un cifrario a blocco di lunghezza $n$, si prende un messaggio
in chiaro e a partire da esso si ottiene un messaggio cifrato, entrambi
della stessa lunghezza ($\left|p\right|=\left|c\right|=n$).

Nell'articolo\footnote{\emph{``Communication Theory of Secrecy Systems'' }(1949), Bell
System Technical Journal} sulla crittografia pubblicato da Shannon, egli espone due proprietà
fondamentali che ogni sistema crittografico dovrebbe avere:
\begin{description}
\item [{\noun{Diffusione}}] Si ha diffusione perfetta se, cambiando 1 bit
del blocco in chiaro, tutti i bit del blocco cifrato corrispondente
cambiano in maniera apparentemente casuale, con probabilità $1/2$.
La perfetta diffusione vale anche nel senso opposto: cambiando 1 bit
del blocco cifrato, tutti i bit del blocco in chiaro corrispondente
cambiano con probabilità $1/2$.
\item [{\noun{Confusione}}] La chiave deve avere effetto su tutti i bit
del blocco cifrato: a parità di blocco in chiaro, se cambia 1 bit
della chiave, tutti i bit del blocco cifrato cambieranno, con probabilità
$1/2$.
\end{description}
Queste due proprietà si riassumono nella seguente affermazione:
\begin{prop}
\label{prop:Propriet=0000E0-fondamentali-cifrari-Shannon}Non solo
ogni bit della chiave ha effetto su \uline{tutti} i bit del blocco
cifrato, ma anche tutti i bit della chiave hanno effetto su \uline{ogni}
bit del blocco cifrato.
\end{prop}

\chapter{Cifrario DES}

\section{Introduzione}

\subsection{Nascita del DES come standard}

L'algoritmo Data Encryption Standard (DES) nasce negli anni '70 per
soddisfare la necessità degli Stati Uniti di usare un cifrario per
le comunicazioni segrete; allora l'NBS (attuale NIST) pubblica un
bando, a cui risponde IBM con l'algoritmo LUCIFER.

L'algoritmo di IBM conteneva delle tabelle di sostituzione, che furono
modificate dall'NBS: questo portò a pensare, per molti anni, che il
governo introdotto una trapdoor nelle tabelle di sostituzione, tuttavia
non fu mai trovata.

Infine il DES fu pubblicato come standard nel '77; col progredire
della potenza di calcolo nei calcolatori, questo algoritmo è divenuto
suscettibile a diversi attacchi, così sono state introdotte delle
sue varianti (compatibilmente con l'hardware legacy), come il triplo
DES (3DES).

Di per sé l'algoritmo DES è robusto, tuttavia la sua chiave di 56bit
è relativamente corta ($\left|\mathscr{K}\right|=2^{56}\simeq2^{6}\cdot10^{15}$),
e questo permette di effettuare in breve tempo un'analisi esaustiva
dello spazio delle chiavi. Oltre a questo, DES sarebbe stato vulnerabile
ad attacchi di crittoanalisi differenziale (si cerca un errore nella
realizzazione della proprietà di perfetta diffusione, prendendo un
blocco di testo in chiaro e cifrandolo, cambiando un bit alla volta
e cercando evidenza statistica all'interno del blocco cifrato) se
il suo algoritmo avesse avuto 14 \emph{round}; tuttavia la specifica
di IBM prevede 16 \emph{round} (si veda \propref{Propriet=0000E0-fondamentali-cifrari-Shannon}).

DES è un cifrario a blocchi di 64bit, che nel modo più semplice lavora
prendendo un blocco, cifrandolo e poi ripetendo il processo in modo
indipendente per il blocco successivo (modo \emph{ECB}).

\subsection{Schema Feistel}

Descriviamo l'idea dietro a questo schema con la procedura da implementare
per realizzarlo:
\begin{itemize}
\item prendiamo un blocco di bit $B_{1}$, e dividiamolo in due metà, in
modo da avere la sinistra $L_{1}$ e la destra $R_{1}$;
\item usiamo la chiave $K$ per generare una sotto-chiave di round $K_{i}$;
\item permutiamo le due metà al round $i$-esimo, facendo passare la metà
di sinistra attraverso una funzione fortemente non lineare che utilizzi
la chiave: $B_{i}=R_{i-1}\parallel L_{i-1}\oplus f\left(R_{i-1},\,K_{i}\right)$;\marginpar{La notazione $A\parallel B$ indica la concatenazione di $B$ dopo
di $A$}
\item se vi sono $n$ round in totale, non si effettua la permutazione di
$L_{i}$ ed $R_{i}$ al round $n$-esimo, e si ottiene $B_{n}=R_{n}\parallel L_{n}$
\end{itemize}
Possiamo presumere che, continuando a permutare le due metà del blocco,
grazie alla funzione $f\left(\right)$, vi sarà un'ottima diffusione
dei bit in ingresso; inoltre la confusione sarà garantita dalla presenza
delle chiavi di round $K_{i}$, generate a partire dalla chiave iniziale.

Lo schema Feistel permette di decifrare con la stessa procedura della
cifratura, utilizzando $B_{n}$ e $K_{n}$ come ingresso, e ottenendo
$B_{1}$ alla fine degli $n$ round.

\section{Algoritmo DES}

Il DES applica 16 volte (round) il blocco di Feistel, utilizzando
la seguente procedura:
\begin{enumerate}
\item si applica una permutazione iniziale (IP) fissata al blocco di 64bit
in chiaro;
\item si prende la chiave DES (da 64bit), si rimuovono gli 8bit di parità
e si utilizzano i 56bit per produrre le successive chiavi di round
$K_{i}$;
\begin{enumerate}
\item si permutano i bit della chiave da 56bit, poi essa viene divisa in
due blocchi da 28bit, rispettivamente $C_{0}$ e $D_{0}$;
\item si produce la chiave di round secondo una tabella di shift fissa (funzione
$LS_{i}$), che fa scorrere i bit delle due metà della chiave ($C_{i}$,
$D_{i}$) in modo circolare di 1 o 2 posizioni, a seconda del numero
$i$ del round: $C_{i}=LS_{i}\left(C_{i-1}\right),\,D_{i}=LS_{i}\left(D_{i-1}\right)\implies K_{i}=C_{i}\parallel D_{i}$;
\item tramite una tabella di riduzione, si estraggono dalla chiave di round
48bit, da usare nella funzione $f\left(\right)$.
\end{enumerate}
\item si prende la chiave di round $K_{i}$ e il blocco sinistro di round
$R_{i-1}$ e si genera il blocco destro $L_{i}$ tramite la funzione
$f\left(\right)$
\begin{enumerate}
\item il blocco $R_{i-1}$ in ingresso viene espanso a 48bit tramite una
tabella di espansione;
\item si somma modulo due la chiave di round al blocco espanso: $E\left(R_{i-1}\right)\oplus K_{i}$;
\item si divide il risultato da 48bit in 8 gruppi da 6bit;
\item ciascun gruppo viene modificato tramite una S-Box (8 in totale), che
prende un blocco da 6bit e lo riduce a 4bit;
\item gli 8 gruppi da 4bit sono uniti in un blocco da 32bit, che viene permutato;
\item il blocco ottenuto viene infine usato assieme alla chiave nella funzione
$f\left(\right)$.
\end{enumerate}
\end{enumerate}

\subsection*{Initial Permutation (IP)}

Essa lavora su un blocco di 64bit, e produce un'altro blocco altrettanto
lungo. Osserviamo che la permutazione iniziale, nota e fissa, non
migliora diffusione o confusione; alcune ipotesi sostengono che poteva
essere un modo per inizializzare l'hardware dell'epoca ('70).

La seguente tabella di look-up realizza la permutazione iniziale del
DES:

\subsection*{Funzione $\boldsymbol{f}$}

Essa lavora su blocchi di 32bit, e garantisce ottima diffusione grazie
alle permutazioni effettuate sui blocchi di bit.

\subsection*{S-Box}

Tabella di sostituzione che prende un blocco da 6bit, e usando il
primo e l'ultimo per indicare la riga e i 4 centrali per indicare
la colonna, si ottiene un blocco da 4bit. Infatti, la tabella dell'S-Box
contiene valori di massimo 4bit, che vengono indirizzati nel modo
seguente: se $B_{h}=\overset{{\scriptscriptstyle \text{R}_{0}}}{0}\underset{{\scriptscriptstyle \text{C}_{0}}}{0}\underset{{\scriptscriptstyle \text{C}_{1}}}{1}\underset{{\scriptscriptstyle \text{C}_{2}}}{0}\underset{{\scriptscriptstyle \text{C}_{3}}}{0}\overset{{\scriptscriptstyle \text{R}_{1}}}{1}$,
allora il valore ottenuto sarà l'elemento alla riga $01_{2}=1_{10}$
e alla colonna $0100_{2}=4_{10}$ della S-Box $h$ (righe e colonne
sono numerate a partire da 0); queste tabelle sono state progettate
per realizzare una trasformazione non lineare sui blocchi.

\subsection*{Chiave di round}

Ogni bit della chiave sarà utilizzato mediamente in 14 su 16 round;
questo permette di realizzare ottima confusione. I bit di parità della
chiave, che portano la sua lunghezza da 56 a 64bit, sono un metodo
per controllarne l'integrità (per esempio per trasmettere la chiave
senza errori, come controllo aggiuntivo).

Notiamo che il DES rispetta il principio di Kerchoffs (pagina \pageref{thm:Principio-di-Kerchoffs})
infatti la chiave deve rimanere privata, ed è l'unico ``ingrediente''
che permette di decifrare un blocco cifrato; l'algoritmo è invece
pubblico e ben definito. L'algoritmo è infatti progettato per rendere
l'analisi esaustiva dello spazio delle chiavi l'unico tipo di attacco
possibile.

\section{Modi operativi\label{sec:Modi-operativi-cifrario-blocchi}}

I cifrari a blocchi, come DES, supportano i modi operativi descritti
nelle seguenti sotto-sezioni.

\subsection*{Electronic Code Book (ECB)}

Il messaggio in chiaro è diviso in blocchi, i quali sono cifrati in
modo indipendente, utilizzando la stessa chiave:
\[
c_{i}=E_{k}\left(p_{i}\right),\quad p_{i}=E_{k}\left(c_{i}\right)
\]
Risulta facile individuare i blocchi ripetuti, inoltre è possibile
costruire una tabella con le corrispondenze tra blocchi i chiaro e
blocchi cifrati.

\subsection*{Cipher Block Chaining (CBC)}

Si tratta di un modo operativo concatenato: in qualche modo, ciascun
blocco è legato agli altri, e si ottiene l'effetto di non avere blocchi
ripetuti (questo vale per ciascun modo concatenato). CBC usa un vettore
di inizializzazione (IV), come se fosse una chiave addizionale, come
primo blocco cifrato $c_{0}$; a partire da esso, le funzioni di cifratura
e decifratura sono definite come:
\[
c_{i}=E_{k}\left(p_{i}\oplus c_{i-1}\right),\quad p_{i}=c_{i-1}\oplus D_{k}\left(c_{i}\right)
\]
Si noti che IV può essere inviato anche in chiaro.

\subsection*{Cipher Feedback (CFB)}

Si tratta di un modo concatenato. Consiste nel cifrare il vettore
di inizializzazione e poi sommarlo al blocco in chiaro; il risultato
è usato come IV per il round successivo. Questo algoritmo crea una
sequenza di bit pseudo-casuali.

Per decifrare non è necessaria una funzione specifica, ma basta ripetere
la somma in base 2 con i blocchi cifrati al posto dei blocchi in chiaro:
\[
c_{i}=p_{i}\oplus E_{k}\left(c_{i-1}\right),\quad p_{i}=c_{i}\oplus E_{k}\left(c_{i-1}\right)
\]
Lo svantaggio di questo cifrario è l'amplificazione degli errori di
trasmissione, da un blocco al suo successivo.

\subsection*{Output Feedback Mode (OFB)}

Si tratta di un modo concatenato. Consiste nel cifrare il vettore
di inizializzazione, sommarlo al blocco in chiaro, e poi usare l'IV
cifrato come ingresso per il blocco successivo. La catena di cifrature
effettuate sull'IV costituisce una PRBS (pseudo-random binary sequence,
una sequenza pseudo-casuale di bit). L'unico modo per generare la
stessa sequenza è conoscere la chiave; inoltre un errore di trasmissione
non si propaga tra i blocchi.

Le funzioni di cifratura e decifratura sono definite come:
\[
c_{i}=p_{i}\oplus E_{k}^{\left(i\right)}\left(\text{IV}\right),\quad p_{i}=c_{i}\oplus E_{k}^{\left(i\right)}\left(\text{IV}\right)
\]
dove $E_{k}^{\left(i\right)}\left(\text{IV}\right)$ è la funzione
$E_{k}$ applicata in modo ricorsivo per $i$ volte all'IV.

\subsection*{Counter Mode (CTR)}

Questo modo \uline{non} è concatenato. Consiste nel cifrare un
IV con la chiave, per poi sommarlo al blocco in chiaro; per ciascun
blocco in chiaro $i$-esimo viene usato un $\text{IV}^{\left(i\right)}\coloneqq\text{IV}+i$,
e ogni blocco cifrato è prodotto in modo indipendente; la sicurezza
di questo modo si basa unicamente su quella della funzione di cifratura
(in caso di ottima diffusione e confusione, un attaccante non può
sapere se a IV sta venendo sommato un intero e quale esso sia).

LE funzioni di cifratura e decifratura sono definite come:
\[
c_{i}=p_{i}\oplus E_{k}\left(\text{IV}^{\left(i\right)}\right),\quad p_{i}=c_{i}\oplus E_{k}\left(\text{IV}^{\left(i\right)}\right)
\]


\section{Sicurezza del DES}

\subsection{Doppio DES}

Per aumentare la sicurezza di DES potremmo provare ad utilizzare una
chiave più lunga; in tal caso, ci chiediamo se esista una chiave $K^{\prime}=K_{1}\parallel K_{2}$
tale che $\left|K^{\prime}\right|=56+56=112\text{bit}$, e per essa
si verifichi che $E_{K^{\prime}}\left(p\right)\equiv E_{K_{2}}\left(E_{K_{1}}\left(c\right)\right)$.

Se prendiamo la funzione di cifratura \emph{affine} (si veda \subsecref{Cifrario-affine}),
dove abbiamo $K_{1}=\left(a,\,b\right)$, allora possiamo cifrare
un testo in chiaro $p$ come $c_{1}=E_{K_{1}}\left(p\right)=\mod{a\cdot p+b}n$;
prendiamo un'altra chiave $K_{2}=\left(c,\,d\right)$ e con essa cifriamo
di nuovo il messaggio $p$, ottenendo $c_{2}=E_{K_{2}}\left(p\right)=\mod{c\cdot p+d}n$.

Si nota subito che, per le caratteristiche della funzione di cifratura
(combinazione lineare con la chiave), esiste $K^{\prime}=\left(a\cdot c,\,b+d\right)$
per cui vale $c^{\prime}=E_{K_{2}}\left(E_{K_{1}}\left(p\right)\right)\equiv E_{K^{\prime}}\left(p\right)=\mod{ac\cdot p+b+d}n$.
Dato che il cifrario affine forma un gruppo algebrico (chiuso rispetto
alla composizione), cifrando due volte con due chiavi $K_{1}$ e $K_{2}$
non viene aumentata la cardinalità dello spazio delle chiavi, dato
che esiste in ogni caso una chiave equivalente $K^{\prime}$ di lunghezza
identica alle singole chiavi.

Il DES non gode di questa proprietà: cifrando più volte il messaggio
in chiaro con due chiavi differenti, aumenta di $2^{\left|K\right|}$
la cardinalità dello spazio delle chiavi. Nel caso del doppio DES
(2DES), si ha una chiave $K=K_{1}\parallel K_{2}$ lunga il doppio
di una chiave singola, dunque $\left|\mathscr{K}\right|=2^{112}\simeq2^{2}\cdot10^{33}$.

Il doppio DES è suscettibile dell'attacco Meet-in-the-Middle (MiM):
questa vulnerabilità permette di analizzare al più $2^{57}$ chiavi,
invece delle $2^{112}$ totali; per ovviare al problema si è scelto
di proseguire con la composizione, ottenendo il triplo DES.

\subsection{Triplo DES}

Questo cifrario è la composizione di tre chiavi DES, che portano la
cardinalità dello spazio delle chiavi a $2^{168}$; anche con un attacco
MiM lo spazio delle chiavi si riduce al più a $2^{112}$, e al giorno
d'oggi è considerato sicuro almeno quanto l'AES, ma è meno veloce
(bisogna cifrare 3 volte con DES).

Il metodo più intuitivo per implementare il 3DES è effettuare tre
volte la cifratura con tre chiavi differenti: $c=E_{K_{1}}\left(E_{K_{2}}\left(E_{K_{3}}\left(p\right)\right)\right)$;
un approccio che utilizza solo due chiavi, senza ridurre lo spazio
delle chiavi, è il seguente:
\[
c=E_{K_{1}}\left(D_{K_{2}}\left(E_{K_{1}}\left(p\right)\right)\right),\quad p=D_{K_{1}}\left(E_{K_{2}}\left(D_{K_{1}}\left(c\right)\right)\right)
\]
Questa implementazione del triplo DES è compatibile con l'hardware
per il singolo DES.

Rivest ha proposto la seguente alternativa, chiamata DESX, che usa
tre chiavi ma effettua una sola cifratura DES, ed è sicura quanto
il 3DES standard:
\[
c=K_{3}\oplus E_{K_{2}}\left(K_{1}\oplus p\right)
\]


\subsection{Attacco Meet-in-the-Middle}

Abbiamo già osservato che DES non è un gruppo; ci chiediamo come possiamo
affrontare questa caratteristica, per ridurre lo spazio delle chiavi
nel caso di una composizione. Conduciamo un attacco di testo in chiaro
noto, partendo da una coppia corrispondente di testo in chiaro e testo
cifrato $p\leftrightarrows c$, senza conoscere la chiave.

Poniamoci nel caso di un testo cifrato ricavato tramite 2DES come
$c=E_{K_{2}}\left(E_{K_{1}}\left(p\right)\right)$, e vogliamo ottenere
$K^{\prime}=K_{1}\parallel K_{2}$. Se quanto affermato sul testo
cifrato è vero, allora applicando a $c$ la decifratura con $K_{2}$
si ottiene
\begin{equation}
D_{K_{2}}\left(c\right)=E_{K_{1}}\left(p\right)\label{eq:MiM-2DES}
\end{equation}
Effettuiamo una esplorazione esaustiva dello spazio delle chiavi $K_{1}$
memorizzando i risultati in una tabella, per cui sarà necessario memorizzare
$2^{56}$ valori da 8Byte (64bit) ovvero circa 0.5EB; poi effettuiamo
la stessa analisi per lo spazio delle chiavi $K_{2}$, questa volta
evitando di memorizzare i risultati ma confrontando ciascuna chiave
trovata con i valori di $K_{1}$ salvati.

Notiamo che saranno necessarie al più $2\cdot2^{56}=2^{57}$ operazioni
di cifratura e decifratura con DES, e al più $2^{112}$ confronti.

\section{Sicurezza delle password}

\subsection{Funzioni di hash\label{subsec:Funzioni-di-hash} }

Per ragioni di sicurezza, una password non viene mai memorizzata in
chiaro; in pratica, si usa una funzione di \emph{hash}. Si tratta
di una funzione con le seguenti caratteristiche:
\begin{itemize}
\item accetta un ingresso di lunghezza arbitraria, produce una uscita di
lunghezza fissa;
\item non è invertibile (ci sono infiniti messaggi con lo stesso hash in
uscita dalla funzione);
\item sia unidirezionale (presa una uscita $y\left(x\right)$, sia impossibile
trovare uno qualunque degli infiniti $x$ che produca quell'uscita);
\item goda di ottima diffusione.
\end{itemize}
Usando una simile funzione, possiamo memorizzare lo hash della password,
e confrontarlo con l'hash calcolato sulla password quando fornita.

È possibile attaccare queste funzioni provando un gran numero di ingressi
casuali differenti, rispetto al numero delle possibili uscite; la
sicurezza viene determinata dalla lunghezza dell'uscita.

Si può mitigare questo attacco scegliendo una funzione di hash particolarmente
lenta.

\subsection{Attacco del vocabolario}

Dato che quasi nessuno sceglie una stringa veramente casuale come
password, è possibile attaccare l'hash corrispondente generando tutti
gli hash di tutte le parole di una lingua, apportando eventuali variazioni
sulle singole parole (aggiunta di un numero, iniziale maiuscola, eccetera...)
e poi confrontando gli hash ottenuti con quelli nel file delle password.

All'interno di sistemi con un gran numero di utenti, la probabilità
di trovare una password ``banale'' per almeno qualche utenza è molto
elevata.

La contromisura migliore è applicare un \emph{salt} (``sale'') alla
password; esso è una stringa di bit, memorizzata in chiaro nel file
delle password. L'hash ``salato'' è calcolato sulla stringa ottenuta
dalla concatenazione del sale con la password.

Il sale non aumenta la complessità dell'attacco sul singolo utente,
bensì ha il vantaggio che, nel caso di un attacco del vocabolario
su numerose utenze, essi abbiano tutti un hash diverso, anche a parità
di password, per via del sale (che sarà diverso per ogni utente).
Un attaccante dovrà calcolare l'hash per ogni parola del vocabolario,
per ogni sale possibile.

Nei sistemi UNIX, le password sono salate con un salt a 12bit, e la
funzione di hash è basata su DES; tradizionalmente si troncava la
password utente a 64bit (8 caratteri), da questi si ottenevano i primi
7 bit di ciascun Byte (per rappresentare solo i caratteri stampabili),
e i 56bit così ottenuti erano usati come chiave DES. Questa chiave
$K_{h}$ è poi usata per cifrare un blocco di 0 da 64bit, con 25 round
di DES; a ogni round, i 12bit del sale sono usati per perturbare la
funzione di cifratura (modificando le S-Box, rende inutile l'implementazione
hardware a priori). Infine sale e blocco cifrato sono codificati in
base 64.

La funzione così realizzata è reputata unidirezionale: infatti ottenere
la password senza conoscere la chiave e con un DES da più di 16 round,
per giunta perturbato dal sale, è un problema difficile.

\chapter{Cifrario AES}

\section{Introduzione}

Nel '97, quando DES era ancora in vigore, il NIST fece un bando per
la creazione di un nuovo standard crittografico, destinato alle informazioni
governative; l'algoritmo selezionato fu chiamato AES. Si tratta di
un cifrario a blocchi da 128bit, con chiave a 128, 192 o 256bit.

La procedura per selezionare l'algoritmo fu gestita in modo pubblico
e trasparente, attraverso delle conferenze; prima di selezionare l'algoritmo
che sarebbe divenuto AES, arrivarono ``in finale'' i cinque seguenti
algoritmi (oggi ancora usati, perché paragonabili all'AES nella sicurezza):
MARS, RC6, Rijndael, Serpent, Twofish.

Nel 2000 viene infine selezionato Rijndael, che viene rinominato in
AES; in particolare, Rijndael definisce una famiglia di cifrari: per
AES viene selezionato una dimensione del blocco di 128bit e chiavi
da 128 a 265bit.

Dal punto di vista matematico, AES non si basa su uno schema Feistel,
ma su una rete di sostituzioni e trasformazioni; a seconda della dimensione
della chiave, il Rijndael effettua 10, 12 o 14 cicli su ciascun blocco,
e può essere utilizzato in tutti i modi operativi concatenati mostrati
per il DES (vedere \secref{Modi-operativi-cifrario-blocchi}).

\section{Algoritmo AES}

Per maggiore semplicità, analizziamo il caso di Rijndael con chiave
a 128bit, e 10 round. Osserviamo che i blocchi da 128bit sono suddivisi
in 16Byte, organizzati in matrici $4\times4$; tutti gli elementi
di queste matrici sono ottetti del campo $\mathcal{GF}\left(2^{8}\right)$
e rappresentano i polinomi al suo interno, dove il polinomio irriducibile
per definire il campo è $P\left(x\right)=x^{8}+x^{4}+x^{3}+x^{2}+x+1$.
L'ottetto di zeri non è invertibile, tuttavia deve essere ammissibile
nel cifrario: si consideri l'elemento nullo come inverso di sé stesso.

Ogni round del Rijndael è composto d 4 livelli, che operano sulla
matrice $4\times4$ che rappresenta il blocco da 128bit:
\begin{itemize}
\item Substitute Byte (SB): tabella di sostituzione, simile alle S-Box del
DES, ma costruita algebricamente in maniera trasparente;
\item Shift Row (SR): scorrimento delle righe della matrice a sinistra;
\item Mix Column (MC): scorrimento delle colonne a sinistra, evita la degenerazione
del cifrario in 4 cifrari applicati alle singole colonne della matrice;
\item Add Round Key (ARK): per ciascun ciclo si aggiunge una chiave di round,
derivata da quella iniziale a 128bit.
\end{itemize}
L'algoritmo usa round e livelli nel modo seguente:
\begin{enumerate}
\item ARK con chiave di round 0;
\item nove round che usano i livelli $\text{SB}\rightarrow\text{SR}\rightarrow\text{MC}\rightarrow\text{ARK}$,
con le chiavi di round dalla 1 alla 9;
\item un ultimo round che usa i livelli $\text{SB}\rightarrow\text{SR}\rightarrow\text{ARK}$,
con la chiave di round 10.
\end{enumerate}
Le differenze col DES riguardano l'assenza del Feistel, rispetto al
rimescolamento dei bit dato dai quattro livelli di ciascun round;
il risultato è una apparente diffusione perfetta già dal secondo round.
Inoltre, tutte le operazioni sugli ottetti del blocco, sono all'interno
del campo $\mathcal{GF}\left(256\right)$.

\subsection*{SB}

Sostituzione\marginpar{La notazione $\boldsymbol{A}$ in maiuscolo corsivo e grassetto, indica
che A è una matrice} non lineare applicata ai Byte (elementi) della matrice; secondo una
matrice di sostituzione con 16 righe e 16 colonne, numerate a partire
da 0, indirizzate tramite gli stessi bit degli ottetti, nel modo seguente:
sia $\boldsymbol{A}$ la matrice che rappresenta il blocco di partenza,
e sia $a_{1,0}=10001011$; sia $\boldsymbol{B}$ la matrice ottenuta
al termine del livello SB; allora $b_{1,0}$ si ottiene prendendo
il valore indicato all'incrocio della riga 8 con la colonna 11, nella
tabella di sostituzione, e sostituendolo al valore di un elemento
di $\boldsymbol{A}$ ( per esempio $a_{i,j}=\overset{\text{riga}}{\overbrace{1000}}\underset{\text{colonna}}{\underbrace{1011}}\rightarrow61$).

Questa tabella si calcola nel modo seguente:
\begin{itemize}
\item l'input è un ottetto di bit $a_{i,j}=x_{7}x_{6}x_{5}x_{4}x_{3}x_{2}x_{1}x_{0}$
\item calcoliamo il suo inverso in $\mathcal{GF}\left(256\right)\ni a_{i,j}^{-1}=y_{7}y_{6}y_{5}y_{4}y_{3}y_{2}y_{1}y_{0}$
(assumendo che 000000000 sia l'inverso di sé stesso)
\item prendiamo l'ottetto $a_{i,j}^{-1}$, scriviamolo partendo dal bit
meno significativo e come un vettore colonna $\left(y_{0}y_{1}y_{2}y_{3}y_{4}y_{5}y_{6}y_{7}\right)^{\text{T}}$
\item computiamo $b_{i,j}=z_{7}z_{6}z_{5}z_{4}z_{3}z_{2}z_{1}z_{0}$ e scriviamolo
come $\left(z_{0}z_{1}z_{2}z_{3}z_{4}z_{5}z_{6}z_{7}\right)^{\text{T}}$
\end{itemize}
per computare $b_{i,j}$ usiamo la seguente trasformazione, per diffondere
e confondere ulteriormente i bit:
\[
b_{i,j}=\begin{bmatrix}1 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\
1 & 1 & 0 & 0 & 0 & 1 & 1 & 1\\
1 & 1 & 1 & 0 & 0 & 0 & 1 & 1\\
1 & 1 & 1 & 1 & 0 & 0 & 0 & 1\\
1 & 1 & 1 & 1 & 1 & 0 & 0 & 0\\
0 & 1 & 1 & 1 & 1 & 1 & 0 & 0\\
0 & 0 & 1 & 1 & 1 & 1 & 1 & 0\\
0 & 0 & 0 & 1 & 1 & 1 & 1 & 1
\end{bmatrix}\cdot\begin{bmatrix}y_{0}\\
y_{1}\\
y_{2}\\
y_{3}\\
y_{4}\\
y_{5}\\
y_{6}\\
y_{7}
\end{bmatrix}+\begin{bmatrix}1\\
1\\
0\\
0\\
0\\
1\\
1\\
0
\end{bmatrix}
\]


\subsection*{SR}

Spostamento a sinistra delle 4 righe rispettivamente di 0, 1, 2, 3
passi (la prima riga rimane immutata, la seconda è spostata di 1,
ecc...); sia $\boldsymbol{B}$ la matrice proveniente dal livello
SB, allora da questo livello otteniamo la seguente matrice $\boldsymbol{C}$:
\[
C=\begin{bmatrix}c_{0,0} & c_{0,1} & c_{0,2} & c_{0,3}\\
c_{1,0} & c_{1,1} & c_{1,2} & c_{1,3}\\
c_{2,0} & c_{2,1} & c_{2,2} & c_{2,3}\\
c_{3,0} & c_{3,1} & c_{3,2} & c_{3,3}
\end{bmatrix}=\begin{bmatrix}b_{0,0} & b_{0,1} & b_{0,2} & b_{0,3}\\
b_{1,1} & b_{1,2} & b_{1,3} & b_{1,0}\\
b_{2,2} & b_{2,3} & b_{2,0} & b_{2,1}\\
b_{3,3} & b_{3,0} & b_{3,1} & b_{3,2}
\end{bmatrix}
\]


\subsection*{MC}

Prendiamo la matrice $\boldsymbol{C}$ ottenuta dal livello precedente
ed effettuiamo il suo prodotto per una matrice $M$ per ottenere $\boldsymbol{D}=\boldsymbol{M}\cdot\boldsymbol{C}$,
nel modo seguente:
\[
D=\begin{bmatrix}00000010 & 00000011 & 00000001 & 00000001\\
00000001 & 00000010 & 00000011 & 00000001\\
00000001 & 00000001 & 00000010 & 00000011\\
00000011 & 00000001 & 00000001 & 00000001
\end{bmatrix}\cdot\begin{bmatrix}c_{0,0} & c_{0,1} & c_{0,2} & c_{0,3}\\
c_{1,0} & c_{1,1} & c_{1,2} & c_{1,3}\\
c_{2,0} & c_{2,1} & c_{2,2} & c_{2,3}\\
c_{3,0} & c_{3,1} & c_{3,2} & c_{3,3}
\end{bmatrix}
\]
Per garantire la decifratura, sarà necessario che la matrice $\boldsymbol{M}$
sia invertibile; l'inversa $\boldsymbol{M}^{-1}$ avrà più 1 che 0,
e per questo la decifratura in AES è più lenta (di poco) della cifratura.

\subsection*{ARK}

La chiave di round viene sommata bit a bit col blocco ottenuto al
livello precedente: $\boldsymbol{E}=\boldsymbol{D}\oplus\boldsymbol{K}^{\left(i\right)}$.
Ad ogni round $i$-esimo ricaviamo una chiave di 16Byte a partire
da quella iniziale; se abbiamo chiavi da 128bit l'algoritmo prevede
10 round e quindi saranno necessarie 11 chiavi di round.

Esprimendo la chiave iniziale come matrice $4\times4$ chiamata $\boldsymbol{K}$,
possiamo indicarla come la giustapposizione di 4 colonne di 4 elementi
ciascuna; le 11 chiavi necessarie saranno costituite in totale da
44 colonne di 4Byte ciascuna. Allora le colonne 0, 1, 2, 3 appartengono
alla chiave $\boldsymbol{K}^{\left(0\right)}$, le colonne 4, 5, 6,
7 costituiscono $\boldsymbol{K}^{\left(1\right)}$, e così via.

Le altre 40 colonne si ottengono dalle 4 iniziali nel modo seguente;
sia $\vec{w}\left(i\right)$ la $i$-esima colonna:
\[
\begin{cases}
\vec{w}\left(i\right)=\vec{w}\left(i-4\right)\oplus\vec{w}\left(i-1\right) & \mod i4\neq0\\
\vec{w}\left(i\right)=\vec{w}\left(i-4\right)\oplus T\left[\vec{w}\left(i-1\right)\right] & \mod i4=0
\end{cases}
\]
La trasformazione $T$ è definita nel modo seguente; sia $r\left(i\right)=00000010^{\left(i-4\right)/4}\in\mathcal{GF}\left(2^{8}\right)$,
e sia SB il livello Substitute Byte dell'algoritmo Rijndael:
\[
T\left[\left(a,\,b,\,c,\,d\right)\right]=\begin{bmatrix}a\\
b\\
c\\
d
\end{bmatrix}\rightarrow\begin{bmatrix}b\\
c\\
d\\
a
\end{bmatrix}\rightarrow\text{SB}\rightarrow\begin{bmatrix}e\\
f\\
g\\
h
\end{bmatrix}\rightarrow\begin{bmatrix}e\oplus r\left(i\right)\\
f\\
g\\
h
\end{bmatrix}
\]
In questo modo si ottiene la chiave di round come:
\[
\boldsymbol{K}^{\left(i\right)}=\left[\vec{w}\left(4i\right),\,\vec{w}\left(4i+1\right),\,\vec{w}\left(4i+2\right),\,\vec{w}\left(4i+3\right)\right]
\]


\subsection*{Decifratura}

I quattro livelli di ciascun ciclo dell'algoritmo Rijndael sono invertibili:
\begin{itemize}
\item Inverted Substitute Byte (ISB): tabella di sostituzione inversa a
quella del livello SB;
\item Inverted Shift Row (ISR): scorrimento delle righe a destra invece
che a sinistra;
\item Inverted Mix Column (IMC): si usa l'inversa della matrice $\boldsymbol{M}$:
$\boldsymbol{C}=\boldsymbol{M}^{-1}\cdot\boldsymbol{D}$;
\item Add Round Key (ARK): questo livello, basato sulla somma bit a bit,
è l'inverso di sé stesso.
\end{itemize}
Possiamo decifrare un blocco applicando all'inverso i 10 round:
\begin{enumerate}
\item il primo round usa $\boldsymbol{K}^{\left(10\right)}$ e i livelli
$\text{ARK}\rightarrow\text{ISR}\rightarrow\text{ISB}$;
\item i nove round successivi usano le chiavi dalla 9 alla 1, con i livelli
$\text{ARK}\rightarrow\text{IMC}\rightarrow\text{ISR}\rightarrow\text{ISB}$;
\item un ultimo round usa ARK con la chiave $\boldsymbol{K}^{\left(0\right)}$.
\end{enumerate}

\section{Sicurezza dell'AES}

Al contrario del DES, le cui S-Box avevano fatto sorgere il dubbio
della presenza di trapdoor segrete, in AES la tabella di sostituzione
è ottenuta tramite una procedura algebrica definita; inoltre, il livello
Substitute Byte consente di ottenere un elevato livello di non linearità,
con la trasposizione dei vettori.

Ad oggi, gli unici attacchi che funzionano contro AES, sfruttano debolezze
dell'implementazione, e non dell'algoritmo.

\chapter{Successioni Pseudo-casuali}

\section{Sequenze binarie pseudo-casuali (PRBS)\label{sec:Sequenze-binarie-pseudo-casuali}}

Se pensiamo che l'AES sia sicuro, dobbiamo limitare questa osservazione
alla pratica: infatti, anche se non è possibile trovare la chiave
di cifratura in un periodo di tempo accettabile, dal punto di vista
teorico e con un tempo infinito a disposizione, è possibile eludere
la sicurezza di AES.

Esiste tuttavia un cifrario inviolabile anche dal punto di vista teorico:
prendiamo una sequenza di bit da cifrare $p$ e la sommiamo bit a
bit con una sequenza casuale $r$, ottenendo la sequenza cifrata:
\[
c=p\oplus r
\]
La sequenza $r$ deve essere veramente casuale (nessuna autocorrelazione
del primo o secondo ordine) e impredicibile, ottenuta per esempio
osservando un fenomeno aleatorio. Per decifrare un $c$ ottenuto in
questo modo, è necessario sommare bit a bit a $c$ la stessa sequenza
casuale $r$ usata nella cifratura.

Osserviamo che la sequenza casuale $r$ deve avere la stessa lunghezza
dei dati da cifrare ($\left|r\right|=\left|p\right|$, per consentire
la somma bit a bit con $p$), ed essa deve essere trasportata in modo
sicuro al destinatario; inoltre, la sequenza $r$ va usata una volta
sola, per mantenere la sua impredicibilità.

Questo sistema di cifratura ha rilevanza se possiamo generare una
sequenza $r$ pseudo-casuale, ovvero a parità di inizializzazione,
è possibile generare in modo indipendente la stessa sequenza $r$.

\subsection{Generatore lineare congruenziale}

Ricaviamo l'elemento $i$-esimo della sequenza pseudo-casuale attraverso
una trasformazione lineare applicata al precedente, modulo un composto:
\[
x_{i}=\mod{\left(a\cdot x_{i-1}+b\right)}n
\]
La sequenza viene generata a partire dai tre parametri $a$, $b$,
$n$ e il suo sviluppo è determinato dal seme iniziale, il primo elemento
$x_{0}$.

Anche se il modulo aggiunge della complessità alla trasformazione
lineare, in molti casi è possibile ottenere i tre parametri osservando
abbastanza a lungo la sequenza $r$.

\subsection{Funzione unidirezionale}

Un metodo algoritmicamente sicuro ma computazionalmente non efficiente,
consiste nell'impiego di funzioni unidirezionali nella generazione
della sequenza. Le funzioni non invertibili $y=f\left(x\right)$ permettono
di tentare di trovare un $\overline{y}$ provando per tentativi degli
$\overline{x}$ tali che $\overline{y}=f\left(\overline{x}\right)$,
mentre le funzioni unidirezionali (invertibili o meno) non permettono
di ``tirare a indovinare'' l'$\overline{x}$ che genera un $\overline{y}$
(anche provando per tentativi non è possibile trovare $\overline{x}$).

Una sequenza pseudo-casuale del genere si inizializza con un seme
$x_{0}$, mentre l'elemento $i$-esimo si ottiene come:
\[
x_{i}=f\left(x_{0}+i\right)
\]
Se la funzione unidirezionale $f\left(\right)$ è la funzione di cifratura
del DES con chiave $K=x_{0}+i$ (va applicata la funzione per generare
ciascun bit $i$-esimo), abbiamo una buona funzione unidirezionale
(genera una sequenza apparentemente casuale, per invertire la funzione
sarebbe necessario trovare la chiave DES) che tuttavia risulta non
pratica per l'elevato costo computazionale.

\subsection{Generatore ai residui quadratici (Blum, Blum e Shub)}

Si prendano due primi $p$ e $q$ grandi, entrambi congruenti a 3
in modulo 4:
\[
p\gg1,\,q\gg1\tc\cgm p34\land\cgm q34
\]
Definiamo il prodotto $n=p\cdot q$, e prendiamo un numero casuale
che non abbia $p$ o $q$ tra i suoi fattori ($x\perp n$).

La successione viene inizializzata a partire da un residuo quadratico
$\cgm{x_{0}}{x^{2}}n$; l'$i$-esimo elemento viene calcolato come:
\[
\cgm{x_{i}}{x_{i-1}^{2}}n
\]
mentre il bit $i$-esimo della sequenza sarà il bit meno significativo
dell'elemento $x_{i}$ ($b_{i}={\scriptstyle \text{LSB}}\left(x_{i}\right)$):

Normalmente, la sequenza di bit $\left\{ b_{i}\right\} $ ha una statistica
ben fatta (probabilità circa$\nicefrac{1}{2}$ che esca 0 o 1), ha
autocorrelazione nulla, ed assenza di memoria ($b_{i}$ non dipende
da $b_{i-1}$). La differenza con una sequenza casuale vera è che
essa è periodica (dovrà essere garantito un periodo lungo); inoltre
si tratta di un generatore lento (per il calcolo di un quadrato per
ciascun bit).

Con una sequenza generata in questo modo, è possibile prevedere un
bit successivo $b_{i+k}$ una volta noti un $x_{i}$ e $n$; tuttavia
è impossibile ottenere un $b_{i-h}$, poiché sarebbe necessario calcolare
la radice quadrata modulo $n$, e quindi sono necessari i fattori
$p$ e $q$ (e con $p$ e $q$ scelti adeguatamente il problema della
fattorizzazione risulta impraticabile).
\begin{example}
\emph{Usare il generatore di Blum, Blum e Shub con $p=43$ e $q=31$,
cercando di determinare il suo periodo.}
\end{example}
$\checked$Ricaviamo subito $n=p\cdot q=1333$; scegliamo inoltre
$x_{0}=50\perp1333$. Applichiamo l'algoritmo:
\[
\begin{array}{ccc}
i & x_{i} & b_{i}\\
0 & \cgm{50^{2}}{\boldsymbol{1167}}{1333} & 1\\
1 & \cgm{1167^{2}}{\boldsymbol{896}}{1333} & 0\\
2 & \cgm{896^{2}}{\boldsymbol{350}}{1333} & 0\\
3 & \cgm{350^{2}}{\boldsymbol{1197}}{1333} & 1\\
4 & \cgm{1197^{2}}{\boldsymbol{1167}}{1333} & 1
\end{array}
\]
Notiamo che il periodo vale 4 (il generatore continuerà a produrre
$1,\,0,\,0,\,1\ldots$).\demo

\section{Periodo del generatore ai residui quadratici}

\subsection{Calcolare il periodo}

Gli studi di Blum, Blum e Shub hanno mostrato che il periodo $\tau$
della sequenza del loro generatore, è un divisore della funzione della
funzione di Carmichael, del prodotto $n=p\cdot q$:
\[
\tau\backslash\lambda\left(\lambda\left(n\right)\right),\,n=p\cdot q
\]
La funzione di Carmichael di un numero $n$ è, a sua volta, un divisore
del toziente di $n$ ($\lambda\left(n\right)\backslash\varphi\left(n\right)$);
essa si calcola nel modo seguente; preso un intero composto positivo
$n$, esso può essere espresso come prodotto di fattori primi $p_{i}$,
ciascuno con la propria potenza $a_{i}$:
\[
n=p_{1}^{a_{1}}\cdot p_{2}^{a_{2}}\cdot\ldots\cdot p_{r}^{a_{r}}
\]
La funzione di Carmichael è pari al minimo comune multiplo degli ordini
(tozienti) di ciascuno dei $p_{i}^{a_{i}}$, per $i$ da 1 a $r$
(elementi del gruppo moltiplicativo degli elementi invertibili di
$\mathbb{Z}_{n}$):\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Funzione di Carmichael}{\footnotesize{}\index{Carmichael, funzione di@{\footnotesize{}Carmichael, funzione di}}}}[0.2cm]
\begin{equation}
\lambda\left(n\right)=\mcm{\left\{ \varphi\left(p_{i}^{a_{i}}\right)\right\} }{i\in\left[1,\,r\right]}\label{eq:Funzione-di-Carmichael}
\end{equation}

Prendiamo in mano le ipotesi del Teorema \ref{thm:Teorema-piccolo-Fermat},
il quale afferma che preso un intero $a$ e un primo $p$, vale $\cgm{a^{p-1}}1p$;
se $p$ non fosse primo, il Teorema \ref{thm:Teorema-Eulero} ci dice
che $\cgm{a^{\varphi\left(p\right)}}1p$. Nel primo caso, ci chiediamo
infine se esista un intero $q<p-1$ per cui il residuo modulo $p$
di $a$ vale sempre 1 ($\cgm{a^{q}}1p$); in generale questo dipende
da $a$, e chiamiamo questo intero $\ord a=q$.

Nel secondo caso, ci chiediamo se esista un divisore di $\varphi\left(p\right)$
per cui il residuo modulo $p$ di $a$ sia sempre 1; questo accade
per $\lambda\left(p\right)$, che possiamo considerare come l'analogo
dell'ordine di $a$.

Facciamo un paragone tra ordine e funzione di Carmichael:
\begin{itemize}
\item $\ord a\in\mathbb{Z}_{p}$ è il minimo intero $n$ tale che $\cgm{a^{n}}1p$;
l'ordine di $a$ è massimo $p-1$ o comunque un suo divisore.
\item $\lambda\left(n\right)\in\mathbb{Z}_{p}$ è il minimo intero $N$
tale che $\cgm{a^{N}}1p$; $\lambda\left(n\right)$ è al massimo $\varphi\left(n\right)$
o comunque un suo divisore.
\end{itemize}
\begin{example}
Calcolare il periodo del generatore BBS (Blum, Blum e Shub), con $p=23,\,q=19,\,x_{0}=7$.
\end{example}
$\checked$Sia $p$ che $q$ sono congruenti a 3 modulo 4, inoltre
$x_{0}$ essendo primo è sicuramente primo relativo rispetto a $p\cdot q=n=437$.
Calcoliamo la successione (si ricorda che tutti i conti per la colonna
$x_{i}$ sono quadrati in modulo $n$, mentre la colonna $b_{i}$
contiene l'LSB corrispondente):\\
\begin{table}[!h]
\begin{tabular}{cc}
$\begin{array}{ccc}
i & x_{i} & b_{i}\\
0 & 49 & 1\\
1 & 216 & 0\\
2 & 334 & 0\\
3 & 121 & 1\\
4 & 220 & 0\\
5 & 330 & 0
\end{array}$ & $\begin{array}{ccc}
i & x_{i} & b_{i}\\
6 & 87 & 1\\
7 & 140 & 0\\
8 & 372 & 0\\
9 & 292 & 0\\
10 & \boxed{49} & 1\\
\\
\end{array}$\tabularnewline
\end{tabular}
\end{table}
\\
Dalla successione costruita osserviamo che il periodo vale 10. Sappiamo
che il periodo sarà un divisore di $\lambda\left(\lambda\left(n\right)\right)$;
calcoliamo $\lambda\left(n\right)$:
\begin{align*}
\lambda\left(n\right) & =\lambda\left(437\right)=\lambda\left(23\cdot19\right)=\mcm{\varphi\left(23\right)}{\varphi\left(19\right)}\\
 & =\mcm{22}{18}=\mcm{2\cdot11}{2\cdot3^{2}}=11\cdot2\cdot9\\
 & =198
\end{align*}
Ora possiamo calcolare $\lambda\left(\lambda\left(n\right)\right)$:
\begin{align*}
\lambda\left(198\right) & =\lambda\left(2\cdot3^{2}\cdot11\right)=\mcm{\varphi\left(2\right)}{\varphi\left(9\right),\,\varphi\left(11\right)}\\
 & =\mcm 1{2\cdot3,\,2\cdot5}=2\cdot3\cdot5=30
\end{align*}
Concludiamo che il periodo $\tau$ sarà uno tra i possibili divisori
di 30, a seconda dal $x_{0}$ selezionato: $\tau\in\left\{ 1,\,2,\,3,\,5,\,6,\,10,\,15,\,30\right\} $;
presi $p=23,\,q=19$ il periodo è un divisore di 30; con $x_{0}=7$
si ha esattamente $\pi=10$.\demo

\subsection{Massimizzare il periodo}

Per avere un periodo lungo di una sequenza BBS, è necessario scegliere
un $x_{0}$ tale che $\pi=\lambda\left(\lambda\left(n\right)\right)\gg1$;
perché ciò si verifichi, scegliamo $p$ e $q$ nel modo seguente:
\begin{itemize}
\item prendiamo un primo $p_{2}$, tale che anche un $p_{1}=2p_{2}+1$ sia
primo; scegliamo il primo $p=2\cdot p_{1}+1$
\item prendiamo un primo $q_{2}$, tale che anche un $q_{1}=2q_{2}+1$ sia
primo; scegliamo il primo $q=2\cdot q_{1}+1$
\item deve valere $p\neq q$, e $p,\,q\gg1$
\end{itemize}
Scegliendo i due primi col criterio appena mostrato, si otterrà in
periodo più lungo possibile.

\section{Successioni LFSR\label{sec:Successioni-LFSR}}

Si tratta di successioni lineari di bit, con aritmetica modulo 2;
definiamo una sequenza PRBS con la seguente costruzione:
\[
\cgm{x_{n+5}}{x_{n}+x_{n+2}}2
\]
Una notazione equivalente per la precedente congruenza è:
\begin{equation}
\cgm{x_{n}}{x_{n-5}+x_{n-3}}2\label{eq:successione-LFSR-5}
\end{equation}
Chiamiamo successione LFSR con memoria 5 la congruenza (\ref{eq:successione-LFSR-5}).

In generale, data una memoria di $M$ bit (la quale genera una ricorrenza
di ordine $M$), possiamo definire una successione LFSR come:
\[
\cgm{x_{n+M}}{c_{M}\cdot x_{n}+c_{M-1}\cdot x_{n+1}+\ldots+c_{1}\cdot x_{n+M-1}}2
\]
Come prima, una costruzione alternativa (vedremo che essa semplificherà
la sintesi di un circuito sequenziale) per la precedente è:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Successione LFSR}{\footnotesize{}\index{Successione LFSR@{\footnotesize{}Successione LFSR}}}}[0.2cm]
\begin{equation}
\cgm{x_{n}}{c_{M}\cdot x_{n-M}+c_{M-1}\cdot x_{n-M+1}+\ldots+c_{1}\cdot x_{n-1}}2\label{eq:successione-LFSR-M}
\end{equation}
Possiamo descrivere la ricorrenza $M$ relativa alla successione (\ref{eq:successione-LFSR-M})
tramite il seguente polinomio, che ha per coefficienti i $c_{i}$
della ricorrenza:
\begin{equation}
P\left(Y\right)=c_{M}Y^{M}+c_{M-1}Y^{M-1}+\ldots+c_{1}Y+c_{0}\label{eq:polinomio-LFSR-M}
\end{equation}
Il polinomio è nella variabile $Y$ per distinguere chiaramente la
sua variabile da quella della successione (\ref{eq:successione-LFSR-M});
usiamo un polinomio per descrivere la ricorrenza, per lavorare con
i campi di Galois.

Il polinomio (\ref{eq:polinomio-LFSR-M}) ha grado $M$ e descrive
una successione con periodo al più $2^{M}-1$; i polinomi di grado
esattamente $M$ sono in numero $2^{M}-1$: infatti possiamo affermare
che $c_{0}=1$ (riferito all'elemento presente) e $c_{M}=1$ (altrimenti
il polinomio non arriverebbe al grado $M$), sottraendo due gradi
di libertà dal numero totale di polinomi di grado $M$.

Per avere una ricorrenza di periodo massimo, dovremo scegliere un
polinomio \emph{irriducibile}, da cercare tra i $2^{M}-1$ disponibili.

Questa ricorrenza può essere implementata via hardware, tramite dei
registri a scorrimento; per esempio per avere una ricorrenza con periodo
di un milione serviranno almeno 20 celle di memoria ($2^{20}-1\simeq10^{6}$).
La sequenza $\left\{ x_{M}\right\} $ generata in questo modo potrà
essere usata come sequenza pseudo-casuale $r$, nel sistema di cifratura
introdotto all'inizio de \secref{Sequenze-binarie-pseudo-casuali}.
In tal caso la chiave sarà costituita da:
\begin{itemize}
\item i coefficienti del polinomio (\ref{eq:polinomio-LFSR-M}), tranne
il primo e l'ultimo \textemdash~sappiamo che essi valgono sempre
1 \textemdash~ovvero $M-1$ bit in totale, a rappresentare i rimanenti
coefficienti (che essendo residui modulo 2 valgono 0 o 1);
\item i valori degli $x$ con i quali inizializzare il polinomio, ovvero
$M$ bit.
\end{itemize}
Questo metodo è vulnerabile all'attacco del testo in chiaro, ed è
usato quando la velocità di cifratura va privilegiata rispetto alla
sicurezza.

\begin{minipage}[c]{0.5\textwidth}%
\begin{example}
\emph{Consideriamo la successione LFSR definita con la congruenza
seguente:}
\[
\cgm{x_{n}}{x_{n-2}+x_{n-3}}2
\]
\emph{Implementare la ricorrenza in esame con un circuito sequenziale.}
\end{example}
$\checked$Possiamo rappresentare la successione col seguente polinomio:
\[
P\left(Y\right)=Y^{3}+Y^{2}+1
\]

Infatti l'ordine della ricorrenza è 3 (ottenuto osservando gli indici
delle $x$), sappiamo che $c_{3}=c_{0}=1$ e infine i termini $x_{n-2}$
e $x_{n-3}$ rappresentano $Y^{2}$ e $Y^{3}$ rispettivamente; il
periodo massimo della sequenza vale $2^{3}-1=7$ (sarebbe sicuramente
massimo se $P\left(Y\right)$ fosse irriducibile).

Implementiamo la successione LFSR col circuito ne \figref{registro-scorrimento-3}.\demo%
\end{minipage}%
\begin{minipage}[c]{0.5\textwidth}%
\begin{center}
\includegraphics{\string"Illustrazioni/5_2-1 Successione LFSR v1\string".pdf}
\par\end{center}
\captionof{figure}{Registro a scorrimento con 3 celle di memoria}\label{fig:registro-scorrimento-3}%
\end{minipage}
\begin{rem}
Abbiamo già concluso che il periodo di una successione LFSR definita
dal polinomio (\ref{eq:successione-LFSR-M}) \emph{irriducibile},
sarà al massimo $2^{M}-1$, oppure un suo sottomultiplo (può essere
un numero diverso se $P\left(Y\right)$ non è irriducibile); tuttavia,
se $2^{M}-1$ è \emph{primo}, il suo unico sottomultiplo è lui stesso
(si ottiene il periodo massimo possibile). In breve vale la seguente
condizione:
\[
P\left(Y\right)\text{ irriducibile}\land2^{M}-1\text{ primo}\implies\left\{ x_{M}\right\} \text{ periodo massimo }\left(2^{M}-1\right)
\]
\end{rem}

\section{Stato della successione}

Supponiamo di prendere il polinomio $P\left(Y\right)$ irriducibile
(\ref{eq:polinomio-LFSR-M}), allora possiamo definire il campo di
Galois con questo polinomio:
\[
\mathcal{GF}\left(2^{M}\right)=\mod{\mathbb{Z}_{2}\left[Y\right]}{P\left(Y\right)}
\]
I polinomi appartenenti a questo campo, che chiamiamo $s_{j}\left(Y\right)$,
avranno al massimo grado $M-1$ e gli $M$ coefficienti di ciascun
polinomio rappresentano lo stato al passo $j$-esimo di un circuito
sequenziale che genera una successione LFSR, che chiameremo \emph{scrambler}.

Possiamo anche considerare $s_{j}\left(Y\right)\in\mathcal{GF}\left(2^{M}\right)$
come un vettore a $M$ dimensioni, dove le coordinate valgono in modulo
2 (0 o 1).

Se moltiplichiamo per $Y$ un polinomio $s_{j}\left(Y\right)$ \textemdash~il
quale rappresenta lo stato delle $M$ celle di memoria \textemdash~otteniamo
lo shift in avanti di un passo del circuito combinatorio:
\[
Y\cdot s_{j}\left(Y\right)=s_{j+1}\left(Y\right)
\]
A questo punto, possiamo scrivere lo stato al passo $j$-esimo come
un residuo in modulo $P\left(Y\right)$, rispetto allo stato iniziale:
\[
\cgm{s_{j}\left(Y\right)}{s_{0}\left(Y\right)\cdot Y^{j}}{P\left(Y\right)}
\]
Chiediamoci dunque sotto quali condizioni $s_{j}\left(Y\right)=s_{0}\left(Y\right)$,
o in altre parole quanto vale il passo al quale inizia il secondo
periodo; questo si verifica quando $\cgm{Y^{j}}1{P\left(Y\right)}$.
Ci interessa il $j$ per cui questa congruenza è vera, quindi ci interessa
l'intero minimo per cui $Y$ (elemento del campo) elevato a quell'intero
dia 1 come residuo: in pratica cerchiamo l'ordine dell'elemento $Y$:
\[
s_{j}\left(Y\right)=s_{0}\left(Y\right)\implies j=\ord Y,\,Y\in\mathcal{GF}\left(2^{M}\right)
\]

\begin{prop}
\label{prop:Ordine-massimo-da-elemento-GF}L'ordine di un elemento
del campo sarà del tipo $\left(2^{M}-1\right)/d$, con $d$ un qualche
intero; si verifica $d=1$ (ordine massimo, pari a $2^{M}-1$) quando
$Y$ è un elemento generatore del campo:
\[
\ord Y=2^{M}-1\implies Y\text{ elemento generatore}
\]
\end{prop}
%
\begin{prop}
\label{prop:Condizione-tutti-elementi-GF-generatori}Condizione sufficiente
perché il periodo della ricorrenza sia $2^{M}-1$ è che il numero
$2^{M}-1$ sia primo; in tal caso tutti gli elementi del campo $\mathcal{GF}\left(2^{M}\right)$
saranno generatori.
\end{prop}

\section{Scrambler}

Consideriamo un apparato di telecomunicazioni: esso avrà un canale
che trasporta una sequenza di bit; in generale le proprietà statistiche
della sequenza di bit, emessi dalla sorgente, non saranno uniformi.
È possibile che una sorgente trasmetta sequenze lunghe di 0 o 1 (sia
per volontà degli utenti, che per segnalare una condizione o un evento,
o uno stato dell'infrastruttura).

Il modo più banale per codificare bit su un canale di comunicazione,
per esempio sulla fibra ottica, è quello di emettere potenza (luce)
quando si vuole inviare un 1, e non emettere nulla quando si vuole
inviare uno 0. In ricezione, si pone il problema di capire se sia
arrivato un 1 o uno 0: si misura la potenza ricevuta, a intervalli
di tempo regolari $T$ (periodo di cifra), e si determina dell'intensità
del segnale in arrivo è maggiore di una certa soglia e può essere
considerata la codifica di un 1 piuttosto che di uno 0.

Tuttavia i componenti che costituiscono i circuiti del trasmettitore
e del ricevitore, a causa della propria tolleranza di fabbricazione,
non possono essere allineati in partenza sulla frequenza di trasmissione
(sarà sempre presente uno sfasamento del segnale ricevuto, chiamato
\emph{jitter}, o rumore di fase). Si usa quindi un circuito chiamato
\emph{clock recovery}, che estrae il sincronismo dal segnale ricevuto;
questo è usato come base per generare un segnale di clock che pilota
un campionatore, facendolo agire esattamente a metà del periodo di
cifra ($T/2$); per estrarre il clock si utilizzano i fronti di salita
e discesa del segnale in ricezione.

Il\marginpar{Un test a livello fisico che si effettua sul ricevitore è chiamato
CID (consecutive identical digits, ovvero cifre identiche consecutive)} problema del clock recovery è l'incapacità dei estrarre il sincronismo
da una sequenza di cifre uguali (tutti 1 o 0). VI sono due strade
per ovviare al problema:
\begin{enumerate}
\item usare una modulazione differente per codificare il segnale nel canale
(per esempio HDB3 trasmette transizioni di potenza a prescindere dalla
cifra codificata);
\item su fibra, dove si trasmette con la modulazione on/off, si usa uno
\emph{scrambler}.
\end{enumerate}
La seconda strada prevede l'impiego dello scrambler, che genera una
sequenza pseudo-casuale (non ci saranno più sequenze lunghe di cifre
ripetute); esso dovrà avere le seguenti proprietà:
\begin{itemize}
\item equalizza la statistica del primo ordine (la \emph{media} degli 1
e 0 trasmessi sia \emph{uguale});
\item equalizza la statistica del secondo ordine (l'autocorrelazione degli
1 e degli 0 deve essere uguale, ovvero la sequenza deve avere \emph{assenza
di memoria} \textemdash~essere non periodica).
\end{itemize}
Per realizzare uno scrambler si usa una successione LFSR (si veda
\secref{Successioni-LFSR}); possiamo realizzare gli scrambler in
due modi.

\subsection{Scrambler auto-sincronizzante}

Si prenda la sequenza $\left\{ I_{k}\right\} $ dei dati da confondere,
la si somma in modulo 2 al contenuto di una serie di celle di memoria,
collegando in retroazione solo quelle identificate dal polinomio caratteristico
che descrive la successione LFSR usata. Si ottiene la sequenza $\left\{ U_{k}\right\} $
dei dati confusi.\bigskip{}

\begin{minipage}[c]{0.7\textwidth}%
\begin{example}
\emph{Consideriamo la successione LFSR definita dal polinomio:}
\[
P\left(Y\right)=Y^{3}+X+1
\]
\emph{Implementare uno scrambler descritto da $P\left(Y\right)$.}
\end{example}
$\checked$Possiamo rappresentare il polinomio con la congruenza:
\[
\cgm{x_{n}}{x_{n-1}+x_{n-3}}2
\]

Infatti l'ordine della ricorrenza è 3 (ottenuto osservando il grado
di $P\left(Y\right)$), sappiamo che $c_{3}=c_{0}=1$ e infine i termini
$Y$ e $Y^{3}$ rappresentano rispettivamente $x_{n-1}$ e $x_{n-3}$;
il periodo massimo della sequenza vale $2^{3}-1=7$ (sarebbe sicuramente
massimo se $P\left(Y\right)$ fosse irriducibile).

Lo scrambler è implementato dal circuito ne \figref{scrambler-auto-sincronizzante-3}.\demo%
\end{minipage}%
\begin{minipage}[c]{0.4\textwidth}%
\begin{center}
\includegraphics[scale=0.65]{\string"Illustrazioni/5_5-1 Scrambler auto-sincronizzante ord 3\string".pdf}
\par\end{center}
\captionof{figure}{Scrambler auto-sincronizzante di ordine 3}\label{fig:scrambler-auto-sincronizzante-3}%
\end{minipage}

Uno scrambler come quello realizzato nell'esempio, avrà periodo massimo
7, nel caso in cui l'ingresso sia costituito da una sequenza si cifre
uguali.

Per effettuare l'operazione inversa dello scrambling, basta invertire
il senso delle frecce che escono da $\left\{ I_{k}\right\} $ e entrano
in $\left\{ U_{k}\right\} $ (grazie alle somme modulo 2, bisogna
solamente invertire la direzione di ingresso e uscita); inoltre non
è necessario conoscere il contenuto di $M_{1}$, $M_{2}$ e $M_{3}$,
tuttavia saranno necessari 3 passi iniziali per inizializzare lo stato
dello scrambler. In pratica sarà necessario conoscere unicamente il
polinomio $P\left(Y\right)$.

\subsection{Scrambler additivo}

~

\begin{minipage}[c]{0.5\textwidth}%
Il funzionamento di questo scrambler è simile al precedente, con la
differenza che l'ingresso viene spento (sostituito da zeri), e il
circuito LFSR genera una sequenza casuale $\left\{ R_{k}\right\} $
(come un generatore PRBS), che viene infine sommata all'ingresso per
generare l'uscita. In questo caso è necessario conoscere anche l'inizializzazione
delle celle $M_{i}$, oltre al polinomio $P\left(Y\right)$.

Lo scrambler additivo sopperisce a un difetto di quello auto-sincronizzante:
quest'ultimo infatti propaga gli errori; un bit sbagliato ricevuto
da uno scrambler auto-sincronizzante interrompe la sequenza, e sono
necessari $M$ passi per inizializzare nuovamente il registro a scorrimento.%
\end{minipage}%
\begin{minipage}[c]{0.6\textwidth}%
\begin{center}
\includegraphics[scale=0.7]{\string"Illustrazioni/5_5-2 Scrambler additivo ord M\string".pdf}
\par\end{center}
\captionof{figure}{Scrambler additivo di ordine $M$}\label{fig:registro-scorrimento-3-1-1}%
\end{minipage}

Per effettuare il \emph{descrambling} (operazione inversa dello scrambling),
si effettua di nuovo l'inversione delle frecce collegate all'ingresso
e all'uscita.\pagebreak{}
\begin{fact}
Tutti i dati trasmessi da un utente, prima di essere mappati nel canale
trasmissivo tramite un protocollo di livello 2 o 1, passano attraverso
un scrambler auto-sincronizzante con polinomio $P\left(Y\right)=Y^{43}+1$;
questa configurazione comporta una propagazione di eventuali errori,
tuttavia garantisce maggiore sicurezza, impedendo che un attaccante
manipoli l'uscita $\left\{ U_{k}\right\} $ dello scrambler (sarebbe
necessario conoscere lo stato del registro a scorrimento, è possibile
ottenerlo tramite $2^{43}$ tentativi \textemdash~circa $10^{12}$).\marginpar{In tutti i sistemi di comunicazione si disaccoppiano i dati trasmessi
dall'utente da quelli che circolano sul mezzo trasmissivo}[-2.5cm]
\end{fact}

\chapter{RSA}

\section{Introduzione}

Trattiamo l'algoritmo di cifratura a chiave pubblica Rivest-Shamir-Adleman
(RSA). La peculiarità degli algoritmi a chiave pubblica è la condivisione
di una chiave pubblica con chiunque voglia cifrare un messaggio, il
quale potrà essere decifrato solo dalla chiave privata, custodita
dal destinatario. La generazione della coppia di chiavi pubblica e
privata è realizzata mediante una funzione unidirezionale (si veda
\subsecref{Funzioni-di-hash}); in questo modo, si ricava la chiave
pubblica da quella privata. In questo modo chi entrerà in possesso
della chiave pubblica non sarà in grado di ricavarne la chiave privata.

Nel caso dell'RSA, la funzione unidirezionale è la seguente. Prendiamo
una coppia di primi $p$ e $q$ molto grandi, e scelti secondo un
criterio (mostrato più avanti); calcoliamo $n=p\cdot q$, e a questo
punto avremo un intero composto computazionalmente impossibile da
fattorizzare. Il prodotto dei due primi costituisce una funzione invertibile,
e se essi sono scelti correttamente è anche unidirezionale; il composto
$n$ sarà pubblico, e i primi $p,\,q$ saranno mantenuti segreti.

\section{Algoritmo}

Prendiamo un composto $n=p\cdot q$, costituito da due primi $p$
e $q$ scelti adeguatamente; prendiamo un intero $e$, che chiamiamo
esponente di cifratura, tale che $e\perp\varphi\left(n\right)$. Dato
che $n$ è costituito da due primi, vale $\varphi\left(n\right)=\left(p-1\right)\left(q-1\right)$.

Il messaggio in chiaro $m$ e quello cifrato $c$ sono entrambi elementi
di $\mathbb{Z}_{n}$; le funzioni di cifratura e decifratura sono
definite come:
\begin{equation}
\begin{array}{c}
\cgm c{p^{e}}n\\
\cgm m{c^{d}}n
\end{array}\label{eq:RSA-cifra-decifra}
\end{equation}
L'intero $d$, chiamato esponente di decifratura, è legato a $e$
nel modo seguente:
\[
\cgm{e\cdot d}1{\varphi\left(n\right)}\implies\boxed{\cgm d{e^{-1}}{\varphi\left(n\right)}}
\]
Dalla congruenza con 1 modulo $\varphi\left(n\right)$ e il prodotto
degli esponenti di cifratura, si deduce che:
\[
e\cdot d=1+k\cdot\varphi\left(n\right)
\]
A questo punto dalla funzione di decifratura (\ref{eq:RSA-cifra-decifra})
otteniamo:
\[
c^{d}=m^{e\cdot d}=m^{1+k\cdot\varphi\left(n\right)}\overset{*}{=}\boxed{m}\cdot1^{k}
\]
Nella relazione $*$ abbiamo usato (\ref{eq:Teorema-Eulero}); si
è voluto mostrare che esiste una corrispondenza univoca tra $m$ e
$c$, per l'ipotesi che $e\perp\varphi\left(n\right)$ (esiste un
solo $d$ che sia inverso di $e$ in modulo $\varphi\left(n\right)$,
e vice versa).

La \emph{chiave pubblica} è costituita da $n,\,e$ mentre la \emph{chiave
privata} è $d$, insieme a $p,\,q$ oppure a $\varphi\left(n\right)$.
\begin{example}
\emph{Siano dati due primi $p_{{\scriptscriptstyle \mathbb{S}}}=3,\,q_{{\scriptscriptstyle \mathbb{S}}}=11$
e un intero $e_{{\scriptscriptstyle \mathbb{P}}}=7$, cifrare tramite
RSA il messaggio $m=19$.}
\end{example}
$\checked$Calcoliamo\marginpar{All'interno di questo esempio, abbiamo usato i pedici ${\scriptscriptstyle \mathbb{P}}$
e ${\scriptscriptstyle \mathbb{S}}$ per indicare un elemento della
chiave pubblica o della chiave privata} il composto $n_{{\scriptscriptstyle \mathbb{P}}}=p\cdot q=33$; calcoliamo
inoltre $\varphi\left(n\right)_{{\scriptscriptstyle \mathbb{S}}}=\varphi\left(33\right)=\left(3-1\right)\left(11-1\right)=2\cdot10=20$.
A questo punto possiamo calcolare $d$:
\[
\begin{array}{c}
\cgm d{e^{-1}}{\varphi\left(n\right)}\\
\cgm d{e^{\varphi\left(\varphi\left(n\right)\right)-1}}{\varphi\left(n\right)}\\
\cgm d{7^{7}}{20}\\
\boxed{\cgm{d_{{\scriptscriptstyle \mathbb{S}}}}3{20}}
\end{array}
\]
Nella precedente relazione abbiamo usato (\ref{eq:Inverso-residuo-toziente}),
e abbiamo calcolato $\varphi\left(\varphi\left(n\right)\right)=\left(2^{2}-2\right)\left(5-1\right)=8$.

Cifriamo il messaggio $m=19$ applicando (\ref{eq:RSA-cifra-decifra}):
\[
c=\mod{19^{7}}{33}=13
\]
Si noti che possiamo riottenere $m=\mod{13^{3}}{33}=19$.\demo
\begin{rem}
Per effettuare la decifratura (operazione adibita alla chiave privata)
è necessario l'esponente $d$, il quale a sua volta viene calcolato
tramite $\varphi\left(n\right)$, che a sua volta deriva dai due primi
$p,\,q$. Ebbene, la conoscenza dei primi $p,\,q$ o del toziente
del loro prodotto $\varphi\left(n\right)$, compromette nello stesso
modo la sicurezza dell'algoritmo, e permette di calcolare $d$ (la
chiave privata).
\end{rem}
\begin{example}
Sia dato il composto $n=p\cdot q=11413$, prodotto di due primi, e
il suo toziente sia noto $\varphi\left(n\right)=$$\left(p-1\right)\left(q-1\right)=11200$.
Calcolare i due primi $p$ e $q$.
\end{example}
$\checked$Analizziamo la relazione $n-\varphi\left(n\right)+1$,
con le seguenti riscritture:
\begin{align*}
n-\varphi\left(n\right)+1 & =p\cdot q-\left(p-1\right)\left(q-1\right)+1\\
214 & =p+q
\end{align*}
Con la conoscenza della somma dei primi cercati, possiamo risolvere
la seguente equazione:
\[
\begin{array}{c}
\left(x-p\right)\left(x-q\right)=0\\
x^{2}-\overset{n-\varphi\left(n\right)+1}{\overbrace{\left(p+q\right)}}x+\overset{n}{\overbrace{p\cdot q}}=0\\
x^{2}-214x+11413
\end{array}
\]
Otteniamo le seguenti soluzioni:\marginpar{Nella formula risolutiva deve valere $\Delta>0$, altrimenti $n$
e $\varphi\left(n\right)$ non sarebbero corretti}
\[
x=\frac{214\pm\sqrt{214^{2}-4\cdot11413}}{2}=\left\{ 101,\,113\right\} 
\]
Abbiamo ottenuto $p=101,\,q=113$. Avremmo ottenuto il risultato con
una bassa complessità computazionale (risolvere un'equazione di secondo
grado), anche nel caso di $p$ e $q$ molto grandi.\demo

\section{Sicurezza di RSA}

In teoria, l'RSA correttamente implementato è sicuro, fintanto che
la scomposizione in fattori primi molto grandi rimane un problema
difficile; tuttavia esistono delle insidie che influenzano la corretta
realizzazione, di cui parleremo in questa sezione.
\begin{thm}
Sia\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Debolezza sulle cifre dei primi in RSA}{\footnotesize{}\index{RSA, debolezza sulle cifre dei primi@{\footnotesize{}RSA, debolezza sulle cifre dei primi}}\label{thm:RSA-debolezza-sulle-cifre-primi}}}[-0.3cm] $m$ il numero di cifre di $n=p\cdot q$ ($m=\left\lceil \log_{10}\left(p\cdot q\right)\right\rceil $);
se si conoscono almeno le \uline{prime} o le \uline{ultime}
$m/4$ cifre di uno dei due primi $p$ o $q$, allora è possibile
fattorizzare in modo efficiente $n$.
\end{thm}
\begin{rem}
Se $n$ ha $m$ cifre, e $p$ e $q$ sono confrontabili, allora essi
avranno ciascuno $m/2$ cifre.
\end{rem}
Il Teorema \ref{thm:RSA-debolezza-sulle-cifre-primi} può essere sfruttato
se il metodo che il mittente utilizza per ricavare i primi $p$ e
$q$ è noto e predicibile: provando per tentativi le cifre dei primi
in un intorno di candidati, è possibile trovare le prime o le ultime
$m/4$ cifre di $p$ o $q$.
\begin{cor}
Consideriamo una chiave pubblica RSA costituita da $n,\,e$, sia $m$
il numero di cifre di $n$; se si conoscono almeno le ultime $m/4$
cifre di $d$ (esponente di decifratura, segreto) allora è possibile
fattorizzare in modo efficiente $d$.
\end{cor}
\begin{rem}
Dato che $\cgm d{e^{-1}}{\varphi\left(n\right)}$, esso avrà da 1
a $m$ cifre, per il limite imposto dal modulo di $\varphi\left(n\right)$
(il toziente avrà al più il numero di cifre di $n$).
\end{rem}
Abbiamo enunciato nelle sezioni precedenti che la scelta di $p$ e
$q$ deve essere fatta prendendo due primi grandi (nella pratica si
usano numero di 150 cifra, ottenendo un $n$ di 300 cifre). per la
scelta dell'esponente di cifratura, bisogna evitare invece un $e$
troppo piccolo, il quale favorirebbe va velocità di cifratura ma sicuramente
causerebbe la comparsa di un $d$ molto grande. Nella scelta di $e$
bisogna anche tenere a mente l'ipotesi che esso sia $e\perp\varphi\left(n\right)$.

Un valore per l'esponente di cifratura comunemente usato e comprovato
è il seguente:
\[
e_{{\scriptscriptstyle \text{RSA}}}=2^{16}+10=65537
\]
Esso è un numero primo (è altamente improbabile che abbia fattori
in comune con $p-1$ o $q-1$, possiamo verificarlo con (\ref{eq:Algoritmo-Euclide-esteso}));
inoltre è facile calcolare il suo valore, tramite square\&multiply
(si veda \secref{Square-=000026-multiply}).

Un altro approccio consiste nello scegliere un $d$ sufficientemente
robusto (50 cifre sono sufficienti), e a partire da esso si calcola
$e$ effettuando l'inverso in modulo $\varphi\left(n\right)$.

\section{Test di primalità}

Normalmente testare la primalità di un numero e fattorizzarlo sono
problemi differenti: è molto più semplice determinare che un numero
sia primo o meno. Vi sono per esempio numeri molto grandi di cui si
sa con certezza che sono composti, ma nessuno è stato in grado di
determinare i loro fattori.

\subsection{Test di Fermat}

Richiamiamo\marginpar{Si ricorda che è possibile testare che due interi siano primi relativi
($a\perp b$) tramite Euclide Esteso (\ref{eq:Algoritmo-Euclide-esteso})} il Teorema \ref{thm:Teorema-piccolo-Fermat}: $\cgm{a\perp p\land\,p\text{ primo}\implies a^{p-1}}1p$;
usando questo risultato, ci chiediamo se, preso un $n$ intero da
testare e un $a\perp n$ qualunque, valga
\begin{equation}
\cgm{a^{n-1}}1n\label{eq:Test-prim-Fermat}
\end{equation}
In caso di residuo esattamente 1, possiamo essere abbastanza sicuri
che $n$ sia un primo: lo chiameremo \emph{pseudo-primo di Fermat
rispetto alla base} $a$. Se il residuo della congruenza fosse diverso
da 1, potremo affermare che $n$ sia composto.
\begin{rem}
Gli interi primi diventano rarefatti tanto più si cercano con un valore
grande, quindi per $n\gg1$ la probabilità che uno pseudo-primo di
Fermat sia davvero un primo è elevata.
\end{rem}
\begin{example}
\emph{Applicare il test di Fermat all'intero} $n=341$.
\end{example}
$\checked$Scegliamo una base che sia prima relativa rispetto a $n$;
dato che 341 è dispari, prendiamo $a=2$. Applichiamo (\ref{eq:Test-prim-Fermat}):\marginpar{Gli pseudo-primi di Fermat rispetto alla base 2 sono detti anche \emph{numeri
di Poulet, Sarrus o Fermatians}}
\[
\mod{2^{340}}{341}=1
\]
Possiamo affermare che 341 sia uno pseudo-primo di Fermat rispetto
alla base 2; con un'analisi veloce tuttavia, otteniamo che $11\backslash341$
(infatti $341=11\cdot31$).

Ripetiamo il test per un'altra base, rispettando l'ipotesi che sia
prima relativa rispetto a $n$; scegliamo $a^{\prime}=3$, dal test
si ottiene:
\[
\mod{3^{340}}{341}=56\neq1
\]
Dato che il candidato al test $n$ non passa il test di Fermat per
qualunque base $a$, possiamo affermare che si tratta di un composto.
La condizione appena enunciata è rappresentata da:
\[
\exists a\in\mathbb{Z}\tc\ncgm{a^{n-1}}1n\implies n\text{ composto}
\]
\demo
\begin{example}
\emph{\label{exa:Esempio-pseudo-primo-assoluto}}Applicare il test
di Fermat all'intero $n=561$.

$\checked$Prendiamo la base $a=2$, e applichiamo il test:
\[
\mod{2^{560}}{561}=1
\]
Possiamo quindi affermare che 561 è uno pseudo-primo di Fermat rispetto
alla base 2; proviamo a usare un'altra base $a=3$, in tal caso il
test vale:
\[
\mod{3^{560}}{561}=375
\]
Da quest'ultimo risultato deduciamo che 561 è composto; tuttavia quello
che abbiamo appena effettuato \uline{non} era un test di Fermat!
Infatti 3 è un fattore di 561 ($561=3\cdot11\cdot17$); inoltre l'intero
561 appare pseudo-primo per tutte le basi, ad eccezione dei suoi fattori.\demo
\end{example}
\begin{defn}
\label{def:pseudoprimo-assoluto-Carmichael}Un\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Numeri di Carmichael}{\footnotesize{}\index{Carmichael, numeri di@{\footnotesize{}Carmichael, numeri di}}}}[-0.2cm] intero pseudo-primo di Fermat rispetto ad ogni base, ad
eccezione di quelle che sono i suoi fattori, è chiamato \emph{pseudo-primo
assoluto}, oppure \emph{numero di Carmichael}.
\end{defn}
\begin{rem}
La distribuzione dei primi di Carmichael è estremamente rarefatta:
il promo elemento è proprio 561, il secondo è 41041, ecc$\ldots$
Il numero $\mathcal{C}\left(x\right)$ dei primi di Carmichael da
0 a $x$ è limitato superiormente nel modo seguente:
\begin{equation}
\mathcal{C}\left(x\right)<x\cdot e^{\frac{-k\cdot\ln\left(x\right)\cdot\ln\left(\ln\left(\ln x\right)\right)}{\ln\left(\ln\left(x\right)\right)}}\label{eq:Quantit=0000E0-nuemri-Carmichael}
\end{equation}
\end{rem}
%
\begin{rem}
Non esistono pseudo-primi che siano forti e assoluti; tuttavia, sia
$\mathbb{B}$ un insieme finito di basi, $b$ un suo elemento, e $\#_{\text{F}}\left(b\right)$
il numero di pseudo-primi forti rispetto a una base $b$, allora
\[
\forall b\in\mathbb{B}\tc\#_{\text{F}}\left(b\right)=\infty
\]
\end{rem}

\subsection{Test del principio fondamentale}

Richiamiamo il principio fondamentale (\ref{eq:Principio-fondamentale});
possiamo usare questo risultato per dedurre:
\begin{equation}
\exists a,\,b\in\mathbb{Z}\tc\cgm{a^{2}}{b^{2}}n\land\ncgm a{\pm b}n\implies n\text{ composto}\label{eq:Test-prim-principio-fondamentale}
\end{equation}
Il test (\ref{eq:Test-prim-principio-fondamentale}) ci fornisce anche
la seguente informazione: il massimo comune divisore tra $a-b$ e
$n$ è un fattore non banale di $n$ (diverso da 1 e da $n$), ovvero
vale:
\[
\mcd{a-b}n\neq\left\{ 1,\,\text{n}\right\} 
\]
Tramite la conoscenza di un fattore non banale, si può scomporre $n$
e ridurre il problema alla fattorizzazione di un intero più piccolo.

\subsection{Test di Miller-Rabin\label{subsec:Test-di-Miller-Rabin}}

Dato un candidato $n$ da testare, esso viene prima testato con Fermat
(\ref{eq:Test-prim-Fermat}); se $n$ si rivela uno pseudo-primo di
Fermat, viene sottoposto al test del principio fondamentale (\ref{eq:Test-prim-principio-fondamentale});
gli interi che passano anche il secondo test sono chiamati \emph{pseudo-primi
forti} (non sono sicuramente dei primi, ma lo sono con alta probabilità).
Gli interi che non passano il test di Miller-Rabin sono sicuramente
composti.

Se prendiamo il candidato $n=561$ dell'Esempio \ref{exa:Esempio-pseudo-primo-assoluto},
esso non passa il test di Miller-Rabin, quindi è uno pseudo-primo
assoluto ma non uno pseudo-primo forte.

\subsection{Densità dei primi}

Vogliamo trovare un intero primo che abbia 100 cifre; la densità dei
numeri primi intorno a $10^{100}$ può essere calcolata usando la
quantità di primi dal Teorema \ref{thm:Numeri-primi}:
\[
\frac{\text{\# primi}}{\text{\# interi}}=\frac{\pi\left(10^{100}\right)}{10^{100}}=\frac{1}{\ln\left(10^{100}\right)}=\frac{1}{100\cdot\ln\left(10\right)}\simeq\frac{1}{230}
\]
Possiamo scrivere in generale, chiamando $\delta\left(x\right)$ la
densità di primi intorno a $x$:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Densità di interi primi}{\footnotesize{}\index{Densità di interi primi@{\footnotesize{}Densità di interi primi}}}}[0.4cm]
\begin{equation}
\delta\left(x\right)=\frac{1}{\ln\left(x\right)}\label{eq:Densit=0000E0-interi-primi}
\end{equation}
La densità calcolata attorno a $10^{100}$ si traduce nella seguente
osservazione: prendendo a caso un intero di 10 cifre, la probabilità
che sia primo è circa $1/230$.

\section{Fattorizzazione}

Consideriamo un numero $n$ che sappiamo essere composto (possiamo
prendere un intero che non abbia passato il test di Miller-Rabin §\ref{subsec:Test-di-Miller-Rabin});
possiamo adottare dei metodi algoritmici per trovare i suoi fattori
primi, se $n$ soddisfa certe condizioni, da evitare nella scelta
dei primi per RSA.

\subsection{Metodo di fattorizzazione di Fermat}

Proviamo ad esprimere il numero che sappiamo essere composto, come
differenza di due quadrati; otteniamo:
\[
n=x^{2}-y^{2}=\bigl(\overset{p}{\overbrace{x+y}}\bigr)\bigl(\overset{q}{\overbrace{x-y}}\bigr)
\]
Costruiamo la sequenza $\left\{ x^{2}\right\} $ seguente, e ci fermiamo
quando $n+y^{2}$ è un quadrato perfetto:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Fattorizzazione di Fermat}{\footnotesize{}\index{Fermat, fattorizzazione@{\footnotesize{}Fermat, fattorizzazione}}}}[0.2cm]
\begin{equation}
\left\{ x^{2}\right\} =\left\{ y\in\left[0,\,\infty\right)\tc n+y^{2}=x^{2}\right\} \label{eq:Successione-fattorizzazione-Fermat}
\end{equation}
Una volta trovato un quadrato perfetto, siamo anche a conoscenza della
$x$ e della $y$, con le quali possiamo calcolare i fattori di $n$:
$p=\left(x+y\right)$ e $q=\left(x-y\right)$.

L'efficienza computazionale di questo metodo dipende da quanto siano
vicini i fattori di $n$; infatti se $n=p\cdot q$ e $p\sim q$, allora
avremo un $y$ piccolo che permetterà di arrivare velocemente alla
soluzione.
\begin{example}
\emph{Fattorizzare l'intero $n=295927$ col metodo di Fermat.}
\end{example}
$\checked$Costruiamo la successione (\ref{eq:Successione-fattorizzazione-Fermat}):
\begin{align*}
295927+1 & \neq x^{2}\\
295927+4 & \neq x^{2}\\
295927+9 & =544^{2}
\end{align*}
Possiamo affermare che $x=544$, $y=3$ e vale $n=\left(544+3\right)\left(544-3\right)$.
Si noti che i fattori ottenuti \uline{non} sono necessariamente
primi.\demo

\subsection{Algoritmo di Pollard $\boldsymbol{\left(p-1\right)}$}

Consideriamo un primo $p$, in tal caso $p-1$ sarà pari, quindi composto:
\[
p-1=2\cdot\prod_{i=1}^{i=\ldots}q_{i}
\]
Possiamo sfruttare questa osservazione solo quando i fattori $q_{i}$
sono piccoli: se abbiamo almeno un fattore $q_{i}$ grande, l'algoritmo
di Pollard non semplifica il problema della fattorizzazione.

Dato un intero $n$ da fattorizzare, si scelga una base $a>1$, poi
si sviluppi la successione $\left\{ b_{j}\right\} $ come:
\[
\begin{array}{c}
\cgm{b_{1}}an\\
\cgm{b_{2}}{b_{1}^{2}}n\\
\cgm{b_{3}}{b_{2}^{3}}n\\
\vdots
\end{array}
\]
Formalizziamo la successione con le seguenti scritture:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Algoritmo di Pollard}{\footnotesize{}\index{Pollard, algoritmo di@{\footnotesize{}Pollard, algoritmo di}}}}[0.2cm]
\begin{equation}
\cgm{b_{j}}{b_{j-1}^{j}}n,\quad d_{j}=\mcd{b_{j}-1}n\label{eq:Successione-fattorizzazione-Pollard}
\end{equation}
Continuiamo per ogni $j$ fino a che $d_{j}\neq1$; in tal caso $d_{j}$
è un fattore non banale di $n$, e l'algoritmo termina.
\begin{example}
\emph{Fattorizzare l'intero $n=11413$ con l'algoritmo di Pollard.}
\end{example}
$\checked$Scegliamo la base $a=2$, e costruiamo la successione (\ref{eq:Successione-fattorizzazione-Pollard}):
\[
\begin{array}{ll}
\cgm{b_{1}}2{11413}, & d_{1}=\mcd 1{11413}=1\\
\cgm{b_{2}}{2^{2}}{11413}, & d_{2}=\mcd 3{11413}=1\\
\cgm{b_{3}}{4^{3}}{11413}, & d_{3}=\mcd{63}{11413}=1\\
\cgm{b_{4}}{64^{4}}{11413}, & d_{4}=\mcd{105}{11413}=1\\
\cgm{b_{5}}{106^{5}}{11413}, & d_{5}=\mcd{-309}{11413}=1\\
\cgm{b_{6}}{-309^{6}}{11413}, & d_{6}=\mcd{9992}{11413}=1\\
\cgm{b_{7}}{9993^{7}}{11413}, & d_{7}=\mcd{5085}{11413}=1\\
\cgm{b_{8}}{5086^{8}}{11413}, & d_{8}=\mcd{-1017}{11413}=1\\
\cgm{b_{9}}{-1016^{9}}{11413}, & d_{9}=\mcd{5537}{11413}=\boxed{113}
\end{array}
\]
Otteniamo che un fattore non banale di $n$ è proprio $p=d_{9}=113$,
mentre il secondo fattore di $q=n/p=101$.\demo

\chapter{Firma digitale}

\section{Logaritmo discreto}

\subsection{Definizione}

Consideriamo la congruenza seguente:
\begin{equation}
\cgm{\beta}{\alpha^{x}}p\label{eq:Equazione-congruenziale-log-discreto}
\end{equation}
dove $p$ è un primo e $\alpha,\,\beta\in\mathbb{Z}_{p}^{*}$; essa
è una equazione congruenziale nell'incognita $x$, a cui dovremo assegnare
il valore a cui elevare $\alpha$ per ottenere $\beta$.

Dunque, abbiamo un problema analogo a quello del logaritmo; osserviamo
inoltre che l'equazione (\ref{eq:Equazione-congruenziale-log-discreto})
ha sempre soluzione se la base $\alpha$ è radice primitiva di $\mathbb{Z}_{p}^{*}$,
infatti in tal caso si ha $\ord{\alpha}=p-1$, quindi elevando $\alpha$
a tutti gli interi da 1 a $p-1$ si ottengono tutti gli elementi di
$\mathbb{Z}_{p}^{*}$; dal momento che anche $\beta$ è contenuto
in $\mathbb{Z}_{p}^{*}$, sarà certo produrre $\beta$ da una alle
potenze di $\alpha$.

Chiamiamo \emph{logaritmo discreto} questo problema, e lo indichiamo
come:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Logaritmo discreto}{\footnotesize{}\index{Logaritmo discreto@{\footnotesize{}Logaritmo discreto}}}}[0cm]
\begin{equation}
x=\logd{\alpha}{\beta}\label{eq:Logaritmo-discreto}
\end{equation}
Risolvendo un logaritmo discreto, si ottengono infinite soluzioni
\textemdash~una classe di congruenze del tipo $\cgm x{\logd{\alpha}{\beta}}{\ord{\alpha}}$;
il logaritmo discreto gode delle stesse proprietà dei logaritmi.
\begin{example}
\emph{Calcolare la soluzione del logaritmo discreto in base $\alpha=2$
di $\beta=9$, nell'insieme dei residui modulo $p=11$.}
\end{example}
$\checked$Le soluzioni apparterranno alla classe di congruenze:
\[
\cgm x{\logd 29}{11}
\]
In questo caso, essendo 10 le possibili soluzioni, possiamo effettuare
una esplorazione esaustiva dello spazio delle radici; provando ad
elevare 2 a tutti gli interi da 1 a 10 si ottiene:
\[
\cgm x6{11}
\]

Possiamo porci nello stesso caso, considerando $\alpha=3$; il problema
sarà allora:
\[
\cgm{3^{x}}9{11}\implies\cgm x{\logd 39}{11}
\]
Effettuando di nuovo un'analisi esaustiva dello spazio delle radici
otteniamo che:
\[
\cgm x25
\]
Notiamo che la classe di residui non è in modulo 11 questa volta,
poiché 3 non è una radice primitiva in $\mathbb{Z}_{11}^{*}$.\demo
\begin{rem}
In generale non abbiamo un algoritmo efficiente che risolva il logaritmo
discreto per un primo $p$ arbitrario. Quindi la funzione logaritmo
discreto non è unidirezionale; infatti, dato $\beta$, non si riesce
a calcolare $x$ in modo semplice. Questo rende il logaritmo discreto
una funzione adatta a essere usata in un cifrario a chiave pubblica.
\end{rem}

\subsection{Parità del logaritmo discreto}

Possiamo ottenere se la soluzione di un logaritmo discreto sia pari
o meno: consideriamo il primo $p$, gli interi $\alpha,\,\beta\in\mathbb{Z}_{p}^{*}$
e l'intero $x\in\left[0,\,p-1\right]$, tali che:
\[
\cgm{\beta}{\alpha^{x}}p
\]
Vogliamo trovare il valore di $x$.

Notiamo che, con la seguente riscrittura, se $\alpha$ è radice primitiva
in $\mathbb{Z}_{p}^{*}$ (implicazione $\star$), otteniamo una congruenza
a 1:
\[
\cgm{\left(\alpha^{\frac{p-1}{2}}\right)^{2}\equiv\alpha^{p-1}}1p\overset{\star}{\implies}\cgm{\alpha^{\frac{p-1}{2}}}{\pm1}p
\]
Dato che $p-1$ è l'esponente minore che verifica la congruenza a
$+1$, consideriamo nella precedente solo ``$\cgm{}{-1}p$''.

Elevando entrambi i membri della prima congruenza a $\left(p-1\right)/2$
si ottiene:
\[
\cgm{\beta^{\frac{p-1}{2}}\equiv\alpha^{\frac{p-1}{2}\cdot x}}{\left(-1\right)^{x}}p
\]
Nella precedente, se abbiamo $\cgm{\beta^{\left(p-1\right)/2}}{+1}p$
allora $x$ è pari, altrimenti sarà dispari.

\subsection{Algoritmo di Pohlig-Hellman}

Osserviamo che $p-1$ sarà pari, dato un primo $p$: allora $p-1$
dovrà essere un composto. Scriviamolo come:
\[
p-1=2\cdot\prod_{i=1}^{h}p_{i}^{r_{i}}
\]
Dato che la soluzione del logaritmo discreto è della forma $\cgm x{\logd{\alpha}{\beta}}{\left(p-1\right)}$,
possiamo scomporre il problema col Teorema \ref{thm:Teorema-cinese-del-resto}
in $h$ pezzi diversi, ognuno in modulo $p_{i}^{r_{i}}$.

Questi problemi sono più facili da risolvere perché più piccoli; se
tuttavia è presente un fattore $p_{i}^{r_{i}}$ molto grande, allora
non vi è riduzione della complessità; concludiamo che la difficoltà
del problema del logaritmo discreto modulo $p-1$ dipende strettamente
dalla grandezza del fattore più grande di $p-1$.

\subsection{Algoritmo baby step, giant step\label{subsec:Baby-step-giant-step}}

Consideriamo le ipotesi per il problema descritto dall'equazione (\ref{eq:Equazione-congruenziale-log-discreto}),
e scegliamo un intero $N\tc N^{2}\geq p-1$; segue che:
\[
N=\left\lfloor \sqrt{p-1}\right\rfloor +1
\]
Costruiamo ora due successioni $\left\{ \alpha^{j}\right\} $ e $\left\{ \beta\cdot\alpha^{-N\cdot k}\right\} $
tali che $0\leq j<N$ e $0\leq k<N$>; le successioni così fatte saranno
sviluppate come:
\[
\begin{array}{ccccc}
\boldsymbol{j} & \boldsymbol{\alpha^{i}} & \boldsymbol{} & \boldsymbol{k} & \boldsymbol{\beta\cdot\alpha^{-N\cdot k}}\\
0 & 1 &  & 0 & \beta\\
1 & \alpha &  & 1 & \beta\cdot a^{-N}\\
2 & \alpha^{2} &  & 2 & \beta\cdot a^{-2N}\\
\vdots & \vdots &  & \vdots & \vdots
\end{array}
\]
Tutti i termini delle successioni $\alpha$ e $\beta$ sono in modulo
$p$; inoltre, una volta sviluppata la successione $\alpha$, cerchiamo
la prima corrispondenza con uno dei termini della successione $\beta$.
Una corrispondenza tra le due successioni vuol dire aver trovato dei
valori per $j$ e $k$ che verificano:
\[
\cgm{\alpha^{j}}{\beta\cdot\alpha^{-N\cdot k}}p\implies\cgm{\alpha^{j+N\cdot k}}{\beta}p
\]
Per il principio fondamentale, dalla precedente possiamo scrivere
la congruenza degli esponenti modulo $p-1$, trovando la risposta
al problema del logaritmo discreto (a quale esponente elevare $\alpha$
per ottenere $\beta$):
\[
\cgm x{j+N\cdot k}{\left(p-1\right)}
\]

\begin{rem}
Con questo algoritmo esprimiamo il valore del logaritmo discreto in
base $N$; la complessità computazionale è proporzionale a $\sqrt{p}$,
rispetto all'analisi esaustiva delle soluzioni del logaritmo discreto,
che può essere condotta con $p-1$ elevamenti a potenza. Infatti dovremo
certamente sviluppare la successione di $\alpha$ fino a $j=N-1$,
e nel peggiore dei casi anche la successione di $\beta$ fino a $k=N-1$.
\end{rem}

\section{Pattuizione della chiave Diffie-Hellman}

Il metodo Diffie-Hellman permette di scambiare una chiave simmetrica
attraverso un canale non sicuro, sfruttando la complessità del problema
del logaritmo discreto. Consideriamo un mittente $\mathbf{A}$ e un
destinatario $\mathbf{B}$; ipotizziamo che un attaccante $\mathbf{O}$
possa osservare tutto il traffico che transita sul canale tra $\mathbf{A}$
e $\mathbf{B}$; nel seguente elenco sono indicati i messaggi scambiati
tra $\mathbf{A}$ e $\mathbf{B}$:
\begin{enumerate}
\item $\mathbf{A}\leftrightarrows\mathbf{B}$: mittente e destinatario concordano
un primo $p$ e una radice primitiva $\alpha\in\mathbb{Z}_{p}^{*}$
(sia $\alpha$ che $p$ sono pubblici);
\item $\mathbf{A}\rightarrow\mathbf{B}$: $\mathbf{A}$ sceglie a caso un
intero $x\in\left[1,\,p-2\right]$, e invia a $\mathbf{B}$ $\mod{\alpha^{x}}p$;
\item $\mathbf{A}\leftarrow\mathbf{B}$: $\mathbf{B}$ sceglie a caso un
intero $y\in\left[1,\,p-2\right]$, e invia ad $\mathbf{A}$ $\mod{\alpha^{y}}p$;
\item $K_{\mathbf{A}\rightarrow\mathbf{B}}$: la chiave che $\mathbf{A}$
usa per scrivere a $\mathbf{B}$ è costruita come $\mod{\left(\alpha^{x}\right)^{y}}p$;
\item $K_{\mathbf{A}\leftarrow\mathbf{B}}$: la chiave che $\mathbf{B}$
usa per rispondere ad $\mathbf{A}$ è costruita come $\mod{\left(\alpha^{y}\right)^{x}}p$.
\end{enumerate}
Si verifica facilmente che le chiavi generate con questo algoritmo
sono uguali:
\[
\cgm{K_{\mathbf{A}\rightarrow\mathbf{B}}\equiv K_{\mathbf{A}\leftarrow\mathbf{B}}}{\alpha^{x\cdot y}}p
\]
Consideriamo il punto di vista di un attaccante $\mathbf{O}$ che
osserva il traffico sul canale: egli non potrà ricavare $x$ e $y$
a meno che non risolva il problema del logaritmo discreto; è quindi
necessario concordare un primo $p$ che renda intrattabile il problema
del logaritmo discreto in $\mathbb{Z}_{p}^{*}$.
\begin{problem}
\noun{\label{prob:Problema-computazionale-Diffie-Hellman}{Problema computazionale di Diffie-Hellman}.}
Dati $\alpha^{x}$ e $\alpha^{y}$, entrambi residui modulo $p$,
calcolare $\mod{\alpha^{x\cdot y}}p$ non è più difficile di calcolare
il logaritmo discreto $\logd{x\cdot y}{\alpha}$. Risolvere il logaritmo
discreto è quindi condizione sufficiente per il problema computazionale
di Diffie-Hellman.
\end{problem}
%
\begin{problem}
\noun{\label{prob:Problema-decisionale-Diffie-Hellman}{Problema decisionale di Diffie-Hellman}.
}Dati $\alpha^{x}$, $\alpha^{y}$ e un intero $c$, tutti residui
modulo $p$, determinare se si verifica $\cgm c{\alpha^{x\cdot y}}p$.
Risolvere il problema computazionale permette di risolvere anche quello
decisionale, tuttavia non è vero il contrario: non sappiamo se risolvere
il problema decisionale possa ridurre a priori la complessità di quello
computazionale.
\end{problem}

\section{Crittosistema a chiave pubblica El Gamal}

Consideriamo un mittente $\mathbf{A}$ e un destinatario $\mathbf{B}$;
ipotizziamo che un attaccante $\mathbf{O}$ possa osservare tutto
il traffico che transita sul canale tra $\mathbf{A}$ e $\mathbf{B}$,
e il messaggio $m$ che $\mathbf{A}$ desidera inviare a $\mathbf{B}$:
\begin{enumerate}
\item $\mathbf{B}$: sceglie un primo $p$ tale che il problema del logaritmo
discreto in $\mathbb{Z}_{p}^{*}$ sia intrattabile e una radice primitiva
$\alpha$ in tale insieme (pubblici); inoltre sceglie un intero $a\in\left[1,\,p-2\right]$
(segreto); infine, egli computa $\cgm{\beta}{\alpha^{a}}p$;
\item $\mathbf{A}\leftarrow\mathbf{B}$: $\mathbf{B}$ invia ad $\mathbf{A}$
la propria chiave pubblica, costituita da $\left(\alpha,\,\beta,\,p\right)$;
\item $\mathbf{A}$: sceglie un intero $k\in\left[1,\,p-2\right]$, e calcola:
\[
\cgm r{\alpha^{k}}p,\quad\cgm t{\beta^{k}\cdot m}p
\]
\item $\mathbf{A}\rightarrow\mathbf{B}$: $\mathbf{A}$ invia il messaggio
cifrato costituito da $\left(r,\,t\right)$ a $\mathbf{B}$;
\item $\mathbf{B}$: decifra il messaggio ricevuto computando $\mod{t\cdot r^{-a}}p$:
\[
\cgm{t\cdot r^{-a}\equiv\left(\beta^{k}\cdot m\right)\left(\alpha^{k}\right)^{-a}\equiv\left(\cancel{\alpha^{a\cdot k}}\cdot m\right)\left(\cancel{\alpha^{a\cdot k}}\right)}{\boxed{m}}p.
\]
\end{enumerate}
\begin{rem}
Mentre $a$ rimane il segreto di $\mathbf{B}$ fin dall'inizio della
comunicazione, il segreto $k$ di $\mathbf{A}$ invece è casuale ed
è bene che sia usato una sola volta; esso è un segreto effimero chiamato
\emph{nonce} (dalla crasi di number e once, un numero da usare una
sola volta).
\end{rem}
%
\begin{rem}
Notiamo che il messaggio in chiaro $m$ appartiene a $\mathbb{Z}_{p}^{*}$,
tuttavia il messaggio cifrato è dato dalla coppia di numeri $\left(r,\,t\right)\in\mathbb{Z}_{p}^{*}\times\mathbb{Z}_{p}^{*}$.
\end{rem}
%
\begin{rem}
Possiamo calcolare $r^{-a}$ sia passando per l'inverso di $r$ elevato
ad $a$, sia considerando che $\cgm{r^{-a}}{r^{p-1-a}}p$, per il
Teorema \ref{thm:Teorema-piccolo-Fermat}.
\end{rem}
Ipotizziamo di utilizzare lo stesso nonce due volte; chiamiamo $m_{i}$
il testo in chiaro, $c_{i}$ il messaggio cifrato, e $m_{1}\neq m_{2}$,
allora dalla cifratura si ottiene:
\[
E\left(m_{1}\right)=c_{1}\left(r,\,t_{1}\right),\quad E\left(m_{2}\right)=c_{2}\left(r,\,t_{2}\right)
\]
I due interi $r$ per i messaggi cifrati coincidono, e questo permette
all'attaccante (se egli possiede anche un testo in chiaro noto, per
esempio $m_{1}$ associato a $c_{1}$) di provare a computare:
\[
\cgm{\frac{t_{1}}{m_{1}}}{\frac{t_{2}}{m_{2}}}p\implies\cgm{m_{2}}{\frac{t_{2}}{t_{1}}\cdot m_{1}}p
\]
Dalla precedente congruenza è possibile ricavare tutti i messaggi
successivi alla ripetizione di un nonce, sfruttando la relazione di
proporzionalità mostrata.
\begin{rem}
Se avessimo un dispositivo che risolve il Problema \ref{prob:Problema-computazionale-Diffie-Hellman},
potremmo usarlo per decifrare i messaggi cifrati tramite il crittosistema
di El Gamal; se avessimo un dispositivo che risolve il Problema \ref{prob:Problema-decisionale-Diffie-Hellman},
potremmo usarlo per decidere se un messaggio cifrato $\left(r,\,t\right)$
sia compatibile con un messaggio in chiaro $m$ (permette di attuare
l'attacco del testo in chiaro noto), non ostante il segreto effimero
$k$. Questa è la differenza con l'RSA nel quale, dato un messaggio
cifrato e uno in chiaro, è possibile verificare direttamente la loro
corrispondenza.
\end{rem}

\section{Funzioni di Hash}

\subsection{Definizione e proprietà}

Una \marginpar{Le funzioni di hash sono state introdotte nella sottosezione §\ref{subsec:Funzioni-di-hash}}[0.5cm]funzione
di hash è una funzione matematica che prende in ingresso un messaggio
di lunghezza arbitraria, e produce una uscita (di solito corta) di
lunghezza prefissata.

La funzione matematica selezionata deve:
\begin{itemize}
\item essere veloce da calcolare;
\item avere uscita pseudo-casuale (deve godere delle proprietà descritte
dalla Proposizione \ref{prop:Propriet=0000E0-fondamentali-cifrari-Shannon});
\item essere non-invertibile (non c'è corrispondenza univoca tra ingresso
e uscita, risulta non-invertibile per definizione);
\item essere\marginpar{La proprietà di unidirezionalità è anche detta \emph{resistenza alla
contro-immagine}} unidirezionale (non deve essere possibile trovare nemmeno una uscita
delle infinite che producono certo ingresso);
\item non esista una coppia di messaggi differenti $m_{1}\neq m_{1}$, tali
che i loro hash siano uguali, ovvero (detta $h\left(m\right)$ la
funzione di hash del messaggio $m$)
\[
\forall\left(m_{1},\,m_{2}\right)\tc m_{1}\neq m_{2}\implies h\left(m_{1}\right)\neq h\left(m_{2}\right)
\]
se questo si verifica, diremo che la funzione $h\left(\right)$ è
\emph{fortemente resistente alle collisioni};
\item dato un messaggio $m$, sia impossibile trovare un messaggio diverso
$m^{\prime}\neq m$ per il quale gli hash dei due messaggi siano uguali,
ovvero
\[
\forall m\,\nexists m^{\prime}\tc m^{\prime}\neq m\implies h\left(m\right)=h\left(m^{\prime}\right)
\]
se questo si verifica, diremo che la funzione $h\left(\right)$ è
\emph{debolmente resistente alle collisioni}.
\end{itemize}
Ottenere la resistenza debole alle collisioni è più difficile: infatti
essa fornisce un grado di libertà in meno rispetto alla resistenza
forte (uno dei due messaggi viene fissato).
\begin{example}
\emph{Determinare se le seguenti funzioni siano invertibili, unidirezionali
e prive di collisioni:}
\end{example}
\begin{enumerate}
\item $h\left(x\right)=\mod xn$ con $n$ intero composto qualunque;
\item $h\left(x\right)=\mod{\alpha^{x}}p$ con $\alpha$ radice primitiva
di $\mathbb{Z}_{p}$;
\item $h\left(x\right)=\mod{x^{2}}n$ con $n=p\cdot q$ prodotto di due
primi;
\item $h\left(x\right)={\scriptstyle \text{DES}}_{x}\left(000\ldots\right)$
con chiave $x\in\left[0,\,2^{56}\right]$.
\end{enumerate}
$\checked$Analizziamo una alla volta le quattro funzioni, nelle sottosezioni
seguenti.

\subsubsection*{Funzione $\left(1\right)$}

Questa funzione non è invertibile, poiché esistono infiniti messaggi
che producono la stessa uscita della funzione ($\forall k\tc h\left(x\right)=\mod{\left(x+k\cdot n\right)}n$);
per quanto appena osservato, tale funzione non è unidirezionale, poiché
è possibile trovare uno qualunque di quegli infiniti messaggi che
producono la stessa uscita (basta provare un $x+k\cdot n$). Per lo
stesso motivo, è possibile trovare una collisione (per esempio $h\left(x\right)=h\left(x+n\right)$).

\subsubsection*{Funzione $\left(2\right)$}

Questa funzione non è invertibile, poiché esistono infiniti numeri
nella classe di congruenza $\cgm k{\overline{x}}{\left(p-1\right)}$
che danno resto $k$; l'inverso di questa funzione ricade nel problema
del logaritmo discreto (\ref{eq:Logaritmo-discreto}): con un $p$
scelto in modo opportuno, la funzione risulta unidirezionale.

Possiamo ottenere una collisione prendendo $x_{1}$ e $x_{2}=x_{1}+k\left(p-1\right)$,
da cui si ottiene la stessa uscita ($h\left(x_{1}\right)=h\left(x_{2}\right)$).

\subsubsection*{Funzione $\left(3\right)$}

Questa funzione non è invertibile, poiché esistono infiniti valori
di $x$ per cui la congruenza in modulo $n$ possa essere soddisfatta;
presi $p$ e $q$ tali da rendere computazionalmente intrattabile
la fattorizzazione di $n$, questa funzione risulta unidirezionale.

Possiamo ottenere una collisione usando il fatto che un quadrato abbia
due radici opposte: $h\left(x\right)=h\left(-x\right)$.

\subsubsection*{Funzione $\left(4\right)$}

Cifriamo un blocco di 64 zeri col DES, usando il messaggio come chiave
di 56bit. Dato che il messaggio usato come chiave è da 56bit, e l'uscita
è un blocco da 64bit, la funzione non è invertibile; grazie alle proprietà
del DES la funzione risulta unidirezionale (non è possibile ottenere
la chiave $x$ che produca un'uscita $h\left(x\right)$ desiderata),
infatti DES resiste all'attacco del testo in chiaro noto.

Per quanto appena affermato, non è possibile trovare collisioni (equivale
a trovare due chiavi che cifrano nello stesso modo lo stesso blocco).

Osserviamo che non possiamo usare questa funzione come una funzione
di hash: infatti essa non rispetta la proprietà sulla lunghezza arbitraria
dell'ingresso, che è limitato a un massimo di 56bit.\demo

\subsection{Algoritmo SHA}

Si tratta di una famiglia di algoritmi classificati, in base alla
lunghezza dell'uscita, la lunghezza dei blocchi e il numero di round,
in SHA-0 (160bit), SHA-1 (160bit), SHA-2 (256bit), SHA-3 (512bit,
standard approvato dal NIST). Il loro funzionamento può essere schematizzato
nel modo seguente; sia dato un messaggio $m$, di cui si vuole calcolare
l'hash:

\textbf{\noun{Inizializzazione}}
\begin{itemize}
\item concatena al messaggio $m$ dei bit di ``padding'', in modo che
la sua lunghezza $\ell$ sia un multiplo di 512;
\item concatena al messaggio $m$ la sua lunghezza $\ell$, sotto forma
di intero senza segno a 64bit (questo pone un limite intrinseco alla
lunghezza dell'ingresso);
\item inizializza 5 registri $H_{0},\,\ldots,\,H_{4}$ con dei valori costanti
(sono parte della specifica dell'algoritmo).
\end{itemize}
\textbf{\noun{Esecuzione}}
\begin{enumerate}
\item dividiamo il messaggio $m$ in blocchi da 512bit chiamati $M_{i}$;
\item dividiamo ciascun blocco $M_{i}$ in 16 blocchi da 32bit, che chiamiamo
$W_{i,j}$;
\item per $j$ da 16 a 79:\marginpar{La funzione $f_{j}\left(\right)$ e il valore $K_{j}$ sono specifici
dell'algoritmo SHA-1; la funzione $B\protect\hookleftarrow r$ fa
scorrere in modo ciclico i bit di $B$ a sinistra di $r$ posizioni}
\begin{enumerate}
\item $W_{i,j}=\left(W_{i,j-3}\oplus W_{i,j-8}\oplus W_{i,j-14}\oplus W_{i,j-16}\right)\hookleftarrow1$;
\end{enumerate}
\item assegniamo $A=H_{0},\,B=H_{1},\,C=H_{2},\,D=H_{3},\,E=H_{4}$;
\item per $j$ da 0 a 79:
\begin{enumerate}
\item $T=\left(A\hookleftarrow5\right)+f_{j}\left(B,\,C,\,D\right)+E+W_{j}+K_{j}$;
\item $E=D$;
\item $D=C$;
\item $C=\left(B\hookleftarrow30\right)$;
\item $B=A$;
\item $A=T$;
\end{enumerate}
\item assegniamo $H_{0}=H_{0}+A,\,H_{1}=H_{1}+B,\,H_{2}=H_{2}+C,\,H_{3}=H_{3}+D,\,H_{4}=H_{4}+E$;
\item il risultato dell'algoritmo è la stringa $H_{0}\parallel H_{1}\parallel H_{2}\parallel H_{3}\parallel H_{4}$,
il valore a 160bit dell'hash.
\end{enumerate}

\subsection{Paradosso del compleanno}

Consideriamo una coppia di persone: la probabilità che esse \uline{non}
abbiano il compleanno nello stesso giorno è pari a $\frac{364}{365}\simeq99.7\%$
(stiamo escludendo gli anni bisestili). Prendiamo ora un campione
di 100 persone; esse possono formare in totale $100\cdot99=990$ coppie
differenti; allora la probabilità che \uline{nessuna} delle coppie
abbia il compleanno nello stesso giorno si ottiene come:
\[
\left(\frac{364}{365}\right)^{990}\simeq6.6\%
\]
Calcoliamo ora la probabilità che, all'interno del campione di 100
persone, almeno due abbiano il compleanno nello stesso giorno:
\[
1-\left(1-\frac{1}{365}\right)\cdot\left(1-\frac{2}{365}\right)\cdot\ldots\cdot\left(1-\frac{99}{365}\right)\underset{N\gg r}{\sim}1-e^{-r^{2}/2N}\rightarrow1-e^{-10000/730}\simeq0.999999
\]
Nel caso in esame si ha $r=100$ e $N=365$; se invece vogliamo ottenere
il numero di persone $r$ che rende la probabilità di avere almeno
una coppia con lo stesso compleanno, possiamo usare al contrario la
formula approssimata appena enunciata:
\[
1-e^{-r^{2}/2N}=0.5\rightarrow\frac{r^{2}}{2N}=\ln\left(2\right)\rightarrow r^{2}\simeq1.17\sqrt{N}
\]
Quando $r$ è circa uguale alla radice di $N$, la probabilità di
collisioni è superiore al 50\%.

Consideriamo un terzo caso, più rilevante dal punto di vista crittografico;
prendiamo due insiemi di $r$ persone, ognuna delle quali ha il compleanno
in uno degli $N$ giorni dell'anno (le ripetizioni vengano considerate):
si dimostra che la probabilità che vi sia una corrispondenza per i
compleanni di una coppia di persone, ciascuna da un gruppo differente,
è pari a:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Collisione nel paradosso del compleanno}{\footnotesize{}\index{Compleanno, collisione nel paradosso del@{\footnotesize{}Compleanno, collisione nel paradosso del}}}}[-0.2cm]
\begin{equation}
1-e^{-r^{2}/N}\label{eq:Paradosso-compleanno-prob-corrispondenza}
\end{equation}

Possiamo adottare questo principio per attaccare la firma digitale
tramite hash. Sia data una funzione di hash con lunghezza 60bit: vi
saranno in totale $2^{60}\simeq10^{19}=N$ ``compleanni'' (hash
possibili); la probabilità di ottenere un hash desiderato scegliendo
il messaggio è pari a $1/2^{60}$ (pressoché nulla).

Se prendiamo due insiemi di $r$ documenti, e calcoliamo l'hash di
ciascuno di essi, troveremo una collisione al 50\% di probabilità
se $r$ vale:
\[
r\simeq\sqrt{2^{60}}=2^{30}\simeq10^{10}
\]
In pratica, nel caso di un hash a 60bit, possiamo generare un miliardo
di variazioni per un messaggio legittimo e un miliardo di variazioni
per un messaggio malevolo (modificando virgole, spazi o lettere maiuscole,
in modo che un osservatore distratto non noti la differenza); dalla
(\ref{eq:Paradosso-compleanno-prob-corrispondenza}) sappiamo che
otterremo una collisione dell'hash con probabilità circa $63.2\%$;
in questo modo è possibile ottenere un messaggio malevolo che appaia
firmato dall'autore del messaggio legittimo.
\begin{example}
\emph{Sia $h_{n}\left(x\right)$ una funzione di hash con ingresso
$x$ e lunghezza dell'uscita $n$ (espressa in bit). Calcolare le
probabilità di collisione per} $h_{4}\left(x\right)$, $h_{8}\left(x\right)$
e $h_{12}\left(x\right)$.
\end{example}
$\checked$Nella seguente tabella sono riassunte le considerazioni
per le tre funzioni di hash:\smallskip{}
\begin{table}[!h]
\begin{tabular}{lll}
$h_{4}\left(x\right)\implies16$ hash & $\mathbb{P}\left(\text{collisione}\right)=\frac{1}{16}$ & $1-\left(1-\frac{1}{16}\right)^{16}=0.6439$\tabularnewline
$h_{8}\left(x\right)\implies256$ hash & $\mathbb{P}\left(\text{collisione}\right)=\frac{1}{256}$ & $1-\left(1-\frac{1}{256}\right)^{256}=0.6328$\tabularnewline
$h_{12}\left(x\right)\implies4096$ hash & $\mathbb{P}\left(\text{collisione}\right)=\frac{1}{4096}$ & $1-\left(1-\frac{1}{4096}\right)^{4096}=0.6321$\tabularnewline
\end{tabular}
\end{table}
\smallskip{}
Nella terza colonna è stata valutata la probabilità $p$ di trovare
la collisione desiderata in $2^{n}$ tentativi (con $n$ il numero
di bit dell'uscita della funzione); osservando i valori di probabilità
ottenuti, possiamo dimostrare che essi tendono a un valore limite,
che possiamo descrivere nel seguente modo:
\[
\lm n{\infty}{\left(1-\frac{1}{n}\right)^{n}\rightarrow\frac{1}{e}\implies}p=1-\frac{1}{e}
\]
\demo

\subsection{Attacco del compleanno al logaritmo discreto}

Riprendiamo le ipotesi del problema del logaritmo discreto (\ref{eq:Logaritmo-discreto}):
\[
\cgm{\alpha^{x}}{\beta}p\implies\cgm x{\logd{\alpha}{\beta}}p
\]
Per risolvere il logaritmo discreto abbiamo introdotto l'algoritmo
``baby step, giant step'' (§\ref{subsec:Baby-step-giant-step}),
che consiste nel generare due liste lunghe al più $\sqrt{p}$; attuiamo
l'attacco del compleanno costruendo prima di tutto due liste: la prima
contiene $\left\{ \mod{\alpha^{k}}p\right\} $, la seconda $\left\{ \mod{\beta\cdot\alpha^{-\ell}}p\right\} $,
dove $k,\ell\in\mathbb{Z}_{p-1}^{*}$ sono scelti a caso.

Troviamo una corrispondenza tra le due liste al 50\% di probabilità,
calcolando $\sqrt{p}$ valori possibili per $k$ ed $\ell$; indicando
con $\overline{k}$ ed $\overline{\ell}$ i valori che permettono
di ottenere una corrispondenza tra le liste, possiamo scrivere:
\[
\cgm{\alpha^{\overline{k}}}{\beta\cdot\alpha^{-\overline{\ell}}}p\implies\cgm{\beta}{\alpha^{\overline{k}+\overline{\ell}}}p\implies\cgm{\overline{k}+\overline{\ell}}{\logd{\alpha}{\beta}}p
\]
In pratica possiamo affermare che il valore $\overline{k}+\overline{\ell}$
sia il valore che risolve il logaritmo discreto cercato, tuttavia
osserviamo che esso non è più efficace dell'algoritmo ``baby step,
giant step''; infatti, per applicare tale algoritmo non è necessario
compilare completamente la seconda lista, ma basta fermarsi alla prima
corrispondenza, inoltre i valori di $\overline{k}$ ed $\overline{\ell}$
sono casuali e non possono essere computati progressivamente. Infine,
la probabilità trovare una corrispondenza non è migliore di quella
ottenuta dall'applicazione del ``baby step, giant step''.

\section{Firma digitale}

La firma digitale è una stringa di bit associata al messaggio da firmare,
che include un segreto del firmatario. In pratica si utilizza lo hash
del messaggio da firmare, al quale viene aggiunto un segreto del firmatario,
cosicché solo chi è a conoscenza del segreto (il firmatario del messaggio)
è in grado di creare la firma associata; inoltre la firma deve essere
verificabile pubblicamente \textemdash~è l'opposto della cifratura
in un crittosistema a chiave pubblica: firmando con la chiave segreta
si permette a tutti di verificare la firma decifrandola con la chiave
pubblica; questo garantisce che solo chi è in possesso della chiave
privata associata alla forma, possa generarla.

Si firma l'hash del messaggio per evitare di avere una firma molto
lunga (pari o maggiore della lunghezza del messaggio) e questo non
compromette la sicurezza della firma, per le proprietà della funzione
di hash.

Altre\marginpar{Autenticazione di questo tipo viene classificata come \emph{HMAC}:
Hash-based Message Autentication Code} applicazioni delle funzioni di hash sono il controllo di integrità
(cambiando anche un bit di un messaggio, il suo hash cambia) e l'autenticazione
del messaggio (si usa una chiave simmetrica insieme al messaggio,
per generare l'hash).

\subsection{Firma RSA\label{subsec:Firma-RSA}}

Consideriamo due parti \textbf{A} e \textbf{B}, e \textbf{B} voglia
inviare un messaggio $m$ ad \textbf{A} in modo che lo firmi. L'algoritmo
per la firma RSA in questo caso si svolge come segue:
\begin{itemize}
\item \textbf{A} pubblica $n$ ed $e_{\text{A}}$, mantiene segreto $d_{\text{A}}$
\begin{itemize}
\item sceglie due primi grandi $p,\,q$ e li usa per calcolare $n=p\cdot q$
in modo da rendere questo intero computazionalmente non fattorizzabile;
\item sceglie\marginpar{Negli intervalli di definizione, 1 e $\varphi\left(n\right)$ sono
esclusi poiché $e_{\text{A}}$ e $d_{\text{A}}$ sono esponenti (elevando
a 1 non cambia la base, ed elevare al toziente di $n$ un residuo
modulo $n$ dà 1)} la sua chiave di cifratura pubblica come $e_{\text{A}}\in\left(1,\,\varphi\left(n\right)\right)$;
\item crea la sua chiave di decifratura come $d_{\text{A}}\in\left(1,\,\varphi\left(n\right)\right)$,
che deve essere l'inverso di $e_{\text{A}}$ ($\cgm{d_{\text{A}}\cdot e_{\text{A}}}1{\varphi\left(n\right)}$);
\end{itemize}
\item \textbf{B} invia ad \textbf{A} il messaggio $m$ da firmare;
\item \textbf{A} firma il messaggio, producendo ${\scriptstyle \text{SIG}}_{\text{A}}\left(m\right)=\mod{m^{d_{\text{A}}}}n$;
\item \textbf{B} verifica la firma di \textbf{A} provando che valga $\mod{{\scriptstyle \text{SIG}}_{\text{A}}\left(m\right)^{e_{\text{A}}}}{n\overset{?}{=}m}$.
\end{itemize}
\begin{rem}
In RSA, per decifrare un messaggio cifrato da \textbf{A}, conoscendo
solo i dati pubblici $n$ ed $e_{\text{A}}$, dobbiamo ottenere l'esponente
di decifratura $\cgm{d_{\text{A}}}{e_{\text{A}}^{-1}}{\varphi\left(n\right)}$;
per calcolare questo inverso possiamo usare (\ref{eq:Teorema-Eulero})
oppure (\ref{eq:Algoritmo-Euclide-esteso}) ma in entrambi i casi
avremo bisogno di $\varphi\left(n\right)=\left(p-1\right)\left(q-1\right)$.

La firma digitale RSA funziona nel modo inverso, usando l'esponente
di decifratura per firmare e quello di cifratura per verificare la
firma.
\end{rem}
%
\begin{rem}
Questo tipo di firma nasconde il messaggio al suo interno; inoltre
intercettando una qualunque firma ${\scriptstyle \text{SIG}}_{\text{A}}\left(m\right)$
ed elevandola ad $e_{\text{A}}$ modulo $n$, otteniamo un messaggio
valido firmato da A; tuttavia esso risulterà una serie casuale di
bit.
\end{rem}

\subsection{Firma cieca}

Consideriamo la seguente variazione dell'algoritmo della firma digitale
RSA. \textbf{B} vuole che \textbf{A} firmi un messaggio $m$, senza
che \textbf{A} conosca il suo contenuto:
\begin{itemize}
\item \textbf{A} pubblica $n$ ed $e_{\text{A}}$, mantiene segreto $d_{\text{A}}$
(tutti e tre gli interi sono costruiti come in §\ref{subsec:Firma-RSA});
\item \textbf{B} sceglie un intero casuale $k\perp n$, da usare una volta
sola (nonce);
\begin{itemize}
\item \textbf{B} calcola $\cgm t{m\cdot k^{e_{\text{A}}}}n$;
\item \textbf{B} invia ad \textbf{A} il messaggio cifrato $t$;
\end{itemize}
\item \textbf{A} firma il messaggio calcolando $\cgm s{t^{d_{\text{A}}}}n={\scriptstyle \text{SIG}}_{\text{A}}\left(t\right)$;
\begin{itemize}
\item \textbf{A} invia la firma $s$ a \textbf{B};
\end{itemize}
\item \textbf{B} verifica la firma calcolando $\mod{s\cdot k^{-1}}n$, ottenendo
\[
\cgm{\overset{s}{\overbrace{m^{d_{\text{A}}}\cdot k^{e_{\text{A}}\cdot d_{\text{A}}}}}\cdot k^{-1}}{m^{d_{\text{A}}}\cdot\bcancel{k}\cdot\cancel{k^{-1}}}n
\]
ovvero \textbf{B} computa proprio la firma di \textbf{A} del messaggio
$m$ (secondo l'algoritmo della firma digitale RSA).
\end{itemize}

\subsection{Firma di El Gamal}

Seguendo l'applicazione della firma RSA, l'algoritmo per la firma
di El Gamal si applica firmando con la chiave privata e verificando
la firma tramite la chiave pubblica; in questo caso la chiave privata
può essere ottenuta a partire da quella pubblica solo risolvendo il
problema del logaritmo discreto.

Consideriamo le stesse premesse delle sezioni precedenti \textemdash~\textbf{B}
ha un messaggio $m$ che vuole far firmare ad \textbf{A} (se il messaggio
è più lungo di $p$, deve essere spezzato blocchi di dimensione $p$,
dato che l'algoritmo opera in $\mathbb{Z}_{p}^{*}$):
\begin{itemize}
\item A pubblica un primo $p$ e un intero $\alpha$;
\begin{itemize}
\item $p$ tale da rendere intrattabile il problema del logaritmo discreto
in $\mathbb{Z}_{p}^{*}$;
\item $\alpha$ sia una radice primitiva di $\mathbb{Z}_{p}^{*}$ (per garantire
l'esistenza di una soluzione al problema del logaritmo discreto);
\end{itemize}
\item \textbf{A} sceglie un esponente intero segreto $a\in\left(1,\,p-2\right)$;
\begin{itemize}
\item \textbf{A} calcola e pubblica $\cgm{\beta}{\alpha^{a}}p$ (nella pratica
è impossibile ottenere il segreto $a$ risolvendo questa equazione
con un logaritmo discreto);
\end{itemize}
\item \textbf{A} sceglie un esponente casuale $k\in\left(1,\,p-2\right)$,
da considerarsi come nonce;
\begin{itemize}
\item A produce la firma ${\scriptstyle \text{SIG}}_{\text{A}}\left(m\right)=\left(r,\,s\right)$;
\item $\cgm r{\alpha^{k}}p$;
\item $\cgm s{k^{-1}\left(m-a\cdot r\right)}{\left(p-1\right)}$;
\end{itemize}
\item B verifica la firma $\left(r,\,s\right)$ usando solo dati pubblici;
\begin{itemize}
\item la firma risulta corretta se si verifica la congruenza $\cgms{\beta^{r}\cdot r^{s}}{\alpha^{m}}p?$;
\end{itemize}
\end{itemize}
%
Mostriamo ora come la congruenza appena enunciata sia una verifica
corretta per la firma di El Gamal; dalla definizione di $s$, moltiplichiamo
per $k$ entrambi i lati della congruenza:
\[
\begin{array}{c}
\cgm{k\cdot s}{\bcancel{k}\cdot\cancel{k^{-1}}\left(m-a\cdot r\right)}{\left(p-1\right)}\\
\cgm m{k\cdot s+a\cdot r}{\left(p-1\right)}\\
\cgms{\alpha^{m}}{\overset{\varhexstar}{\overbrace{\alpha^{k\cdot s+a\cdot r}}}}p{{\scriptscriptstyle \bigstar}}\\
\cgm{\overset{\varhexstar}{\overbrace{\underset{{\scriptscriptstyle \blacktriangle}}{\underbrace{\left(\alpha^{a}\right)^{r}}}\cdot\underset{{\scriptscriptstyle \blacksquare}}{\underbrace{\left(\alpha^{k}\right)^{s}}}}}}{\overset{{\scriptscriptstyle \blacktriangle}}{\overbrace{\beta^{r}}}\cdot\overset{{\scriptscriptstyle \blacksquare}}{\overbrace{r^{s}}}}p\\
\cgm{\alpha^{m}}{\beta^{r}\cdot r^{s}}p
\end{array}
\]
Nella relazione ${\scriptstyle \bigstar}$ abbiamo usato (\ref{eq:Principio-fondamentale}),
dato che gli esponenti di $\alpha$ sono congruenti in modulo $p$;
l'ultima congruenza è proprio quella che verifica la firma di El Gamal.
\begin{rem}
La firma generata in questo modo non è sempre la stessa, fissato il
messaggio: infatti essa dipende dal segreto effimero $k$; quindi
ci sono $p-2$ firme valide per lo stesso messaggio $m$. Rispetto
alla firma cieca, in questo modo non è neanche possibile capire se
è lo stesso messaggio ad essere firmato due volte.
\end{rem}
%
\begin{rem}
La firma RSA è lunga quanto il messaggio firmato; la firma di El Gamal
è lunga il doppio del messaggio firmato (essa è espressa da due interi
$r$ ed $s$, con lo stesso ordine di grandezza); questo riconferma
la necessità di firmare l'hash del messaggio e non il messaggio stesso,
altrimenti la firma avrebbe una dimensione troppo grande rispetto
al messaggio.
\end{rem}

\subsection{Attacco del nonce ripetuto}

Un attaccante è in grado di firmare con El Gamal un messaggio al posto
di \textbf{A} in modo che \textbf{B} possa comunque verificare correttamente
la sua firma; questo accade quando \textbf{A} utilizza due volte lo
stesso $k$ per firmare.

Dal punto di vista di un osservatore esterno, quando A emette due
firme differenti ${\scriptstyle \text{SIG}}_{\text{A}}\left(m_{1}\right)=\left(r_{1},\,s_{1}\right)\neq{\scriptstyle \text{SIG}}_{\text{A}}\left(m_{2}\right)=\left(r_{2},\,s_{2}\right)$
tali che $r_{1}=r_{2}=r^{\prime}$, si può ricavare il nonce $k$
nel modo seguente:
\[
\begin{cases}
\cgm{-a\cdot r^{\prime}}{s_{1}\cdot k-m_{1}}{\left(p-1\right)}\\
\cgm{-a\cdot r^{\prime}}{s_{2}\cdot k-m_{2}}{\left(p-1\right)}
\end{cases}\implies\;\cgm{\left(s_{1}-s_{2}\right)k}{m_{1}-m_{2}}{\left(p-1\right)}
\]
La seconda relazione è il frutto della differenza tra le prime due;
possiamo calcolare $k$ dall'equazione lineare in una incognita:
\begin{equation}
\cgm k{\left(m_{1}-m_{2}\right)\cdot\left(s_{1}-s_{2}\right)^{-1}\,}{\left(p-1\right)}\label{eq:Attacco-nonce-ripetuto}
\end{equation}
Per risolverla dobbiamo ottenere l'inverso di $s_{1}-s_{2}$ modulo
$p-1$ (non è detto che esista): calcoliamo quindi $\mcd{s_{1}-s_{2}}{p-1}=d$;
esso dovrebbe essere un numero relativamente piccolo e rappresenta
il numero di soluzioni dell'equazione.

Una volta ottenuti $d$ valori di $k$, possiamo ricavare il segreto
$a$ risolvendo una equazione congruenziale lineare in una incognita:
\[
\cgm a{r^{-1}\left(m-k\cdot s\right)}{\left(p-1\right)}
\]
Di nuovo, otterremo non uno ma $n$ possibili valori di $a$ che risolvono
l'equazione.

\chapter*{Esercizi}

\section*{Equazioni congruenziali}
\begin{xca}
Risolvere la seguente equazione congruenziale:\marginpar{$\blacktriangleright$ \emph{Esercizio: equazione congruenziale, modulo
composto}}
\[
\cgm{28x}{16}{412}
\]
\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Procediamo calcolando $\mcd{28}{412}=4$; allora possiamo dividere
per 4 tutti i termini dell'equazione, ottenendo
\[
\cgm{7x}4{103}
\]
L'equazione originale avrà 4 soluzioni, e la prima si ricava dall'equazione
ridotta appena trovata:
\[
\cgm{x_{0}}{4\cdot7^{-1}}{103}
\]
Per calcolare l'inverso di 7 modulo 103 possiamo usare il Teorema
\ref{thm:Teorema-piccolo-Fermat} oppure l'algoritmo (\ref{eq:Algoritmo-Euclide-esteso}).\bigskip{}

\noun{Teorema piccolo di Fermat}\\
Il teorema afferma che, in questo caso, vale
\[
\cgm{7^{-1}}{7^{101}}{103}
\]
dato che 103 è primo; adesso effettuiamo l'operazione di $\mod{7^{101}}{103=59}$
(possiamo usare l'algoritmo descritto ne \secref{Square-=000026-multiply}),
da cui segue che
\[
\cgm{7^{-1}}{59}{103}
\]

\noun{Algoritmo di Euclide Esteso}\\
Usiamo l'algoritmo per ottenere che $7\perp103$ e in tal caso anche
$7^{-1}$; cominciamo a costruire la sequenza (\ref{eq:Algoritmo-Euclide}):
\[
\begin{array}{cc}
103=14\cdot7+5 & q_{1}=14\\
7=1\cdot5+2 & q_{2}=1\\
5=2\cdot2+\boxed{1} & q_{3}=2\\
2=2\cdot1+0 & q_{4}=1
\end{array}
\]
Otteniamo che $\mcd 7{103}=1$, e per quanto riguarda l'inverso costruiamo
la sequenza (\ref{eq:Algoritmo-Euclide-esteso}):
\[
\begin{array}{c}
x_{0}=0\\
x_{1}=1\\
x_{2}=-q_{1}x_{1}+x_{0}=-14\\
x_{3}=-q_{2}x_{2}+x_{1}=15\\
x_{4}=-q_{3}x_{3}+x_{2}=\boxed{-44}
\end{array}
\]
Segue che $\mod{-44}{103}=59=7^{-1}$.

\bigskip{}

Ora che abbiamo l'inverso di 7 in modulo 103, siamo in grado di scrivere
la soluzione dell'equazione ridotta:
\[
\begin{array}{c}
\cgm{x_{0}}{4\cdot59}{103}\\
\cgm{x_{0}}{30}{103}
\end{array}
\]
Le soluzioni successive saranno altre tre, a 103 di distanza da $x_{0}$,
esse inoltre saranno in modulo 412:
\[
X=\left\{ 30,\,133,\,236,\,339\right\} \mod{}{412}
\]
\demo
\end{sol}
\begin{xca}
Trovare\marginpar{$\blacktriangleright$ \emph{Esercizio: sistema di 2 congruenze}}
la congruenza equivalente al seguente sistema di congruenze:
\[
\begin{cases}
\cgm x5{11}\\
\cgm x2{20}
\end{cases}
\]
\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Esisterà una sola congruenza equivalente, per il Teorema \ref{thm:Teorema-cinese-del-resto},
infatti vale $11\perp20$; per riassumere le due congruenze in una
sola, cerchiamo un valore $x$ della successione $5+k\cdot11$ che
sia anche congruente a 2 in modulo 20:
\[
x=\cgm{5+k\cdot11}2{20}
\]
Questo sarà vero per un valore di $k$ pari a
\[
\begin{array}{c}
\cgm{k\cdot11}{2-5}{20}\\
\cgm k{-3\cdot11^{-1}}{20}
\end{array}
\]
Troviamo l'inverso di 11 in modulo 20 usando il Teorema \ref{thm:Teorema-Eulero}:
\[
\cgm{11^{-1}}{11^{\varphi\left(20\right)-1}}{20}
\]
sapendo che la funzione toziente di 20 vale $\varphi\left(20\right)=\left(2^{2}-2^{1}\right)\left(5^{1}-5^{0}\right)=2\cdot4=8$,
e che $\mod{11^{8-1}}{20}=11$, abbiamo la seguente congruenza per
$k$:
\[
\begin{array}{c}
\cgm k{-33}{20}\\
\cgm k7{20}
\end{array}
\]
Ritornando alla congruenza per $x$, si ottiene dalla precedente (con
$k=7$):
\[
\begin{array}{c}
x=\cgm{5+77}2{20\cdot11}\\
\cgm x{82}{220}
\end{array}
\]
dove abbiamo usato il Teorema \ref{thm:Teorema-cinese-del-resto}
per comporre la congruenza in modulo 220.\demo
\end{sol}
\begin{xca}
Trovare\marginpar{$\blacktriangleright$ \emph{Esercizio: sistema di 3 congruenze}}
il valore della variabile $x$, che compare nel sistema di congruenze:
\[
\begin{cases}
\cgm x1{10}\\
\cgm x2{11}\\
\cgm x03
\end{cases}
\]
\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Mettiamo assieme la prima congruenza con la seconda, ottenendo:
\[
x=\cgm{1+k\cdot10}2{11}
\]
Risolviamo la precedente rispetto a $k$:
\[
\cgm{k\cdot10}1{11}
\]
Notando che $100=9\cdot11+1\implies\mod{100}{11}=1$ possiamo affermare
subito che $k=10$; per il Teorema \ref{thm:Teorema-cinese-del-resto}
scriviamo:
\[
\cgm x{101}{110}
\]
Unendo quanto ottenuto con la terza congruenza del sistema, si ha:
\[
x=\cgm{101+k\cdot110}03
\]
Effettuando l'operazione di modulo 3 sui termini dell'equazione, avremo:
\[
x=\cgm{2+h\cdot2}03
\]
Risolviamo la precedente rispetto ad $h$:
\[
\begin{array}{c}
\cgm{2\cdot h}{-2}3\\
\cgm h{1\cdot2^{-1}}3
\end{array}
\]
Osserviamo che l'inverso di 2 in $\mathbb{Z}_{3}$ è proprio 2, infatti
$2\cdot2=\mod 43=1$; allora $h$ è congruente a 2 in modulo 3, e
sostituendo nella congruenza di $x$ otteniamo:
\[
\begin{array}{c}
\cgm x{101+220}{110\cdot3}\\
\cgm x{321}{330}
\end{array}
\]
Abbiamo trovato che $x$ deve valere $321+k\cdot330$ per generare
le tre congruenze esaminate.\demo
\end{sol}

\section*{Elementi primitivi}
\begin{xca}
Quanti elementi primitivi ha l'insieme $\mathbb{Z}_{31}^{*}$, e quali
sono?\marginpar{$\blacktriangleright$ \emph{Esercizio: elementi primitivi di un insieme
dei residui}}

\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Gli elementi primitivi sono in numero $\varphi\left(31-1\right)=\varphi\left(30\right)=\left(2^{1}-2^{0}\right)\left(3^{1}-3^{0}\right)\left(5^{1}-5^{0}\right)=1\cdot2\cdot4=8$
(applichiamo una delle formule \vpageref{eqn:Toziente} per calcolare
il toziente $\varphi\left(\circ\right)$).

Per capire quali siano gli elementi primitivi, usiamo il test (\ref{eq:Test-primitivit=0000E0})
con i quozienti $q_{i}=\left\{ 2,\,3,\,5\right\} $, per ciascun elemento
di $\mathbb{Z}_{31}^{*}$ (da 1 a 30); facendo le prove col test rispetto
ai tre quozienti, si ottengono i seguenti elementi primitivi:
\[
\alpha=\left\{ 3,\,11,\,12,\,13,\,\ldots\right\} 
\]
\demo
\end{sol}
\begin{xca}
Trovare gli elementi primitivi dell'insieme $\mathbb{Z}_{13}^{*}$\marginpar{$\blacktriangleright$ \emph{Esercizio: elementi primitivi di un insieme
dei residui}}

\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Usiamo un secondo metodo, a partire da un elemento sicuramente primitivo
$\alpha\in\mathbb{Z}_{13}^{*}$; proviamo con 2, sottoponendolo al
test (\ref{eq:Test-primitivit=0000E0}):
\[
\cgm{2^{6}}{-1}{13},\quad\cgm{2^{4}}3{13}
\]
Allora $\alpha=2$ è un elemento primitivo rispetto a $p=13$; possiamo
elevare $\alpha$ a tutte le potenze, per ottenere tutti gli elementi
dell'insieme. Tuttavia solo le potenze positive pari restituiranno
un altro elemento primitivo rispetto a $p$ che è un quadrato:
\[
\begin{array}{lll}
\cgm{\alpha^{1}}2{13} & \cgm{\alpha^{5}}6{13} & \cgm{\alpha^{9}}5{13}\\
\cgm{\alpha^{2}}{\boxed{4}}{13} & \cgm{\alpha^{6}}{\boxed{12}}{13} & \cgm{\alpha^{10}}{\boxed{10}}{13}\\
\cgm{\alpha^{3}}8{13} & \cgm{\alpha^{7}}{11}{13} & \cgm{\alpha^{11}}7{13}\\
\cgm{\alpha^{4}}{\boxed{3}}{13} & \cgm{\alpha^{8}}{\boxed{9}}{13} & \cgm{\alpha^{12}}{\boxed{1}}{13}
\end{array}
\]
Le radici primitive in $\mathbb{Z}_{13}^{*}$ sono:
\[
a_{q}=\left\{ 1,\,3,\,4,\,9,\,10,\,12\right\} 
\]
Si noti che ci troviamo nel caso $\cgm p14$, per cui se non esiste
$\sqrt{a}$ nemmeno $\sqrt{-a}$ è definita rispetto a $p$.\demo
\end{sol}

\section*{Scrambling}
\begin{xca}
Si\marginpar{$\blacktriangleright$ \emph{Esercizio: scrambler auto-sincronizzante}}
consideri uni scrambler auto-sincronizzante con polinomio caratteristico
$P\left(Y\right)=Y^{3}+Y+1$; esso è inizializzato come $M_{1}M_{2}M_{3}=000$,
in ingresso si ha una sequenza di soli 1 ($\left\{ I_{k}\right\} =111\ldots$);
determinare la sequenza di uscita $\left\{ U_{k}\right\} $.

\rule[0.5ex]{0.9\textwidth}{0.1pt}
\end{xca}
\begin{sol}
Innanzitutto cerchiamo il periodo della successione, analizzando la
riducibilità del polinomio $P\left(Y\right)$; esso non è divisibile
per $Y$, tuttavia può esserlo per $Y+1$; dalla divisione tra polinomi
si ottiene:\marginpar{Si ricorda che le operazioni su questo polinomio sono tutte in \uline{modulo
2}}
\[
\begin{array}{rl}
Y^{3}\quad\quad+Y+1 & \underline{\left(\div\,Y+1\right)}\\
\underline{Y^{3}+Y^{2}\quad\;\qquad} & \quad Y^{2}+Y\\
Y^{2}+Y+1 & \,\\
\underline{Y^{2}+Y\quad\,\,\,\,} & \,\\
1
\end{array}
\]
Ottenendo resto non nullo, confermiamo che il polinomio non può essere
diviso nemmeno per $Y+1$; in tal caso possiamo affermare che $P\left(Y\right)$
sia irriducibile, e quindi il periodo della sequenza pseudo-casuale
generata sarà determinato dal suo grado $M=3$ come $\pi=2^{3}-1=7$.

Lo scrambler descritto dal polinomio $P\left(Y\right)$ può essere
implementato col circuito ne \figref{scrambler-auto-sincronizzante-3};
l'andamento della sua uscita si ricava riempiendo la seguente tabella
(viene mostrato anche il descrambling della sequenza $\left\{ U_{k}\right\} $
ottenuta):\bigskip{}
\\
\begin{minipage}[c]{0.5\textwidth}%
\begin{center}
\begin{tabular}{c|cccc|c}
$k$ & $\overset{\bullet}{I}_{k}$ & $\overset{\bullet}{M}_{1,k}$ & $M_{2,k}$ & $\overset{\bullet}{M}_{3,k}$ & $U_{k}$\tabularnewline
\hline 
0 & 1 & \emph{0} & \emph{0} & \emph{0} & 1\tabularnewline
1 & 1 & 1 & 0 & 0 & 0\tabularnewline
2 & 1 & 0 & 1 & 0 & 1\tabularnewline
3 & 1 & 1 & 0 & 1 & 1\tabularnewline
4 & 1 & 1 & 1 & 0 & 0\tabularnewline
5 & 1 & 0 & 1 & 1 & 0\tabularnewline
6 & 1 & 0 & 0 & 1 & 0\tabularnewline
\hline 
\hline 
7 & 1 & 0 & 0 & 0 & 1\tabularnewline
\end{tabular}\captionof{table}{Uscita dello scrambler}
\par\end{center}%
\end{minipage}%
\begin{minipage}[c]{0.5\textwidth}%
\begin{center}
\begin{tabular}{c|cccc|c}
$k$ & $\overset{\bullet}{U}_{k}$ & $\overset{\bullet}{M}_{1,k}$ & $M_{2,k}$ & $\overset{\bullet}{M}_{3,k}$ & $I_{k}$\tabularnewline
\hline 
0 & 1 & \emph{1} & \emph{0} & \emph{0} & \textbf{0}\tabularnewline
1 & 0 & 1 & 1 & 0 & \textbf{1}\tabularnewline
2 & 1 & 0 & 1 & 1 & \textbf{0}\tabularnewline
\hline 
3 & 1 & 1 & 0 & 1 & 1\tabularnewline
4 & 0 & 1 & 1 & 0 & 1\tabularnewline
5 & 0 & 0 & 1 & 1 & 1\tabularnewline
6 & 0 & 0 & 0 & 1 & 1\tabularnewline
7 & 1 & 0 & 0 & 0 & 1\tabularnewline
\end{tabular}\captionof{table}{Uscita del descrambler}
\par\end{center}%
\end{minipage}\\
La tabella indica lo stato al passo $k$-esimo delle celle di memoria
e dell'uscita; la consegna prevede di assegnare all'ingresso 1 in
ciascun passo ($\forall k\in\left[0,\,\infty\right)\tc I_{k}=1$).
Le colonne con un cerchio pieno sopra l'etichetta di una colonna relativa
a una cella di memoria, indica che essa è collegata in retroazione;
in pratica l'uscita sarà influenzata dalla somma modulo 2 dell'ingresso
con tutte le celle $\overset{\bullet}{M}_{i,k}$.

Possiamo notare che l'uscita ha proprio periodo 7; infatti lo stato
delle celle di memoria al passo 7 è uguale a quello al passo 0.

SI noti che, nella tabella del descrambler, le tre celle di memoria
sono state inizializzate in modo arbitrario ($M_{1}M_{2}M_{3}=100$),
inoltre sono stati necessari 3 passi per avere la traduzione corretta
della sequenza \textemdash~lo scrambler auto-sincronizzante descritto
da $P\left(Y\right)$ impiega $M=3$ passi per raggiungere da solo
la configurazione corretta.\demo
\end{sol}

\part{Protocolli e sistemi per la comunicazione sicura}

\appendix

\chapter{Introduzione alla crittografia}

\subsection*{Cenni storici}

Il termine crittografia deriva dal greco $\kappa\rho\nu\pi\tau\acute{o}\zeta$
(krypt$\acute{\text{o}}$s - segreto) e $\gamma\rho\alpha\varphi\acute{\eta}$
(grafi - scrittura); tra gli esempi di crittografia dal passato il
più famoso è il cifrario di Cesare: si tratta di un cifrario a scorrimento
ciclico, che consisteva nello scrivere le lettere dell'alfabeto su
due anelli per poi ruotarne uno rispetto all'altro di $k=+3$ posizioni;
in questo modo si ottiene $A\rightarrow D,\,B\rightarrow E,\,\ldots Z\rightarrow C$.

Non si trattava di un cifrario robusto, ma veniva usato quando gli
avversari dell'Impero Romano erano i Galli: si rivelò un metodo più
che sufficiente.

\subsection*{Comunicazione sicura}

In generale una comunicazione sicura tra due parti si svolge nel modo
seguente: sia $A$ il mittente del messaggio, $B$ il destinatario,
ed $E$ un intruso che abbia accesso al canale di comunicazione. L'intruso
può essere \emph{passivo} (intercetta i messaggi senza modificarne
il flusso) oppure \emph{attivo} (modifica il contenuto dei messaggi).

\begin{figure}[!h]
\begin{centering}
\includegraphics[scale=1.3]{\string"Illustrazioni/A_1 Scenario fondamentale di comunicazione\string".pdf}
\par\end{centering}
\caption{Scenario fondamentale di comunicazione}
\label{fig:Scenario-fondamentale- comunicazione}
\end{figure}

$\boldsymbol{A}$ invia un \emph{plaintext} $m$ (testo in chiaro),
lo codifica usando una funzione di cifratura (un algoritmo crittografico)
che prende in ingresso anche la sua chiave $k_{{\scriptscriptstyle \text{A}}}$
e ottiene un \emph{ciphertext $c$} (messaggio cifrato); il messaggio
$c$ giunge a $\boldsymbol{B}$, il quale usa una funzione di de-cifratura
\textemdash~tramite la sua chiave $k_{{\scriptscriptstyle \text{B}}}$,
che è associata in qualche modo alla chiave $k_{{\scriptscriptstyle \text{A}}}$
\textemdash~per ottenere nuovamente il \emph{plaintext} $m$ inviato
da \textbf{$\boldsymbol{A}$}.

$\boldsymbol{E}$ potrebbe avere le seguenti intenzioni malevole rispetto
alla comunicazione tra $\boldsymbol{A}$ e $\boldsymbol{B}$:
\begin{itemize}
\item leggere il messaggio e comprenderne il contenuto;
\item ottenere la chiave;
\item corrompere il contenuto del messaggio;
\item impersonare $A$ senza che $B$ se ne accorga.
\end{itemize}
L'intruso può mettere in atto i seguenti tipi di attacchi sull'algoritmo
di cifratura usato nella comunicazione:
\begin{itemize}
\item \noun{ciphertext-only}: avendo a disposizione il testo cifrato, si
cerca di ricavarne delle informazioni (attacco più comune);
\item \noun{known plaintext}: avendo a disposizione una coppia di testo
cifrato e testo in chiaro corrispondente, si confrontano i due cercando
di ottenere informazioni sulla chiave;
\item \noun{chosen plaintext}: avendo a disposizione la stessa implementazione
dell'algoritmo utilizzato per cifrare il messaggio, si scelgono dei
testi in chiaro da cifrare e si osservano i testi cifrati in uscita,
per cercare di ricavare informazioni sull'implementazione;
\item \noun{chosen ciphertext}: avendo a disposizione la stessa implementazione
dell'algoritmo utilizzato per decifrare il messaggio, si scelgono
dei testi cifrati da decifrare e si osservano i testi in chiaro in
uscita, per cercare di ricavare informazioni sull'implementazione.
\end{itemize}

\subsection*{Sicurezza e segretezza}

Giulio Cesare basava la sicurezza del proprio algoritmo di cifratura
sul fatto che i possibili avversari non ne conoscessero il funzionamento;
il crittografo olandese Auguste Kerckhoffs, enunciò ne \emph{`La cryptographie
militaire'} (1883) il principio di Kerchoffs:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Principio di Kerchoffs}{\footnotesize{}\index{Kerchoffs, principio di@{\footnotesize{}Kerchoffs, principio di}}\label{thm:Principio-di-Kerchoffs}}}[0.7cm]
\begin{center}
\begin{minipage}[t]{0.8\textwidth}%
\begin{center}
\emph{La sicurezza di un sistema di cifratura è basata sulla segretezza
della chiave (assumere sempre che il nemico conosca l'algoritmo di
cifratura)}
\par\end{center}%
\end{minipage}
\par\end{center}

Da questa considerazione segue che la chiave utilizzata deve essere
lunga, complessa, e in generale essere costruita per evitare che sia
possibile indovinarla.

Claude Elwood Shannon, che scrisse cinque articoli che cambiarono
la storia della comunicazione dell'informazione, tra cui un articolo
sulla crittografia\footnote{\emph{``Communication Theory of Secrecy Systems'' }(1949), Bell
System Technical Journal}, espresse lo stesso principio in maniera molto incisiva con le parole
``Il nemico conosce il sistema'' (frase nota come massima di Shannon).

È interessante notare come si è passati dal fondare la sicurezza del
sistema sulla segretezza dell'algoritmo alla segretezza della chiave;
il passo successivo fu il sistema a \emph{chiave pubblica}: gli algoritmi
usati sono noti e accessibili a tutti, e una chiave del mittente (quella
pubblica) è resa nota a tutti; tramite la chiave pubblica è possibile
cifrare i messaggi, tuttavia la chiave per decifrare, associata alla
chiave pubblica, è mantenuta riservata (si parla di\emph{ chiave privata}).

Fondamentale è il fatto che, non ostante esista una regola (formula
o algoritmo) che permetta di associare la chiave pubblica a quella
privata, per un intruso qualunque è impossibile, dal punto di vista
computazionale, risalire alla chiave privata attraverso quella pubblica.
Solo il mittente che possiede la chiave privata è in grado di computare
questa associazione, poiché egli deve aver ricavato la chiave pubblica
a partire da quella privata (l'operazione inversa risulta molto più
difficile).

\subsection*{Algoritmi noti}

Gli algoritmi a chiave simmetrica hanno una coppia di chiavi, per
cifratura e de-cifratura, che sono entrambe segrete: DES, AES; si
pone il problema di scambiare col destinatario la chiave di de-cifratura,
utilizzando un canale sicuro.

Con i sistemi di cifratura a chiave pubblica questo problema non si
pone, tuttavia si pone il nuovo problema dell'autenticità delle chiavi
pubbliche in circolazione; è stato introdotto il meccanismo dei certificati,
da associare alle chiavi pubbliche, per garantire la loro provenienza
e affidabilità.

\subsection*{Numeri interi grandi}

Lavoreremo prevalentemente con numeri interi (positivi e negativi)
di elevato ordine di grandezza; ecco un esempio per effettuare un
calcolo approssimato.
\begin{example}
\emph{\label{ex:grandi-interi-approssimati}Calcolare in modo approssimato
il valore di $2^{35}$.}

\emph{$\checked$}Sfruttando le proprietà delle potenze e la costante
informatica $2^{10}\sim1000=10^{3}$, possiamo ragionare nel modo
seguente:
\[
2^{35}=2^{30}\cdot2^{5}=\left(2^{10}\right)^{3}\cdot32\simeq\left(10^{3}\right)^{3}\cdot32=\boxed{32\times10^{9}}
\]
\demo
\end{example}
Trattare interi grandi è importante nell'ambito degli algoritmi di
cifratura: prendendo l'algoritmo a chiave simmetrica DES come esempio,
è ragionevole pensare che una chiave di 56 bit non sia sufficientemente
sicura; usando le considerazioni fatte nell'Esempio \ref{ex:grandi-interi-approssimati}
otteniamo che $2^{56}\simeq10^{16}$, ed essendo in possesso di una
macchina in grado di ottenere una chiave in 1$ns$, allora sarebbero
necessari 27 mesi per ottenere questa chiave; ovviamente si può ridurre
questo tempo aumentando il numero di macchine impiegate.

Al giorno d'oggi sono considerate sicure chiavi a 265 bit ($\sim10^{77}$):
per analizzare in modo esaustivo un simile spazio delle chiavi sarebbero
necessari $10^{60}$ anni, nelle condizioni descritte in precedenza!

\chapter{Campi di Galois}

\section{Costruzione con polinomi}

Per comprendere la struttura e le proprietà dei campi di Galois, analizziamo
il seguente esempio: sia dato l'insieme $\mathcal{GF}\left(4\right)=\left\{ 0,\,1,\,\omega,\,\omega^{2}\right\} ,$che
chiamiamo ``campo di Galois 4''; su questo insieme siano definite
le seguenti proprietà, posto $\forall x\in\mathcal{GF}\left(4\right)$:
\begin{enumerate}
\item Ogni elemento del campo ha un inverso additivo: $x+0=x$;
\item $x+x=0$;
\item Ogni elemento del campo ha un inverso moltiplicativo: $1\cdot x=x$;
\item $\omega+1=\omega^{2}$;
\item somma e prodotto godono delle proprietà commutativa, associativa e
distributiva.
\end{enumerate}
Usando queste proprietà possiamo calcolare $\omega^{2}+1\overset{{\scriptscriptstyle 4}}{\rightarrow}\omega+1+1\overset{{\scriptscriptstyle 2}}{\rightarrow}\omega$.
Notiamo dalle proprietà enunciate, che con 0 indichiamo l'elemento
neutro rispetto alla somma e con 1 l'elemento neutro rispetto al prodotto;
rispetto alla somma inoltre, ogni elemento è l'inverso di sé stesso.
L'inverso moltiplicativo invece, non è definito per 0, e vale 1 per
l'elemento 1; negli altri casi, ($\omega$ e $\omega^{2}$) si ha
che l'inverso è $\omega^{2}$; infatti si ricava che 
\[
\omega\cdot\omega^{2}=\omega\cdot\left(\omega+1\right)=\omega+\omega^{2}=\omega+\omega+1=1\implies\omega\cdot\omega^{2}=1\implies\boxed{\omega^{-1}=\omega^{2}}
\]
Vale alche l'opposto, ovvero l'inverso di $\omega^{2}$ è $\omega$.

Possiamo enunciare la definizione di \emph{campo}:
\begin{defn}
\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Campo}{\footnotesize{}\index{Campo@{\footnotesize{}Campo}}\label{def:Campo}}}[-0.2cm]Un campo è un insieme che abbia almeno una operazione di
somma e una di prodotto, includa come minimo gli elementi 0 e 1, dove
0 è l'elemento neutro rispetto alla somma e 1 l'elemento neutro rispetto
al prodotto; l'insieme deve soddisfare inoltre le proprietà ${\scriptstyle \left(1\right)}$,
${\scriptstyle \left(3\right)}$ e ${\scriptstyle \left(5\right)}$
tra quelle elencate in precedenza.
\end{defn}
Questo implica che un insieme che soddisfa la definizione di campo
sarà chiuso rispetto alle operazioni di somma e prodotto.
\begin{example}
L'insieme dei numeri reali forma un campo, infatti in esso sono contenuti
0 e 1, e per ciascun numero reale esiste un inverso definito all'interno
dell'insieme.

L'insieme degli interi non è un campo, poiché l'inverso degli elementi
non appartiene all'insieme.

Consideriamo l'insieme $\mathbb{Z}_{p}$ con $p$ un primo, e l'insieme
$\mathbb{Z}_{n}$ con $n$ composto: il primo è un campo, mentre il
secondo no, dato che i suoi elementi hanno inverso moltiplicativo
solo se primi relativi rispetto a $n$.

Infine, l'insieme delle matrici $2\times2$ non forma un campo, perché
non gode della proprietà commutativa e non tutti i suoi elementi sono
invertibili.\demo
\end{example}
Vale in generale la seguente proprietà, che lega i campi di Galois
alla cardinalità degli insiemi di interi:
\begin{defn}
Per ogni intero, esprimibile come potenza di un primo, esiste esattamente
un solo campo finito di $p^{n}$ elementi, chiamato campo di Galois
$p^{n}$:
\begin{equation}
\forall p^{n}\exists!\,\mathcal{GF}\left(p^{n}\right)\tc\left|\mathcal{GF}\left(p^{n}\right)\right|=p^{n}\label{eq:GF-p^n-cardinalit=0000E0}
\end{equation}
\end{defn}
Possiamo domandarci se l'insieme dei residui modulo $p^{n}$ ($\mathbb{Z}_{p^{n}}$)
sia un campo di Galois: esso non lo è, perché solo i suoi elementi
primi relativi rispetto a $p^{n}$ ammettono inverso. Usiamo la seguente
procedura, che permette di costruire in generale un insieme che sia
un campo $\mathcal{GF}\left(p^{n}\right)$ tramite l'impiego dei polinomi
(avremmo potuto rappresentare il campo di Galois tramite qualsiasi
simbolo di qualunque alfabeto).

Usiamo l'insieme dei residui modulo $p$, e l'insieme di tutti i polinomi
nella variabile $x$, di qualunque grado, con coefficienti modulo
$p$: 
\[
\mathbb{Z}_{p},\quad\mathbb{Z}_{p}\left[x\right]=\serie{i=0}n{a_{i}x^{i}}\,\forall a_{i}\in\mathbb{Z}_{p}
\]
prendiamo un polinomio $P\left(x\right)$ di grado $n$, con coefficienti
$a_{i}$ in $\mathbb{Z}_{p}$, che sia irriducibile (impossibile da
scomporre nel prodotto di polinomi di grado inferiore).
\begin{example}
Prendiamo $p=2$, $n=2$. Scriviamo allora $P\left(x\right)=\mod{x^{2}+1}2$

Notiamo che $P\left(x\right)$ è riducibile, infatti $\cgm{x^{2}+1}{\left(x+1\right)\cdot\left(x+1\right)}2$.

Invece, possiamo usare il polinomio irriducibile $x^{2}+x+1$ per
definire $\mathcal{GF}\left(4\right)$. Per provare che un polinomio
sia riducibile o meno è necessario provare la divisione tra polinomi,
tenendo presente che le operazioni sono modulo $p$, provando tutti
i possibili divisori fino al grado $n/2$.\demo
\end{example}
\begin{rem}
\label{oss:Analogia-GF-insieme-residui}Adesso definiamo il campo
di Galois $p^{n}$ nel modo seguente:
\begin{equation}
\mathcal{GF}\left(p^{n}\right)=\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}\label{eq:GF-p^n-definizione}
\end{equation}
Possiamo osservare un'analogia con l'insieme dei resti interi modulo
$p$:
\end{rem}
\begin{flushleft}
\begin{table}[!h]
\begin{tabular}{>{\centering}p{0.4\textwidth}>{\centering}p{0.4\textwidth}}
primo $p$ & irriducibile $P\left(x\right)$\tabularnewline
\hline 
$\mathbb{Z}_{p}$ & $\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}$\tabularnewline
residui della divisione per un \uline{primo} $p$ & residui della divisione per un polinomio \uline{irriducibile} $P\left(x\right)$
di grado $n$\tabularnewline
\hline 
cardinalità $p$ & cardinalità $p^{n}$\tabularnewline
\end{tabular}
\end{table}
Un generico polinomio ottenuto secondo questa costruzione è al massimo
di grado $n-1$, essendo il resto di una divisione per un polinomio
di grado $n$; possiamo scrivere il polinomio $P\left(x\right)$ nella
seguente forma:
\[
P\left(x\right)=a_{n-1}\cdot x^{n-1}+a_{n-2}\cdot x^{n-2}+\ldots+a_{1}\cdot x+a_{0}
\]
I possibili polinomi di questa forma sono $p^{n}$, dato che ogni
singolo coefficiente è in modulo $p$, e si hanno in totale $n$ coefficienti.
\par\end{flushleft}

\begin{rem}
Qualunque polinomio appartenente a un campo di Galois ammette inverso.
Prendiamo dunque $a\left(x\right)\in\mathcal{GF}\left(p^{n}\right)$,
definito come descritto in questa sezione, l'inverso di $a\left(x\right)$
è l'elemento $a^{-1}\left(x\right)\in\mathcal{GF}\left(p^{n}\right)$
tale che
\[
\cgm{a^{-1}\left(x\right)\cdot a\left(x\right)}1{P\left(x\right)}
\]
Questo vale se $\mcd{a\left(x\right)}{P\left(x\right)}=1$, ma ciò
è sicuramente vero perché $P\left(x\right)$ è definito irriducibile;
se avessimo un polinomio composto (riducibile) al posto di $P\left(x\right)$,
avremmo un'analogia con l'insieme $\mathbb{Z}_{n}$ ($n$ composto),
nel quale solo gli elementi primi relativi rispetto a $n$ hanno l'inverso.
\end{rem}
%
\begin{rem}
Per definire un campo di Galois $p^{n}$ abbiamo bisogno di un polinomio
irriducibile di grado $n$; tuttavia vi è più di un solo polinomio
irriducibile, fissato il grado. Si verifica che, usando polinomi irriducibili
diversi dello stesso grado, si ottiene lo stesso campo di Galois da
entrambi: esso è uno e uno solo, da (\ref{eq:GF-p^n-cardinalit=0000E0}).

Dal punto di vista algebrico, si ottengono due campi \emph{isomorfi},
ovvero le relazioni biunivoche tra elementi di uno stesso insieme
coincidono con quelle dell'altro insieme.
\end{rem}
\begin{defn}
Un campo di Galois può essere definito tramite i resti $R\left(x\right)$
che derivano dalla divisione dei polinomi di qualunque grado $\mathbb{Z}_{p}\left[x\right]$
per il polinomio irriducibile $P\left(x\right)$:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Campo di Galois}{\footnotesize{}\index{Galois, campo di@{\footnotesize{}Galois, campo di}}}}[0.2cm]
\begin{equation}
\mathcal{GF}\left(p^{n}\right)\doteq\cgm{R\left(x\right)}{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}\label{eq:GF-p^n-residui}
\end{equation}
\end{defn}

\section{Polinomi come elementi generatori}

Come visto nell'Osservazione \ref{oss:Analogia-GF-insieme-residui},
il grado massimo di $R\left(x\right)$ sarà $n-1$, mentre i possibili
polinomi di grado fino a $n-1$ sono in totale $p^{n}$. Nella stessa
Osservazione, abbiamo mostrato un'analogia tra l'insieme dei residui
modulo $p$ e i campi di Galois definiti come residui della divisione
dei polinomi con coefficienti modulo $p$, per $P\left(x\right)$.

Possiamo estendere questa analogia al concetto di radice primitiva
(\ref{def:Radice-primitiva}), ovvero anche in $\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}$
ci saranno dei polinomi $g\left(x\right)$, chiamati elementi generatori,
tali che
\[
\cgm{g\left(x\right)^{n}}1{P\left(x\right)}
\]
Il minimo $n$ per il quale si verifica la precedente condizione è
chiamato ordine (\ref{eq:Ordine-di-intero}) del campo, e vale:
\begin{equation}
\ord{g\left(x\right)}=p^{n}-1\label{eq:Ordine-polinomio-irriducibile}
\end{equation}
Questo polinomio $g\left(x\right)$ sarà una radice primitiva del
campo; il numero di radici primitive di un campo sarà determinato
dal toziente dell'ordine, come $\varphi\left(p^{n}-1\right)$

\begin{table}[!h]
\begin{tabular}{>{\centering}p{0.4\textwidth}>{\centering}p{0.4\textwidth}}
$\mathbb{Z}_{p}$ & $\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}$\tabularnewline
\hline 
$\ord{\alpha}=p-1$ & $\ord{g\left(x\right)}=p^{n}-1$\tabularnewline
\hline 
$\varphi\left(p-1\right)$ & $\varphi\left(p^{n}-1\right)$\tabularnewline
\end{tabular}
\end{table}

\begin{rem}
Chiediamoci se esiste un caso in cui tutti gli elementi di un insieme
$\mathbb{Z}_{p}$ sono anche elementi generatori; dovrebbe valere
$\varphi\left(p-1\right)=p-1$, ma questo è impossibile, poiché $q$
è primo e $q-1$ risulta pari.

Nel campo $\mod{\mathbb{Z}_{p}\left[x\right]}{P\left(x\right)}$ invece
deve valere $\varphi\left(p^{n}-1\right)=p^{n}-1$, e ciò è possibile
poiché $p^{n}-1$ è primo per alcuni $n$, a patto che valga $p=2$
(per esempio, con $p=2$ e $n=5$, vale $p^{n}-1=31$ e il campo $\mathcal{GF}\left(2^{5}\right)$
avrà tutti gli elementi che sono anche generatori del campo).
\end{rem}
\begin{example}
Consideriamo\marginpar{Il polinomio di $\mathcal{GF}\left(256\right)$ mostrato in questo
esempio è quello utilizzato nel cifrario AES} il campo $\mathcal{GF}\left(256\right)$, ovvero $p=2$ e $n=8$;
possiamo definire questo campo a partire da qualunque polinomio irriducibile
$P\left(x\right)$ di grado 8, con i coefficienti modulo 2: prendiamo
\[
P\left(x\right)=x^{8}+x^{4}+x^{3}+x^{2}+x+1
\]
Gli elementi del campo, resti della divisione con $P\left(x\right)$,
avranno grado massimo 7; possiamo scriverli come
\[
R\left(x\right)=b_{7}\cdot x^{7}+b_{7}\cdot x^{7}+\ldots+b_{1}\cdot x+b_{0}
\]
I coefficienti di un polinomio $R\left(x\right)\in\mathcal{GF}\left(256\right)$
sono 8 e sono tutti in modulo 2 (valgono 0 o 1): essi possono essere
rappresentati da un Byte, e l'algoritmo dell'AES usa questa rappresentazione
per effettuare operazioni tra polinomi, all'interno di $\mathcal{GF}\left(256\right)$.
\end{example}

\section{Cardinalità dei polinomi irriducibili}

Abbiamo già concluso che il numero di elementi di un campo di Galois
$p^{n}$ è proprio $p^{n}$ ($\left|\mathcal{GF}\left(p^{n}\right)\right|=p^{n}$);
per definire il campo è necessario un polinomio irriducibile $P\left(x\right)$
di grado $n$ coi coefficienti modulo $p$. Ci chiediamo il numero
di tali polinomi; indichiamo allora il numero di polinomi irriducibili
con coefficienti modulo $p$ e grado $n$ come:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Numero di polinomi irriducibili}{\footnotesize{}\index{Polinomi irriducibili, numero@{\footnotesize{}Polinomi irriducibili, numero}}}}[0.3cm]
\begin{equation}
\nirr pn=\frac{1}{n}\serie{i=1,\,i\backslash n}n{\mu\left(\frac{n}{i}\right)\cdot p^{i}}\label{eq:Numero-polinomi-irriducibili}
\end{equation}
La funzione $\mu\left(\right)$ si chiama funzione di Möbius ed è
definita nel modo seguente:\marginpar{\rule[0.5ex]{3cm}{1pt}\textbf{\footnotesize{}}\protect \\
\textbf{\footnotesize{}Funzione di Möbius}{\footnotesize{}\index{Möbius, funzione di@{\footnotesize{}Möbius, funzione di}}}}[0.7cm]
\begin{equation}
\mu\left(n\right)=\begin{cases}
0 & n=\text{ prodotto di primi, almeno uno ripetuto}\\
1 & n=1\\
\left(-1\right)^{k} & n=\text{ prodotto di \ensuremath{k} primi distinti}
\end{cases}\label{eq:Funzione-Mobius}
\end{equation}

\begin{example}
\emph{Prendiamo i polinomi con coefficienti in modulo 2 e grado 6:
determinare il numero di polinomi irriducibili tra di essi.}
\end{example}
$\checked$Sappiamo che il numero totale di polinomi con queste caratteristiche
è $p^{n}=2^{6}=64$; usiamo la formula (\ref{eq:Numero-polinomi-irriducibili}):
\begin{align*}
\nirr 26 & =\frac{1}{6}\left(\mu\left(6\right)\cdot2^{1}+\mu\left(3\right)\cdot2^{2}+\mu\left(2\right)\cdot2^{3}+\mu\left(1\right)\cdot2^{6}\right)\\
 & =\frac{1}{6}\left(2-2^{2}-2^{3}+2^{6}\right)=\frac{54}{6}=\boxed{9}
\end{align*}
Abbiamo usato nella sommatoria i valori da 0 a 6 che dividono 6, ovvero
$i\in\left\{ 1,\,2,\,3,\,6\right\} $.\demo

\renewcommand{\chaptername}{}\printindex
\end{document}
